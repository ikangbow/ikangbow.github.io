<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="The Pursuit of Happyness">
<meta property="og:type" content="website">
<meta property="og:title" content="Airthink">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Airthink">
<meta property="og:description" content="The Pursuit of Happyness">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Airthink">
<meta name="twitter:description" content="The Pursuit of Happyness">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Airthink</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Airthink</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/GIT使用详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/GIT使用详解/" itemprop="url">Git使用详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T17:23:22+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git的安装和使用"><a href="#Git的安装和使用" class="headerlink" title="Git的安装和使用"></a>Git的安装和使用</h1><h2 id="下载安装Git"><a href="#下载安装Git" class="headerlink" title="下载安装Git"></a>下载安装Git</h2><pre><code>[https://git-scm.com/download/win](https://git-scm.com/download/win &quot;下载Git&quot;)
</code></pre><p><img src="/2020/06/17/GIT使用详解/1.png" alt=""></p>
<h2 id="下载完成后双击安装"><a href="#下载完成后双击安装" class="headerlink" title="下载完成后双击安装"></a>下载完成后双击安装</h2><h2 id="检验是否安装完成"><a href="#检验是否安装完成" class="headerlink" title="检验是否安装完成"></a>检验是否安装完成</h2><p>鼠标右击如果看到有两个git单词则安装成功</p>
<p><img src="/2020/06/17/GIT使用详解/2.png" alt=""></p>
<h1 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h1><h2 id="Git的工作区域"><a href="#Git的工作区域" class="headerlink" title="Git的工作区域"></a>Git的工作区域</h2><p><img src="/2020/06/17/GIT使用详解/3.png" alt=""></p>
<h2 id="向仓库中添加文件流程"><a href="#向仓库中添加文件流程" class="headerlink" title="向仓库中添加文件流程"></a>向仓库中添加文件流程</h2><p><img src="/2020/06/17/GIT使用详解/4.png" alt=""></p>
<h1 id="Git初始化及仓库创建和操作"><a href="#Git初始化及仓库创建和操作" class="headerlink" title="Git初始化及仓库创建和操作"></a>Git初始化及仓库创建和操作</h1><h2 id="Git安装之后需要进行一些基本信息设置"><a href="#Git安装之后需要进行一些基本信息设置" class="headerlink" title="Git安装之后需要进行一些基本信息设置"></a>Git安装之后需要进行一些基本信息设置</h2><ol>
<li>设置用户名：git  config – global  user.name  ‘你再github上注册的用户名’;</li>
<li>设置用户邮箱：git  config – global  user.email  ‘注册时候的邮箱’;</li>
</ol>
<p>注意：该配置会在github主页上显示谁提交了该文件</p>
<ol start="3">
<li>配置ok之后，我们用如下命令来看看是否配置成功</li>
</ol>
<p>　　git config –list</p>
<p>注意：git  config –global 参数，有了这个参数表示你这台机器上所有的git仓库都会使用这个配置，当然你也可以对某个仓库指定不同的用户名和邮箱</p>
<h2 id="初始化一个新的git仓库"><a href="#初始化一个新的git仓库" class="headerlink" title="初始化一个新的git仓库"></a>初始化一个新的git仓库</h2><ol>
<li>创建文件夹</li>
</ol>
<p>　　　　方法一：可以鼠标右击-》点击新建文件夹test1</p>
<p>　　　　方法二：使用git新建：$  mkdir test1</p>
<p><img src="/2020/06/17/GIT使用详解/5.png" alt=""></p>
<ol start="2">
<li>在文件内初始化git（创建git仓库）</li>
</ol>
<p>　　　　方法一：直接输入 $ cd test1</p>
<p>　　　　方法一：点击test1文件下进去之后-》鼠标右击选择Git Bash Here-&gt;输入$ git int</p>
<p><img src="/2020/06/17/GIT使用详解/6.png" alt=""></p>
<ol start="3">
<li>向仓库中添加文件　　</li>
</ol>
<p>　　方法一：用打开编辑器新建index.html文件</p>
<p>　　方法二：使用git命令。$  touch ‘文件名’，然后把文件通过$ git add ‘文件名’添加到暂存区，最后提交操作</p>
<p><img src="/2020/06/17/GIT使用详解/7.png" alt=""></p>
<ol start="4">
<li>修改仓库文件</li>
</ol>
<p>　　方法一：用编辑器打开index.html进行修改</p>
<p>　　方法二：使用git命令。$  vi  ‘文件名’，然后在中间写内容，最后提交操作</p>
<p><img src="/2020/06/17/GIT使用详解/8.png" alt=""></p>
<p><img src="/2020/06/17/GIT使用详解/9.png" alt=""></p>
<ol start="5">
<li>删除仓库文件</li>
</ol>
<p>　　方法一：在编辑器中直接把要删除的文件删除掉</p>
<p>　　方法二：使用git删除：$ git rm ‘文件名’，然后提交操作</p>
<p><img src="/2020/06/17/GIT使用详解/10.png" alt=""></p>
<h1 id="Git管理远程仓库"><a href="#Git管理远程仓库" class="headerlink" title="Git管理远程仓库"></a>Git管理远程仓库</h1><p><img src="/2020/06/17/GIT使用详解/11.png" alt=""></p>
<h1 id="Git克隆操作"><a href="#Git克隆操作" class="headerlink" title="Git克隆操作"></a>Git克隆操作</h1><p>目的：将远程仓库（github上对应的项目）复制到本地</p>
<p><img src="/2020/06/17/GIT使用详解/12.png" alt=""></p>
<h2 id="代码：git-clone-仓库地址"><a href="#代码：git-clone-仓库地址" class="headerlink" title="代码：git clone 仓库地址"></a>代码：git clone 仓库地址</h2><p>仓库地址由来如下：</p>
<h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p><img src="/2020/06/17/GIT使用详解/13.png" alt=""></p>
<h2 id="将本地仓库同步到git远程仓库中：git-push"><a href="#将本地仓库同步到git远程仓库中：git-push" class="headerlink" title="将本地仓库同步到git远程仓库中：git push"></a>将本地仓库同步到git远程仓库中：git push</h2><p><img src="/2020/06/17/GIT使用详解/14.png" alt=""></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><img src="/2020/06/17/GIT使用详解/15.png" alt=""></p>
<p>解决：这是通过Git GUI进行提交时发生的错误，由 .git 文件夹中的文件被设为“只读”所致，将 .git 文件夹下的所有文件、文件夹及其子文件的只读属性去掉即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/08/消息队列5个应用场景/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/08/消息队列5个应用场景/" itemprop="url">消息队列5个应用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-08T15:49:23+08:00">
                2020-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削峰等问题，实现高性能、高可用、可伸缩和最终一致性架构，使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ。</p>
<h2 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>场景说明：用户注册后，需要发送注册邮件和注册短信，传统的做法有两种，串行的方式和并行的方式。</p>
<p>串行方式：将注册信息写入数据库成功后，发送注册邮件，在发送注册短信，以上三个任务全部完成后，返回给用户。</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 160339.png" alt=""></p>
<p>并行的方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信，以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 160514.png" alt=""></p>
<p>假设三个业务节点每个使用50毫秒，不考虑网络等其他开销，则串行方式时间是150毫秒，并行的时间是100毫秒。</p>
<p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内的吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求是10（1000/100）次。</p>
<p>如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈，如何解决呢？</p>
<p>引入消息队列，将不是必须的业务逻辑，异步处理，改造后如下</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 160530.png" alt=""></p>
<p>按照以上约定，用户的响应时间想当与是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能就是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了2倍。</p>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 161344.png" alt=""></p>
<p>缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统存在耦合</p>
<p>解决：引入应用消息队列</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 161632.png" alt=""></p>
<p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</p>
<p>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</p>
<p>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</p>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>流量削峰也是消息队列中常用的场景，一般在秒杀或团抢活动中使用广泛。</p>
<p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端假如消息队列。</p>
<p>可以控制活动的人数，可以缓解短时间内高流量压垮应用。</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 162324.png" alt=""></p>
<p>用户的请求，服务器接收到后先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误的页面。</p>
<p>秒杀业务根据消息队列中的请求信息，再做后续处理。</p>
<h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>日志处理是指将消息ui列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 162722.png" alt=""></p>
<p>日志采集客户端，负责日志数据采集，定时写入Kafka队列；Kafak消息队列，负责日志数据的接收，存储和转发；日志处理应用：订阅并消费kafaka队列中的日志数据。</p>
<p>以下是新浪kafka日志处理应用案例：</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 163012.png" alt=""></p>
<p> Kafka:接收用户日志的消息队列；</p>
<p> Logstach:做日志解析，统一成JSON传输给Elasticsearch;</p>
<p> Elasticsearch:实时日志分析服务的核心技术，一个schemaless,实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</p>
<p> Kibaba:基于Elasticsearch的数据可视化组件，超强的数据可视化能力</p>
<h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。</p>
<p><img src="/2020/06/08/消息队列5个应用场景/批注 2020-06-08 163623.png" alt=""></p>
<p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p>
<h2 id="实战用redis实现简单的发布-订阅"><a href="#实战用redis实现简单的发布-订阅" class="headerlink" title="实战用redis实现简单的发布/订阅"></a>实战用redis实现简单的发布/订阅</h2><p>场景：两台tomcat做集群，配置文件不同时生效的问题</p>
<pre><code>&lt;bean id=&quot;messageContainer&quot;
    class=&quot;org.springframework.data.redis.listener.RedisMessageListenerContainer&quot;
    destroy-method=&quot;destroy&quot;&gt;
    &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot; /&gt;
    &lt;property name=&quot;messageListeners&quot;&gt;
        &lt;map&gt;
            &lt;entry key-ref=&quot;subService&quot;&gt;
                &lt;ref bean=&quot;channelTopic&quot; /&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;channelTopic&quot; class=&quot;org.springframework.data.redis.listener.ChannelTopic&quot;&gt;
    &lt;constructor-arg value=&quot;server:topic&quot; /&gt;
&lt;/bean&gt;

@Service
public class PubServiceImpl implements PubService {

    private static final Logger logger = Logger.getLogger(PubService.class);

    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;

    private String channelTopic = &quot;server:topic&quot;;

    public void publish(String str) {
        //String str = JsonUtils.toJson(message);
        logger.error(&quot;Publish message:&quot; + str + &quot;, topic:&quot; + channelTopic);
        redisTemplate.convertAndSend(channelTopic, str);
    }

    public void publish(Map&lt;String, Object&gt; message) {
        String str = JsonUtils.toJson(message);
        logger.error(&quot;Publish message:&quot; + str + &quot;, topic:&quot; + channelTopic);
        redisTemplate.convertAndSend(channelTopic, str);
    }
}

@Service(&quot;subService&quot;)
public class SubServiceImpl implements MessageListener {

    private static final Logger logger = Logger.getLogger(SubServiceImpl.class);

    @Autowired
    private ChannelTopic channelTopic;

    @Override
    public void onMessage(Message message, byte[] pattern) {
        String str = message.toString();
        logger.error(&quot;Subscribe message:&quot; + str + &quot;, topic:&quot; + channelTopic.getTopic());
        try {
            String type =  m.getType();
            if (&quot;config&quot;.equals(type)) {
                System.out.println(&quot;接收到消息，doSomething========&quot;);
            }else if(&quot;me&quot;.equals(type)){
                System.out.println(&quot;接收到消息，doSomething========&quot;);
            }else{
                System.out.println(&quot;接收到消息，doSomething========&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/08/JAVA的map/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/08/JAVA的map/" itemprop="url">JAVA的map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-08T11:45:45+08:00">
                2020-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Map的用法"><a href="#Map的用法" class="headerlink" title="Map的用法"></a>Map的用法</h1><h2 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h2><ul>
<li><p>HashMap</p>
<p>  最常用的Map,它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为null（多条会覆盖）；允许多条记录的值为null。非同步的。</p>
</li>
<li><p>TreeMap</p>
<p>  能够把它保存的记录根据键（key）排序，默认是按升序排序，也可指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</p>
</li>
<li><p>Hashtable</p>
<p>  与HashMap类似，不同的是：key和value的值均不允许为null;它支持线程同步，即任一时刻只有一个线程能写HashTable,因此也导致了HashTable在写入时会比较慢。</p>
</li>
<li><p>LinkedHashMap</p>
<p>  保存了记录的插入顺序，在使用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢。key和value均允许为空。非同步的。</p>
</li>
</ul>
<h2 id="Map用法"><a href="#Map用法" class="headerlink" title="Map用法"></a>Map用法</h2><pre><code>用法
Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();

插入元素

map.put(&quot;key1&quot;,&quot;value1&quot;);

获取元素

map.get(&quot;key1&quot;);

移除元素

map.remove(&quot;key1&quot;)
</code></pre><h2 id="四种常用Map插入与读取性能比较"><a href="#四种常用Map插入与读取性能比较" class="headerlink" title="四种常用Map插入与读取性能比较"></a>四种常用Map插入与读取性能比较</h2><p><img src="/2020/06/08/JAVA的map/批注 2020-06-08 124807.png" alt=""></p>
<pre><code>测试代码

package net.xsoftlab.baike;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;
import java.util.UUID;
public class Test {
    static int hashMapW = 0;
    static int hashMapR = 0;
    static int linkMapW = 0;
    static int linkMapR = 0;
    static int treeMapW = 0;
    static int treeMapR = 0;
    static int hashTableW = 0;
    static int hashTableR = 0;
    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            Test test = new Test();
            test.test(100 * 10000);
            System.out.println();
        }
        System.out.println(&quot;hashMapW = &quot; + hashMapW / 10);
        System.out.println(&quot;hashMapR = &quot; + hashMapR / 10);
        System.out.println(&quot;linkMapW = &quot; + linkMapW / 10);
        System.out.println(&quot;linkMapR = &quot; + linkMapR / 10);
        System.out.println(&quot;treeMapW = &quot; + treeMapW / 10);
        System.out.println(&quot;treeMapR = &quot; + treeMapR / 10);
        System.out.println(&quot;hashTableW = &quot; + hashTableW / 10);
        System.out.println(&quot;hashTableR = &quot; + hashTableR / 10);
    }
    public void test(int size) {
        int index;
        Random random = new Random();
        String[] key = new String[size];
        // HashMap 插入
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            key[i] = UUID.randomUUID().toString();
            map.put(key[i], UUID.randomUUID().toString());
        }
        long end = System.currentTimeMillis();
        hashMapW += (end - start);
        System.out.println(&quot;HashMap插入耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // HashMap 读取
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            index = random.nextInt(size);
            map.get(key[index]);
        }
        end = System.currentTimeMillis();
        hashMapR += (end - start);
        System.out.println(&quot;HashMap读取耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // LinkedHashMap 插入
        map = new LinkedHashMap&lt;String, String&gt;();
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            key[i] = UUID.randomUUID().toString();
            map.put(key[i], UUID.randomUUID().toString());
        }
        end = System.currentTimeMillis();
        linkMapW += (end - start);
        System.out.println(&quot;LinkedHashMap插入耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // LinkedHashMap 读取
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            index = random.nextInt(size);
            map.get(key[index]);
        }
        end = System.currentTimeMillis();
        linkMapR += (end - start);
        System.out.println(&quot;LinkedHashMap读取耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // TreeMap 插入
        key = new String[size];
        map = new TreeMap&lt;String, String&gt;();
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            key[i] = UUID.randomUUID().toString();
            map.put(key[i], UUID.randomUUID().toString());
        }
        end = System.currentTimeMillis();
        treeMapW += (end - start);
        System.out.println(&quot;TreeMap插入耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // TreeMap 读取
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            index = random.nextInt(size);
            map.get(key[index]);
        }
        end = System.currentTimeMillis();
        treeMapR += (end - start);
        System.out.println(&quot;TreeMap读取耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // Hashtable 插入
        key = new String[size];
        map = new Hashtable&lt;String, String&gt;();
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            key[i] = UUID.randomUUID().toString();
            map.put(key[i], UUID.randomUUID().toString());
        }
        end = System.currentTimeMillis();
        hashTableW += (end - start);
        System.out.println(&quot;Hashtable插入耗时 = &quot; + (end - start) + &quot; ms&quot;);
        // Hashtable 读取
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; size; i++) {
            index = random.nextInt(size);
            map.get(key[index]);
        }
        end = System.currentTimeMillis();
        hashTableR += (end - start);
        System.out.println(&quot;Hashtable读取耗时 = &quot; + (end - start) + &quot; ms&quot;);
    }
}
</code></pre><h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><h3 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h3><pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put(&quot;key1&quot;,&quot;value1&quot;);
map.put(&quot;key2&quot;,&quot;value2&quot;);
</code></pre><h3 id="增强for循环遍历"><a href="#增强for循环遍历" class="headerlink" title="增强for循环遍历"></a>增强for循环遍历</h3><p>使用keySet()遍历</p>
<pre><code>for(String key:map.keySet()){
    System.out.println(key+&quot;:&quot;+map.get(key))
}
</code></pre><p>使用entrySet()遍历</p>
<pre><code>for(Map.Entry&lt;String,String&gt; entry:map.entrySet()){
    System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
}
</code></pre><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>使用keySet()遍历</p>
<pre><code>Iterator&lt;String&gt; iterator = map.keySet().iterator();
while(iterator.hasNext()){
    String key = iterator.next();
    System.out.println(key+&quot;:&quot;+map.get(key));
}
</code></pre><p>使用entrySet()遍历</p>
<pre><code>Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iterator = map.entrySet().iterator();
while(iterator.hasNext()){
    Map.Entry&lt;String,String&gt; entry = iterator.next();
    System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
}
</code></pre><h2 id="HashMap四种遍历方式性能比较"><a href="#HashMap四种遍历方式性能比较" class="headerlink" title="HashMap四种遍历方式性能比较"></a>HashMap四种遍历方式性能比较</h2><pre><code>package net.xsoftlab.baike;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
public class TestMap {
    public static void main(String[] args) {
        // 初始化，10W次赋值
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 0; i &lt; 100000; i++)
            map.put(i, i);
        /** 增强for循环，keySet迭代 **/
        long start = System.currentTimeMillis();
        for (Integer key : map.keySet()) {
            map.get(key);
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;增强for循环，keySet迭代 -&gt; &quot; + (end - start) + &quot; ms&quot;);
        /** 增强for循环，entrySet迭代 */
        start = System.currentTimeMillis();
        for (Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {
            entry.getKey();
            entry.getValue();
        }
        end = System.currentTimeMillis();
        System.out.println(&quot;增强for循环，entrySet迭代 -&gt; &quot; + (end - start) + &quot; ms&quot;);
        /** 迭代器，keySet迭代 **/
        start = System.currentTimeMillis();
        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();
        Integer key;
        while (iterator.hasNext()) {
            key = iterator.next();
            map.get(key);
        }
        end = System.currentTimeMillis();
        System.out.println(&quot;迭代器，keySet迭代 -&gt; &quot; + (end - start) + &quot; ms&quot;);
        /** 迭代器，entrySet迭代 **/
        start = System.currentTimeMillis();
        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator1 = map.entrySet().iterator();
        Map.Entry&lt;Integer, Integer&gt; entry;
        while (iterator1.hasNext()) {
            entry = iterator1.next();
            entry.getKey();
            entry.getValue();
        }
        end = System.currentTimeMillis();
        System.out.println(&quot;迭代器，entrySet迭代 -&gt; &quot; + (end - start) + &quot; ms&quot;);
    }
}

运行三次，比较结果 第一次
增强for循环，keySet迭代 -&gt; 37 ms
增强for循环，entrySet迭代 -&gt; 19 ms
迭代器，keySet迭代 -&gt; 14 ms
迭代器，entrySet迭代 -&gt; 9 ms

增强for循环，keySet迭代 -&gt; 29 ms
增强for循环，entrySet迭代 -&gt; 22 ms
迭代器，keySet迭代 -&gt; 19 ms
迭代器，entrySet迭代 -&gt; 12 ms

增强for循环，keySet迭代 -&gt; 27 ms
增强for循环，entrySet迭代 -&gt; 19 ms
迭代器，keySet迭代 -&gt; 18 ms
迭代器，entrySet迭代 -&gt; 10 ms
</code></pre><p>总结：</p>
<ol>
<li>增强for循环使用方便，但性能较差，不适合处理超大量级的数据。</li>
<li>迭代器的遍历速度要比增强for循环快很多，是增强for循环的2倍左右。</li>
<li>使用entrySet遍历的速度比keySet快很多，是keySet的1.5倍左右。</li>
</ol>
<h2 id="Map排序"><a href="#Map排序" class="headerlink" title="Map排序"></a>Map排序</h2><p>HashMap、HashTable、LinkedHashMap排序</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put(&quot;b&quot;,&quot;b&quot;);
map.put(&quot;a&quot;,&quot;c&quot;);
map.put(&quot;c&quot;,&quot;a&quot;);
//排序
List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String, String&gt;&gt;(map.entrySet().size());
Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() {
    @Override
    public int compare(Map.Entry&lt;String, String&gt; o1, Map.Entry&lt;String, String&gt; o2) {
        return o1.getKey().compareTo(o2.getKey());
    }
});

for (Map.Entry&lt;String,String&gt; mapping:
list) {
    System.out.println(mapping.getKey()+&quot;:&quot;+mapping.getValue());
}
</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code>Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(new Comparator&lt;String&gt;() {
    @Override
    public int compare(String o1, String o2) {
        // 降序排序
        return o1.compareTo(o2);
    }
});
map.put(&quot;b&quot;, &quot;b&quot;);
map.put(&quot;a&quot;, &quot;c&quot;);
map.put(&quot;c&quot;, &quot;a&quot;);
for (String key : map.keySet()) {
    System.out.println(key + &quot; ：&quot; + map.get(key));
}
</code></pre><h3 id="按value排序-通用"><a href="#按value排序-通用" class="headerlink" title="按value排序(通用)"></a>按value排序(通用)</h3><pre><code>Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;();
map.put(&quot;b&quot;, &quot;b&quot;);
map.put(&quot;a&quot;, &quot;c&quot;);
map.put(&quot;c&quot;, &quot;a&quot;);
// 通过ArrayList构造函数把map.entrySet()转换成list
List&lt;Map.Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String, String&gt;&gt;(map.entrySet());
// 通过比较器实现比较排序
Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() {
    @Override
    public int compare(Map.Entry&lt;String, String&gt; mapping1, Map.Entry&lt;String, String&gt; mapping2) {
        return mapping1.getValue().compareTo(mapping2.getValue());
    }
});
for (String key : map.keySet()) {
    System.out.println(key + &quot; ：&quot; + map.get(key));
}
</code></pre><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p><img src="/2020/06/08/JAVA的map/批注 2020-06-08 141629.png" alt=""></p>
<h2 id="扩展List如何一边遍历一边删除"><a href="#扩展List如何一边遍历一边删除" class="headerlink" title="扩展List如何一边遍历一边删除"></a>扩展List如何一边遍历一边删除</h2><pre><code>public static void main(String[] args) {
    List&lt;String&gt; platformList = new ArrayList&lt;&gt;();
    platformList.add(&quot;博客园&quot;);
    platformList.add(&quot;CSDN&quot;);
    platformList.add(&quot;掘金&quot;);

    for (String platform : platformList) {
        if (platform.equals(&quot;博客园&quot;)) {
            platformList.remove(platform);
        }
    }

    System.out.println(platformList);
}

java.util.ConcurrentModificationException异常了，翻译成中文就是：并发修改异常
</code></pre><h3 id="使用Iterator的remove-方法"><a href="#使用Iterator的remove-方法" class="headerlink" title="使用Iterator的remove()方法"></a>使用Iterator的remove()方法</h3><pre><code>public static void main(String[] args) {
    List&lt;String&gt; platformList = new ArrayList&lt;&gt;();
    platformList.add(&quot;博客园&quot;);
    platformList.add(&quot;CSDN&quot;);
    platformList.add(&quot;掘金&quot;);

    Iterator&lt;String&gt; iterator = platformList.iterator();
    while (iterator.hasNext()) {
        String platform = iterator.next();
        if (platform.equals(&quot;博客园&quot;)) {
            iterator.remove();
        }
    }

    System.out.println(platformList);
}
</code></pre><h3 id="使用for循环正序遍历"><a href="#使用for循环正序遍历" class="headerlink" title="使用for循环正序遍历"></a>使用for循环正序遍历</h3><pre><code>public static void main(String[] args) {
    List&lt;String&gt; platformList = new ArrayList&lt;&gt;();
    platformList.add(&quot;博客园&quot;);
    platformList.add(&quot;CSDN&quot;);
    platformList.add(&quot;掘金&quot;);

    for (int i = 0; i &lt; platformList.size(); i++) {
        String item = platformList.get(i);

        if (item.equals(&quot;博客园&quot;)) {
            platformList.remove(i);
            i = i - 1;
        }
    }

    System.out.println(platformList);
}
</code></pre><h3 id="使用for循环倒序遍历"><a href="#使用for循环倒序遍历" class="headerlink" title="使用for循环倒序遍历"></a>使用for循环倒序遍历</h3><pre><code>public static void main(String[] args) {
    List&lt;String&gt; platformList = new ArrayList&lt;&gt;();
    platformList.add(&quot;博客园&quot;);
    platformList.add(&quot;CSDN&quot;);
    platformList.add(&quot;掘金&quot;);

    for (int i = platformList.size() - 1; i &gt;= 0; i--) {
        String item = platformList.get(i);

        if (item.equals(&quot;掘金&quot;)) {
            platformList.remove(i);
        }
    }

    System.out.println(platformList);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/JSON对象和JSON字符串/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/JSON对象和JSON字符串/" itemprop="url">JSON对象和JSON字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T18:31:07+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h1><h2 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h2><p>对象的属性是可以用： 对象.属性进行调用的。</p>
<pre><code>var person={&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;}//json对象
console.log(person.name);//在控制台输出tom
alert(typeof(person));//object
</code></pre><p>以上就是json对象。是一个可以用person.name这种方式进行属性的调用。<br>第三行代码就是看person的类型为object类型</p>
<h1 id="JSON字符串"><a href="#JSON字符串" class="headerlink" title="JSON字符串"></a>JSON字符串</h1><h2 id="字符串，JS中的字符串是单引号或者双引号引起来的。那么json字符串就是如下"><a href="#字符串，JS中的字符串是单引号或者双引号引起来的。那么json字符串就是如下" class="headerlink" title="字符串，JS中的字符串是单引号或者双引号引起来的。那么json字符串就是如下"></a>字符串，JS中的字符串是单引号或者双引号引起来的。那么json字符串就是如下</h2><pre><code>var b = &apos;{&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;}&apos;;//json字符串
console.log(b);//{&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;};
alert(typeof(b));//string
</code></pre><p>以上b就是一个字符串，是一个string类型</p>
<h1 id="JSON字符串和JSON对象的转换"><a href="#JSON字符串和JSON对象的转换" class="headerlink" title="JSON字符串和JSON对象的转换"></a>JSON字符串和JSON对象的转换</h1><h2 id="JSON字符串转json对象，调用parse方法；"><a href="#JSON字符串转json对象，调用parse方法；" class="headerlink" title="JSON字符串转json对象，调用parse方法；"></a>JSON字符串转json对象，调用parse方法；</h2><pre><code>var b = &apos;{&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;}&apos;;//json字符串
console.log(b);//{&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;};
alert(typeof(b));//string
var objb = JSON.parse(b);
console.log(objb.name);
</code></pre><h2 id="JSON对象转JSON字符串"><a href="#JSON对象转JSON字符串" class="headerlink" title="JSON对象转JSON字符串"></a>JSON对象转JSON字符串</h2><pre><code>var person={&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;}//json对象
console.log(person.name);//在控制台输出tom
alert(typeof(person));//object
var personStr = JSON.stringify(person);
alert(typeof(personStr));//string
console.log(personStr);//{&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;}
</code></pre><h2 id="字符串转json对象"><a href="#字符串转json对象" class="headerlink" title="字符串转json对象"></a>字符串转json对象</h2><pre><code>场景：
    后台返回的person对象上有herf属性，是一个字符串
href = {&apos;href&apos;:&apos;../juvenile/summerCamp/summerCamp.html&apos;,&apos;isLogined&apos;:&apos;1&apos;,&apos;param&apos;:{&apos;activityId&apos;:&apos;2141108450038362510&apos;}}

要解析到herf

var configData = eval(&apos;(&apos; + href + &apos;)&apos;);//由字符串转换为JSON对象

console.log(configData.href)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/SpringSecurity验证流程解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/28/SpringSecurity验证流程解析/" itemprop="url">SpringSecurity验证流程解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-28T21:08:05+08:00">
                2020-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><ol>
<li><p>TokenAuthenticationFilter</p>
<pre><code>if (httpRequest.getServletPath().equals(loginLink)) {
    //如果是登录或注销的话，设置不沿着过滤器向下
    doNotContinueWithRequestProcessing(httpRequest);
    checkLoginAnDoSomething(httpRequest, httpResponse, token);
}
</code></pre></li>
<li><p>checkLoginAnDoSomething(httpRequest, httpResponse, token);</p>
<pre><code>example: Authorization=Basic YWRtaW46MTIzNDU2 (admin:123456)

private boolean checkLoginAnDoSomething(HttpServletRequest httpRequest, HttpServletResponse httpResponse,
    String token) throws IOException {
    String authorization = httpRequest.getHeader(CacheConstant.AUTHORIZATION);
    ReturnStatus result = null;
    if (authorization != null) {
        result = checkBasicAuthorization(authorization, httpRequest, httpResponse, token);
    }

    if (null == result) {
        result = new ReturnStatus(false);
        result.getErrors().add(new MError(MErrorCode.e9000));
        result.setMessage(MErrorCode.e9000.desc());
    }

    String body;
    try {
        body = JsonUtils.toJson(result);// JsonParserFactory.getParser().toJson(result).toString();
        httpResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);
        httpResponse.getWriter().write(body);
    } catch (Exception e) {
        throw new IOException(e);
    }

    return result.isSuccess();
</code></pre><p> }</p>
</li>
<li><p>checkBasicAuthorization(authorization, httpRequest, httpResponse, token);</p>
<pre><code>private ReturnStatus checkBasicAuthorization(String authorization, HttpServletRequest httpRequest,
        HttpServletResponse httpResponse, String token) throws IOException {
    StringTokenizer tokenizer = new StringTokenizer(authorization);
    if (tokenizer.countTokens() &lt; 2) {
        return null;
    }
    if (!tokenizer.nextToken().equalsIgnoreCase(CacheConstant.BASIC_AUTH_PREFIX)) {
        return null;
    }

    String base64 = tokenizer.nextToken();
    String loginPassword = new String(Base64.decode(base64.getBytes(StandardCharsets.UTF_8)));
    tokenizer = new StringTokenizer(loginPassword, &quot;:&quot;);
    String username = tokenizer.nextToken();
    String pwd = tokenizer.nextToken();
    String password = passwordEncoder.encodePassword(pwd, null);
    ReturnStatus status = checkUsernameAndPassword(username, password, httpRequest, httpResponse, token);
    // 登录成功后返回登录状态
    return status;
}
</code></pre></li>
<li><p>private ReturnStatus checkUsernameAndPassword(String username, String password, HttpServletRequest httpRequest,HttpServletResponse httpResponse, String oldtoken)</p>
<pre><code>private ReturnStatus checkUsernameAndPassword(String username, String password, HttpServletRequest httpRequest,
        HttpServletResponse httpResponse, String oldtoken) throws IOException {
    ReturnStatus returnResult = new ReturnStatus(false);
    TokenInfo tokenInfo = authenticationService.authenticate(username, password, httpRequest);
    if (tokenInfo != null &amp;&amp; tokenInfo.getUserDetails() != null) {
        VerifyContext verifyContext = (VerifyContext) tokenInfo.getUserDetails();
        Account account = (Account) verifyContext.getUser().getEntity();
        if (account.isLogin()) {
            if (null != oldtoken &amp;&amp; !&quot;&quot;.equals(oldtoken) &amp;&amp; !&quot;null&quot;.equals(oldtoken)
                    &amp;&amp; !&quot;undefined&quot;.equals(oldtoken)) {
                logger.info(&quot;tokenInfo.setToken use the oldtoken Token :{}&quot;, tokenInfo.getToken());
                tokenInfo.setToken(oldtoken);
            }
            logger.info(&quot;the new Token :{},entity:{}&quot;, tokenInfo.getToken(), tokenInfo);
            this.cacheManager.saveObject(CacheEnum.TOKEN, tokenInfo.getToken(), tokenInfo.getUserDetails(),
                    CacheConstant.USER_SESSION_TIME);
            logger.info(&quot;the token:{}, save object:{}&quot;, tokenInfo.getToken(),
                    this.cacheManager.getObject(CacheEnum.TOKEN, tokenInfo.getToken()));
            returnResult.setEntity(account);
            returnResult.setSuccess(true);
        } else {
            returnResult.getErrors().add(new MError(MErrorCode.e9001));
            returnResult.setMessage(MErrorCode.e9001.desc());
        }
        httpResponse.setHeader(CacheConstant.HEADER_TOKEN, tokenInfo.getToken());
    } else {
        logger.error(&quot;User {} ,Password {} Unauthorized!&quot;, username, password);
        returnResult.getErrors().add(new MError(MErrorCode.e9000));
        returnResult.setMessage(MErrorCode.e9000.desc());
    }
    return returnResult;
}
</code></pre></li>
</ol>
<h2 id="基于用户-角色-权限设计"><a href="#基于用户-角色-权限设计" class="headerlink" title="基于用户-角色-权限设计"></a>基于用户-角色-权限设计</h2><pre><code>Account

accountName//账号名
accountPwd//密码
status//状态
accountType//账号类型
entityID//实体id
lastLoginTime//最后一次登录时间
loginTimes//登录次数
roleIds//角色列表
//一个账号可以关联角色，角色呈树状结构，可多选

Function

name//功能点名称
parentId//父级
memo//描述
action//资源url
order//排序
icon//图标
permissionCode//唯一权限标识
permissionName//权限名称

Role

name//角色名称
parentId//父级
memo//描述
functionIds//功能点
order//排序
//角色也是呈树状菜单的，角色里面有权限配置，所有的功能点以树状结构展示，通过角色去关联功能点
</code></pre><h2 id="递归菜单和角色"><a href="#递归菜单和角色" class="headerlink" title="递归菜单和角色"></a>递归菜单和角色</h2><pre><code>// 获取标准JSON数据
public static List&lt;Map&lt;String, Object&gt;&gt; getStandardJSON() {
    // 根据不同框架获取对应的List数据
    List&lt;Map&lt;String, Object&gt;&gt; queryList = query.find();
    List&lt;Map&lt;String, Object&gt;&gt; parentList = Lists.newArrayList();
    for (Map&lt;String, Object&gt; map : queryList) {
        if (map.get(&quot;pId&quot;).equals(&quot;0&quot;)) {
            parentList.add(map);
        }
    }    
    recursionChildren(parentList, queryList);
    return parentList;
}

// 递归获取子节点数据
public static void recursionChildren (List&lt;Map&lt;String, Object&gt;&gt; parentList, 
List&lt;Map&lt;String, Object&gt;&gt; allList) {
    for (Map&lt;String, Object&gt; parentMap : parentList) {
        List&lt;Map&lt;String, Object&gt;&gt; childrenList = Lists.newArrayList();
        for (Map&lt;String, Object&gt; allMap : allList) {
            if (allMap.get(&quot;pId&quot;).equals(parentMap.get(&quot;id&quot;))) {
                childrenList.add(allMap);
            }
        }
        if (!ParamValidUtils.isEmpty(childrenList)) {
            parentMap.put(&quot;children&quot;, childrenList);
            recursionChildren(childrenList, allList);
        }
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/26/SpringBoot系列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/26/SpringBoot系列/" itemprop="url">SpringBoot系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-26T21:34:15+08:00">
                2020-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h2><ol>
<li>Spring boot是Spring家族中的一个全新的框架，它用来简化Spring应用程序的创建和开发过程，也可以说Spring boot能简化我们之前采用SpringMVC+Spring+Mybatis框架进行开发的过程。</li>
<li>在以往我们采用SpringMVC+Spring+Mybatis框架进行开发的时候，搭建和整合三大框架，我们需要做很好工作，比如配置web.xml，配置Spring，配置Mybatis,并将它们整合在一起等，而Spring boot框架对此开发过程进行了革命性的颠覆，抛弃了繁琐的xml配置过程，采用大量的默认配置简化我们的开发过程。</li>
<li>所以采用Spring boot可以非常容易和快速的创建基于Spring框架的应用程序，它让编码变简单了，配置变简单了，部署变简单了，监控也变简单了。</li>
<li>正因为Spring boot它化繁为简，让开发变得极其简单和快捷，所以在业界备受关注。Spring boot在国内的关注趋势也日渐超过Spring。</li>
</ol>
<ol>
<li>能够快速创建基于Spring的应用程序。（简化配置）</li>
<li>能够直接使用java的main方法启动内嵌的Tomcat，Jetty服务器运行Spring boot程序，不需要部署war包文件。</li>
<li>提供约定的starter POM来简化来简化Maven配置，让Maven配置变得简单。</li>
<li>根据项目的maven依赖配置，Spring boot自动配置Spring,SpringMVC等其它开源框架。<br>.提供程序的健康检查等功能。（检查内部的运行状态等）<br>基本可以完全不使用xml配置文件，采用注解配置。（或者默认约定的配置，代码中已经实现）</li>
</ol>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务：架构风格</p>
<p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p>
<p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="环境约束"><a href="#环境约束" class="headerlink" title="环境约束"></a>环境约束</h3><p>-jdk1.8</p>
<p>-maven 3.x</p>
<p>-springboot1.5.9RELEASE</p>
<h3 id="MAVEN设置"><a href="#MAVEN设置" class="headerlink" title="MAVEN设置"></a>MAVEN设置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring-Boot-HelloWorld"><a href="#Spring-Boot-HelloWorld" class="headerlink" title="Spring Boot HelloWorld"></a>Spring Boot HelloWorld</h3><p>浏览器发送hello请求，服务器接受请求并处理，响应HelloWorld字符串；</p>
<h4 id="创建一个maven工程（jar）"><a href="#创建一个maven工程（jar）" class="headerlink" title="创建一个maven工程（jar）"></a>创建一个maven工程（jar）</h4><h4 id="导入springBoot-依赖"><a href="#导入springBoot-依赖" class="headerlink" title="导入springBoot 依赖"></a>导入springBoot 依赖</h4><pre><code>&lt;parent&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
    &lt;exclusion&gt;
    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
    &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h4 id="编写主程序，启动Spring-Boot应用"><a href="#编写主程序，启动Spring-Boot应用" class="headerlink" title="编写主程序，启动Spring Boot应用"></a>编写主程序，启动Spring Boot应用</h4><pre><code>/**
 * @Date2020/5/23 12:53
 * SpringBootApplication来标注一个主程序
 **/
@SpringBootApplication
public class HelloWorldMainApplication {
    public static void main(String[] args) {
        //spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    }
}
</code></pre><h4 id="编写相关的Controller、Service"><a href="#编写相关的Controller、Service" class="headerlink" title="编写相关的Controller、Service"></a>编写相关的Controller、Service</h4><h4 id="运行主程序测试"><a href="#运行主程序测试" class="headerlink" title="运行主程序测试"></a>运行主程序测试</h4><h4 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h4><pre><code>&lt;!--可以将应用打包成一个可执行的jar宝--&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><h5 id="将这个应用打成jar包，直接用java-jar的命令进行执行；"><a href="#将这个应用打成jar包，直接用java-jar的命令进行执行；" class="headerlink" title="将这个应用打成jar包，直接用java -jar的命令进行执行；"></a>将这个应用打成jar包，直接用java -jar的命令进行执行；</h5><h5 id="终止运行"><a href="#终止运行" class="headerlink" title="终止运行"></a>终止运行</h5><pre><code>netstat -aon|findstr &quot;8080&quot;
taskkill /f /pid 8976  终止jar命令运行的程序
</code></pre><h3 id="Hello-World探究"><a href="#Hello-World探究" class="headerlink" title="Hello World探究"></a>Hello World探究</h3><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><h5 id="父文件"><a href="#父文件" class="headerlink" title="父文件"></a>父文件</h5><pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre><p>Spring Boot的版本仲裁中心</p>
<p>以后我们导入依赖默认是不需要写版本号的（没有在dependencies里面管理的依赖自然需要声明版本号）</p>
<h5 id="导入的依赖"><a href="#导入的依赖" class="headerlink" title="导入的依赖"></a>导入的依赖</h5><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>spring-boot-starter-web：</p>
<h6 id="spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件"><a href="#spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件" class="headerlink" title="spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件"></a>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件</h6><p>Spring Boot将所有功能场景都抽取出来，做成一个个starters(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h5 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h5><pre><code>/**
 * @Date2020/5/23 12:53
 * SpringBootApplication来标注一个主程序,说明这是一个Spring Boot应用
 **/
@SpringBootApplication
public class HelloWorldMainApplication {

    private static Logger log= LoggerFactory.getLogger(HelloWorldMainApplication.class);

    public static void main(String[] args) {
        log.info(&quot;HelloWorldMainApplication is success!&quot;);
        //spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    }
}
</code></pre><p>@SpringBootApplication Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用。</p>
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
    ), @Filter(
        type = FilterType.CUSTOM,
        classes = {AutoConfigurationExcludeFilter.class}
    )}
)
</code></pre><p>@SpringBootConfiguration：SpringBoot的配置类；</p>
<p>​    标注在某个类上，标识这是一个SpringBoot的配置类；</p>
<p>​    @Configuration:配置类上来标注这个注解：</p>
<p>​        配置类—配置文件；配置类也是容器中的一个组件；@Componet</p>
<p>@EnableAutoConfiguration：开启自动配置功能</p>
<p>​    以前需要配置的东西，SpringBoot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效。</p>
<pre><code>@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
</code></pre><p>@AutoConfigurationPackage：自动配置包</p>
<p>@Import({Registrar.class})</p>
<p>​Spring的底层注解@Import，给容器中导入一个组件；导入的组件由Registrar.class</p>
<p>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到</p>
<p>Spring容器；</p>
<p>​@Import({EnableAutoConfigurationImportSelector.class})</p>
<p>​给容器中导入组件</p>
<p>​EnableAutoConfigurationImportSelector：导入那些组件的选择器；</p>
<p>​将所有需要导入的组件以全类名的方式返回；</p>
<p>​会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所</p>
<p>有组件，并配置好这些组件；免去了我们手动编写配置注入功能组件的工作。</p>
<pre><code>SpringFactoriesLoader.loadFactoryNames(
  getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
</code></pre><p><img src="/2020/05/26/SpringBoot系列/批注 2020-05-23 145433.jpg" alt=""></p>
<p>Spring Boot在启动的时候从类路径下的”META-INF/spring.factories”中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。</p>
<p>J2EE的整体整合解决方案和自动配置都在m2\repository\org\springframework\boot\spring-boot-autoconfigure\1.5.9.RELEASE\spring-boot-autoconfigure-1.5.9.RELEASE.jar</p>
<h3 id="使用Spring-Initializer快速创建Spring-Boot项目"><a href="#使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="使用Spring Initializer快速创建Spring Boot项目"></a>使用Spring Initializer快速创建Spring Boot项目</h3><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块，向导会联网进行项目的创建；</p>
<p>默认生成的Spring Boot项目</p>
<ol>
<li><p>主程序已经生成好了，只需要实现我们自己的逻辑</p>
</li>
<li><p>resources文件夹的目录结构</p>
<p>static:保存所有的js  css images</p>
<p>templates:保存所有的页面模板；（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）;</p>
<p>application.properties:Spring Boot 的配置文件，可以修改一些默认设置；</p>
</li>
</ol>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="SpringBoot使用一个全局的配置文件，配置文件名是固定的；"><a href="#SpringBoot使用一个全局的配置文件，配置文件名是固定的；" class="headerlink" title="SpringBoot使用一个全局的配置文件，配置文件名是固定的；"></a>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</h3><p>application.properties</p>
<p>application.yml</p>
<p>配置文件的作用：修改SpringBoot自动配置的默认值</p>
<p>SpringBoot在底层都给我们自动配置好；</p>
<p>YAML是一个标记语言：以前的配置大都使用xxx.xml文件，而yaml以数据为中心，比json,xml更适合作配置文件</p>
<h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><h4 id="k-v-标识一对键值对（空格必须有）"><a href="#k-v-标识一对键值对（空格必须有）" class="headerlink" title="k: v :标识一对键值对（空格必须有）"></a>k: v :标识一对键值对（空格必须有）</h4><p>以空格的缩进来控制层级关系，只要左对齐的一列数据，都是一个层级的，属性和值也是大小写敏感；</p>
<h4 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h4><p>字面量：普通的值（数字、字符串、布尔）</p>
<p>​    字面量直接来写，字符串默认不用加上单引号或者双引号</p>
<p>​    “”:双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思</p>
<p>​        name: “zhangsan \n lisi” 输出zhangsan 换行 lisi</p>
<p>​    ‘’:单引号，会转义特殊字符，输出zhangsan \n lisi</p>
<p>对象、map（属性和值）（键值对）</p>
<p>​k:v :对象还是k:v的形式</p>
<pre><code>friends:
lastName: zhangsan
    age: 18
</code></pre><p>行内写法</p>
<pre><code>friends{lastName:zhangsan,age:18}
</code></pre><p>数组（list、set）</p>
<pre><code>pets:
  - cat
  - dog
 - pig
</code></pre><p>行内写法</p>
<pre><code>pets:{cat,dog,pig}
</code></pre><h3 id="配置文件的注入和校验"><a href="#配置文件的注入和校验" class="headerlink" title="配置文件的注入和校验"></a>配置文件的注入和校验</h3><h4 id="properities配置文件在idea中默认utf-8可能会乱码"><a href="#properities配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="properities配置文件在idea中默认utf-8可能会乱码"></a>properities配置文件在idea中默认utf-8可能会乱码</h4><pre><code>person:
  name: zhangsan
  age: 18
  boss: false
  birth: 2020/12/12
  map: {k1: v1,k2: 12}
  objectList:
    - lisi
    - wangwu
  dog:
    name: mumu
    age: 2
</code></pre><p>javaBean</p>
<pre><code>/**
 * @ClassNamePerson
 * @Description 将配置文件中的每一个属性的值映射到这个组件中
 * @Author
 * @Date2020/5/23 16:08
 * @ConfigurationProperties告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
 * prefix = &quot;person&quot;:配置文件中哪个下面的所有属性进行一一映射
 * 只有这个组件是容器中的组件，才能用容器提供的@ConfigurationProperties功能,需要加上@Component
 * @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值
 **/
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private boolean boss;
    private Date birth;
    private Map&lt;String,Object&gt; map;
    private List&lt;Object&gt; objectList;
    private Dog dog;
</code></pre><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>
<pre><code>&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
     &lt;optional&gt;true&lt;/optional&gt;
 &lt;/dependency&gt;
</code></pre><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入文件的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定</td>
<td>支持（lastName,last-name）</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>配置文件yml还是properties都可获取到值</p>
<p>如果只需要获取简单属性值可用@Value</p>
<h4 id="PropertySource-amp-ImportResource"><a href="#PropertySource-amp-ImportResource" class="headerlink" title="@PropertySource&amp;ImportResource"></a>@PropertySource&amp;ImportResource</h4><p>@PropertySource:加载指定的配置文件，需要指定配置文件的路径</p>
<pre><code>/**
 * @Description 将配置文件中的每一个属性的值映射到这个组件中
 * @ConfigurationProperties告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
 * prefix = &quot;person&quot;:配置文件中哪个下面的所有属性进行一一映射
 * 只有这个组件是容器中的组件，才能用容器提供的@ConfigurationProperties功能,需要加上@Component
 **/
@PropertySource(value = {&quot;classpath:person.properties&quot;})
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private boolean boss;
    private Date birth;
    private Map&lt;String,Object&gt; map;
    private List&lt;Object&gt; objectList;
    private Dog dog;
</code></pre><p>@ImportResource:导入Spring的配置文件，让配置文件里面的内容生效；</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别，想让Spring的配置文件生效，加载进来；@ImportResource需要标注在一个配置类上</p>
<pre><code>@ImportResource(locations = {&quot;classpath:beans.xml&quot;})
</code></pre><p>导入Spring的配置文件，让其生效</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;helloService&quot; class=&quot;com.think.hello.service.HelloService&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>SpringBoot推荐给容器中添加组件的方式，推荐使用全注解的方式；</p>
<p>1、配置类===Spring配置文件</p>
<p>2、@Bean给容器中添加组件</p>
<pre><code>@Configuration
public class myAppConfig {
    //将方法的返回值添加到容器，容器中这个组件默认的id就是方法名
    @Bean
    public HelloService helloService(){
        return new HelloService();
    }
}
</code></pre><h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><p>占位符后期之前配置的值，如果没有可用：指定默认值</p>
<pre><code>person:
  name: zhangsan${random.uuid}
  boss: false
  age: ${random.int}
  birth: 2020/12/12
  map: {k1: v1,k2: 12}
  objectList:
    - lisi
    - wangwu
    - zhangsan
  dog:
    name: ${person.hello:hello}mumu
    age: 2
</code></pre><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><h4 id="多profile文件"><a href="#多profile文件" class="headerlink" title="多profile文件"></a>多profile文件</h4><p>我们在主配置文件编写的时候，文件名可用applicaton-{profile}.properties/yml</p>
<p>默认使用application.properties的配置</p>
<h4 id="yml支持多文档块的方式"><a href="#yml支持多文档块的方式" class="headerlink" title="yml支持多文档块的方式"></a>yml支持多文档块的方式</h4><pre><code>server:
  port: 8080
spring:
  profiles:
    active: prod
---
server:
  port: 8081
spring:
  profiles: dev
---
server:
  port: 8082
spring:
  profiles: prod
</code></pre><h4 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h4><h5 id="在配置文件中指定spring-profiles-active-dev"><a href="#在配置文件中指定spring-profiles-active-dev" class="headerlink" title="在配置文件中指定spring.profiles.active=dev"></a>在配置文件中指定spring.profiles.active=dev</h5><h5 id="命令行的方式"><a href="#命令行的方式" class="headerlink" title="命令行的方式"></a>命令行的方式</h5><p>​    在启动配置里 –spring.profiles.active=dev或java -jar xxx.jar –spring.profiles.active=dev</p>
<h5 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h5><p>​    -Dspring.profiles.active=dev</p>
<h3 id="配置文件的加载默认的优先级由高到低"><a href="#配置文件的加载默认的优先级由高到低" class="headerlink" title="配置文件的加载默认的优先级由高到低"></a>配置文件的加载默认的优先级由高到低</h3><p>高优先级的配置会覆盖低优先级的配置生效；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</p>
<p>-file:./conifg/</p>
<p>-file:./</p>
<p>-classpath:/config/</p>
<p>-classpath:/</p>
<p>我们还可用通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包后可用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定配置文件会和默认加载的这些配置文件共同起作用形成配置</p>
<p> -jar xxx.jar –server.port=8080</p>
<h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>配置文件能配置的属性参照</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties</a></p>
<pre><code>@SpringBootApplication
@SpringBootApplication是一个复合注解或派生注解，在@SpringBootApplication中有一个注解@EnableAutoConfiguration，该注解是开启自动配置
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
</code></pre><p>@EnableAutoConfiguration也是一个派生注解，其中的关键功能是由@Import提供，其导入的AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()扫描所有具有META-INF/spring.factories的jar包。 spring-boot-autoconfigure-x.x.x.x.jar里就有一个spring.factories文件。spring.factories文件由一组一组的key=value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表， 这些类名以逗号分隔。<br>spring-boot-autoconfigure-x.x.x.x.jar -&gt; META-INF/spring.factories -&gt; org.springframework.boot.autoconfigure.xxx.xxxAutoConfiguration 类列表将会被实例化到Spring容器。<br>SpringBoot项目启动时，@SpringBootApplication用在启动类SpringApplication.run()的内部就会置顶selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class,然后将所有自动配置类加载到Spring容器中。</p>
<h3 id="以redis自动配置，解析Spring自动配置原理"><a href="#以redis自动配置，解析Spring自动配置原理" class="headerlink" title="以redis自动配置，解析Spring自动配置原理"></a>以redis自动配置，解析Spring自动配置原理</h3><h4 id="将redis-starter依赖加入"><a href="#将redis-starter依赖加入" class="headerlink" title="将redis starter依赖加入"></a>将redis starter依赖加入</h4><pre><code>&lt;!--redis jar--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration会被实例化到容器。该类为什么会被实例化？ 因为它在META-INF/spring.factories的Auto Configure列表。<br>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration被实例化，然而redis也会被实例化即创建RedisTemplate在Spring容器。</p>
<p>然而实例化redis对象是有条件的即@ConditionalOnClass({RedisOperations.class})，意思：当给定的类名在类路径上存在，则实例化当前Bean。</p>
<p>也就是想Spring创建redis实例对象，必须需要将redis starter包：spring-boot-starter-data-redis依赖引入。有了redis starter依赖springboot自动配置就会检测到classpath路径下有相关的类，然后就可以实例化对应的类了，这就是自动配置的原理。</p>
<p><em>知识点：类上有该注解@Configuration，类被实例化 时@bean会自动执行，生成对应的bean实例，放入Spring容器。</em></p>
<pre><code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration会导入JedisConnectionConfiguration.class
@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})

JedisConnectionConfiguration.class有注解：@ConditionalOnClass({GenericObjectPool.class, JedisConnection.class, Jedis.class}) 
</code></pre><h4 id="spring是怎样读取redis配置参数？"><a href="#spring是怎样读取redis配置参数？" class="headerlink" title="spring是怎样读取redis配置参数？"></a>spring是怎样读取redis配置参数？</h4><p>关键是org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration的注解：@EnableConfigurationProperties({RedisProperties.class})</p>
<p><em>知识点：@EnableConfigurationProperties会将配置文件的key-value映射成Java对象。<br>redis配置类，如果没redis配置，使用本地的redis这需要本地安装redis服务，如果有redis配置就设置redis host、port等属性</em></p>
<p>appliccation.yml redis配置。必须以spring.redis开头</p>
<h2 id="spring-boot-starter"><a href="#spring-boot-starter" class="headerlink" title="spring-boot-starter"></a>spring-boot-starter</h2><p>SpringBoot 可以省略众多的繁琐配置，它的众多starter可以说功不可没。 例如集成redis,只需要pom.xml中引入spring-boot-starter-data-redis,配置文件application.yml中加入spring.redis.database等几个关键配置项即可，常用的starter还有spring-boot-starter-web、spring-boot-starter-test等，相比传统的xml配置大大减少了集成的工作量。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用starter实现自动化配置只需要两个条件–maven依赖、配置文件。引入maven实质就是导入jar包，spring-boot启动的时候会找到starter jar包中的resources/META-INF/spring.factories文件，根据spring.factories文件中的配置，找到需要自动配置的类。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Configuration</td>
<td>表明是一个配置文件，被注解的类将成为一个bean配置类</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>当classpath下发现该类的情况下进行自动配置</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>当classpath下发现该类的情况下进行自动配置</td>
</tr>
<tr>
<td>@EnableConfigurationProperties</td>
<td>使@ConfigurationProperties注解生效</td>
</tr>
<tr>
<td>@AutoConfigureAfter</td>
<td>完成自动配置后实例化这个bean</td>
</tr>
</tbody>
</table>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>pom.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.air&lt;/groupId&gt;
    &lt;artifactId&gt;starter-demo&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;starter-demo&lt;/name&gt;
    &lt;description&gt;spring-boot-starter demo&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;!-- Source --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre><p>spring-boot-configuration-processor 的作用是编译时生成 spring-configuration-metadata.json ，在IDE中编辑配置文件时，会出现提示。 打包选择jar-no-fork，因为这里不需要main函数。</p>
<h3 id="EnableDemoConfiguration"><a href="#EnableDemoConfiguration" class="headerlink" title="EnableDemoConfiguration"></a>EnableDemoConfiguration</h3><pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface EnableDemoConfiguration {
}
</code></pre><h3 id="DemoProperties"><a href="#DemoProperties" class="headerlink" title="DemoProperties"></a>DemoProperties</h3><pre><code>@Data
@ConfigurationProperties(prefix = &quot;demo&quot;)
public class DemoProperties {
    private String name;
    private Integer age;
}
</code></pre><p>name和age对应application.properties里面的demo.name和demo.age</p>
<h3 id="DemoAutoConfiguration"><a href="#DemoAutoConfiguration" class="headerlink" title="DemoAutoConfiguration"></a>DemoAutoConfiguration</h3><pre><code>@Configuration
@ConditionalOnBean(annotation = EnableDemoConfiguration.class)
@EnableConfigurationProperties(DemoProperties.class)
public class DemoAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    DemoService demoService (){
        return new DemoService();
    }

}
</code></pre><p>这里设置自动配置的相关条件，和相关操作，由于这里只想写一个最简单的demo，所以这里只需要简单注入一个bean，没有复杂逻辑，实际开发中，这个类是最关键的。</p>
<h3 id="DemoService"><a href="#DemoService" class="headerlink" title="DemoService"></a>DemoService</h3><pre><code>public class DemoService {

    @Autowired
    private DemoProperties demoProperties;

    public void print() {
        System.out.println(demoProperties.getName());
        System.out.println(demoProperties.getAge());
    }
}
</code></pre><p>这里不需要@Service，因为已经通过DemoAutoConfiguration注入spring容器了。</p>
<h3 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h3><p>在resources/META-INF/下创建spring.factories文件:<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.air.starterdemo.config.DemoAutoConfiguration<br>告诉spring-boot，启动时需要扫描的类。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>pom.xml 本地mvn install之后，在新的spring-boot项目里面引入<br>    <dependency><br>        <groupid>com.air</groupid><br>        <artifactid>starter-demo</artifactid><br>        <version>0.0.1-SNAPSHOT</version><br>    </dependency></p>
<h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>demo.name = ooo
demo.age = 11
</code></pre><p>如果使用的是IDEA，在编辑时会出现提示。</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><pre><code>@SpringBootApplication
@EnableDemoConfiguration
public class Demo1Application {

    @Autowired
    private DemoService demoService;

    public static void main(String[] args) {
        SpringApplication.run(Demo1Application.class, args);
    }

    @PostConstruct
    public void test() {
        demoService.print();
    }
}
</code></pre><p>启动main函数，控制台会打印出配置文件中的name和age，一个简单的spring-boot-starter就写好了</p>
<h3 id="spring-factories-1"><a href="#spring-factories-1" class="headerlink" title="spring.factories"></a>spring.factories</h3><pre><code># Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Auto Configuration Import Listeners
org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition

# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration

# Failure analyzers
org.springframework.boot.diagnostics.FailureAnalyzer=\
org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\
org.springframework.boot.autoconfigure.flyway.FlywayMigrationScriptMissingFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer

# Template availability providers
org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider
</code></pre><p>每一个autoconfigure类都是容器中的一个组件，都加入到容器中，用他们来做自动配置</p>
<p>每一个自动配置类进行自动配置功能;</p>
<p>以HttpEncodingAutoConfiguration为例解释自动配置原理</p>
<pre><code>@Configuration(//表示这是一个自动配置类
proxyBeanMethods = false
)
@EnableConfigurationProperties({ServerProperties.class})//启用configurationProperties功能，将配置文件中对应的值和xxxProperties绑定起来
@ConditionalOnWebApplication(//Spring底层@Conditional注解，根据不同条件，如果满足指定条件，整个配置里里面的配置就会生效，判断当前应用是否是web应用，是就生效不是就不生效
    type = Type.SERVLET
)
@ConditionalOnClass({CharacterEncodingFilter.class})//判断当前项目有没有这个类
CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器
@ConditionalOnProperty(//判断配置文件中是否存在某个配置server.servlet.encoding.enabled如果不存在判断也是成立的，即使我们的配置文件中不配置server.servlet.encoding.enabled=true,也是默认生效的  
    prefix = &quot;server.servlet.encoding&quot;,//从配置文件中获取指定的值和bean的属性进行绑定
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)
public class HttpEncodingAutoConfiguration {
</code></pre><p>根据当前不同的条件判断，决定这个配置类是否生效</p>
<p><em>如果生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个又是和配置文件绑定的</em></p>
<pre><code>@Bean//给容器中添加一个组件,这个组件的某些值需要从properties中获取
@ConditionalOnMissingBean
public CharacterEncodingFilter characterEncodingFilter() {
    CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
    filter.setEncoding(this.properties.getCharset().name());
    filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));
    filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));
    return filter;
}
</code></pre><p>所有在配置文件中能配置的属性都是xxxProperties类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<p>总结 1、SpringBoot启动会加载大量的自动配置类；</p>
<p>​    2、我们看需要的功能有没有SpringBoot默认写好的自动配置类</p>
<p>​    3、我们再来看这个自动配置类中配置了哪些组件，只要我们要用的组件有，就不需要再来配置了，</p>
<p>​    4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，我们就可以再配置文件总指定这些属性的值。</p>
<p>xxxAutoConfiguration:自动配置类</p>
<p>给容器中添加组件</p>
<p>xxxProperties：封装配置文件中相关属性</p>
<p>自动配置类哪个生效了</p>
<p>我们可以通过debug=true来让控制台打印自动配置报告，这样就可以很方便知道哪些自动配置生效了</p>
<pre><code>============================
CONDITIONS EVALUATION REPORT
============================


Positive matches:（自动配置类启用的）
-----------------

AopAutoConfiguration matched:
- @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition)

AopAutoConfiguration.ClassProxyingConfiguration matched:
- @ConditionalOnMissingClass did not find unwanted class &apos;org.aspectj.weaver.Advice&apos; (OnClassCondition)
- @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)

DispatcherServletAutoConfiguration matched:
- @ConditionalOnClass found required class &apos;org.springframework.web.servlet.DispatcherServlet&apos; (OnClassCondition)
- found &apos;session&apos; scope (OnWebApplicationCondition)

DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched:
- @ConditionalOnClass found required class &apos;javax.servlet.ServletRegistration&apos; (OnClassCondition)
- Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)


Negative matches:（没有启用的，没匹配成功的）
-----------------

ActiveMQAutoConfiguration:
Did not match:
- @ConditionalOnClass did not find required class &apos;javax.jms.ConnectionFactory&apos; (OnClassCondition)

AopAutoConfiguration.AspectJAutoProxyingConfiguration:
Did not match:
- @ConditionalOnClass did not find required class &apos;org.aspectj.weaver.Advice&apos; (OnClassCondition)

ArtemisAutoConfiguration:
Did not match:
- @ConditionalOnClass did not find required class &apos;javax.jms.ConnectionFactory&apos; (OnClassCondition)
</code></pre><h2 id="SpringBoot与日志"><a href="#SpringBoot与日志" class="headerlink" title="SpringBoot与日志"></a>SpringBoot与日志</h2><h3 id="日志门面SLF4J日志实现Logback"><a href="#日志门面SLF4J日志实现Logback" class="headerlink" title="日志门面SLF4J日志实现Logback;"></a>日志门面SLF4J日志实现Logback;</h3><p>SpringBoot:底层是Spring框架，Spring框架默认用JCL;</p>
<p>SpringBoot选用SLF4J(日志的抽象层)和logback;</p>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象曾里面的方法。</p>
<p>应该给系统导入slf4j的jar和logback的实现jar</p>
<pre><code>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}
</code></pre><p><img src="/2020/05/26/SpringBoot系列/批注 2020-05-24 123704.png" alt=""></p>
<p>每一个日志的实现框架都有自己的配置文件。使用slf4j后，<em>配置文件还是做成日志实现框架自己本身的配置文件</em>；</p>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>不同系统有不同的日志框架，需要做到统一日志记录，即使别的框架和我一起使用slf4j进行输出</p>
<p><img src="/2020/05/26/SpringBoot系列/legacy.png" alt=""></p>
<p>如何让系统中所有日志都统一到slf4j</p>
<p>将系统中其他日志框架排除，用中间包替换原有的日志框架，再导入slf4d其他的实现</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>SpringBoot 使用它来做日志</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p><img src="/2020/05/26/SpringBoot系列/批注 2020-05-24 125540.png" alt=""></p>
<p>总结：1、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p>
<p>​    2、SpringBoot也把其他的日志都替换成了slf4j</p>
<p>​    3、中间替换包</p>
<p>​    4、如果要引入其他框架，一定要把这个框架的默认日志移除掉</p>
<p>​    Spring框架用的commons-logging;</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
    &lt;artifactId&gt;activemq-console&lt;/artifactId&gt;
    &lt;version&gt;${activemq.version}&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre><p><em>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉。</em></p>
<pre><code>private static Logger logger = LoggerFactory.getLogger(HelloApplication.class);
public static void main(String[] args) {
    SpringApplication.run(HelloApplication.class, args);
    //日志级别由低到高
    //可以调整输出的日志级别
    logger.trace(&quot;trace&quot;);
    logger.debug(&quot;debug&quot;);
    logger.info(&quot;HelloApplication is Success&quot;);
    logger.warn(&quot;warn&quot;);
    logger.error(&quot;error&quot;);
}

logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n

%d表示日期时间
%thread表示线程名
%-5level:级别从左显示5个字符的宽度
%logger{50}表示logger名字最长50个字符，否则按照句点分割
%msg:日志消息
%n换行符
</code></pre><p>SpringBoot修改默认日志配置</p>
<pre><code>logging.level.com.think=trace
#当前项目下生成springboot.log日志，可以指定完整的路径D:/springboot.log
#logging.file.name=springboot.log
#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用spring.log做为默认文件
logging.file.path=/spring/log
#在控制台输出的日志的格式
logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
#指定文件中日志的输出格式
logging.pattern.file=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n

&lt;!-- 日志记录器，日期滚动记录 --&gt;
&lt;appender name=&quot;FILE_ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;

&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;
&lt;file&gt;${LOG_PATH}/log_error.log&lt;/file&gt;

&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;
&lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;

&lt;!-- 归档的日志文件的路径，%d{yyyy-MM-dd}指定日期格式，%i指定索引 --&gt;
&lt;fileNamePattern&gt;${LOG_PATH}/error/log-error-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;

&lt;!-- 除按日志记录之外，还配置了日志文件不能超过2M，若超过2M，日志文件会以索引0开始，
命名日志文件，例如log-error-2013-12-21.0.log --&gt;
&lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
&lt;/rollingPolicy&gt;

&lt;!-- 追加方式记录日志 --&gt;
&lt;append&gt;true&lt;/append&gt;

&lt;!-- 日志文件的格式 --&gt;
&lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
&lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;
&lt;charset&gt;utf-8&lt;/charset&gt;
&lt;/encoder&gt;

&lt;!-- 此日志文件只记录error级别的 --&gt;
&lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
&lt;level&gt;error&lt;/level&gt;
&lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
&lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
&lt;/filter&gt;
&lt;/appender&gt;
</code></pre><p>可以按照slfj的日志适配图，进行相关的切换</p>
<p>idea依赖分析-pom.xml-右键-Diagrams-Show Dependencies</p>
<h2 id="SpringBoot与Web开发"><a href="#SpringBoot与Web开发" class="headerlink" title="SpringBoot与Web开发"></a>SpringBoot与Web开发</h2><h3 id="使用SpringBoot"><a href="#使用SpringBoot" class="headerlink" title="使用SpringBoot"></a>使用SpringBoot</h3><h4 id="创建SpringBoot应用，选中我们需要的模块；"><a href="#创建SpringBoot应用，选中我们需要的模块；" class="headerlink" title="创建SpringBoot应用，选中我们需要的模块；"></a>创建SpringBoot应用，选中我们需要的模块；</h4><h4 id="SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来；"><a href="#SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来；" class="headerlink" title="SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来；"></a>SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来；</h4><h4 id="自己编写业务逻辑代码；"><a href="#自己编写业务逻辑代码；" class="headerlink" title="自己编写业务逻辑代码；"></a>自己编写业务逻辑代码；</h4><h4 id="自动配置原理-1"><a href="#自动配置原理-1" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>这个场景SpringBoot帮我们配置了什么，能不能修改，能修改哪些配置，能不能扩展</p>
<p>xxxAutoConfiguration:帮我们给容器中自动配置组件</p>
<p>xxxProperties：配置类来封装配置文件中的内容</p>
<h4 id="SpringBoot对静态资源的映射规则"><a href="#SpringBoot对静态资源的映射规则" class="headerlink" title="SpringBoot对静态资源的映射规则"></a>SpringBoot对静态资源的映射规则</h4><p>ResourceProperties可以设置静态资源有关的参数，缓存时间等</p>
<pre><code>@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)
public class ResourceProperties {

    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { &quot;classpath:/META-INF/resources/&quot;,
            &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; };

    /**
     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
     * /resources/, /static/, /public/].

@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    }
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
        .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) {
    customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
    .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
    .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
}
</code></pre><p>所有/webjars/**都去classpath:/META-INF/resources/webjars/找资源</p>
<p>webjars:以jar包的方式引入静态资源；</p>
<p><a href="https://www.webjars.org/" target="_blank" rel="noopener">https://www.webjars.org/</a></p>
<p><img src="/2020/05/26/SpringBoot系列/批注 2020-05-24 160548.png" alt=""></p>
<p><a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.5.1/jquery.js</a></p>
<pre><code>&lt;!--引入jquery-webjar--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>/**访问当前项目的任何资源（静态资源文件夹）</p>
<pre><code>&quot;/&quot;：当前项目的根路径
&quot;classpath:/META-INF/resources/&quot;,
&quot;classpath:/resources/&quot;, 
&quot;classpath:/static/&quot;, 
&quot;classpath:/public/
</code></pre><h4 id="以什么样的路径访问静态资源"><a href="#以什么样的路径访问静态资源" class="headerlink" title="以什么样的路径访问静态资源"></a>以什么样的路径访问静态资源</h4><p>spring.mvc.static-path-pattern=/static/**<br>Spring Boot 2.3要在配置文件配置静态资源访问路径</p>
<p>欢迎页，静态资源文件夹下所有的index.html页面；被”/**“映射</p>
<p>所有的**/favicon.ico都是在静态资源文件下找</p>
<h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>Thymeleaf</p>
<p>语法更简单，功能更强大</p>
<h4 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h4><pre><code>&lt;!--模板引擎--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;

@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)
public class ThymeleafProperties {

    private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
    //只要我们把html页面放在classpath:/templates/，thymeleaf就能自动渲染
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;

    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;

    /**
     * Whether to check that the template exists before rendering it.
     */
    private boolean checkTemplate = true;

导入thymeleaf的名称空间
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
</code></pre><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>参考thymeleaf手册</p>
<h3 id="SpringMVC自动配置"><a href="#SpringMVC自动配置" class="headerlink" title="SpringMVC自动配置"></a>SpringMVC自动配置</h3><h4 id="Spring-Boot自动配置好了SpringMVC"><a href="#Spring-Boot自动配置好了SpringMVC" class="headerlink" title="Spring Boot自动配置好了SpringMVC"></a>Spring Boot自动配置好了SpringMVC</h4><p>以下是SpringBoot对SpringMVC的默认</p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View）视图对象决定如何渲染，是转发还是重定向）</li>
<li>ContentNegotiatingViewResolver符合所有的视图解析器的</li>
<li>如何定制：我们可以给容器中添加一个视图解析器@Bean；自动将其组合进来</li>
<li>如何验证是否添加进来了-搜索DispatcherServlet-doDispatch-在这打断点，用debug方式运行</li>
<li>随便请求一个页面可以看到DispatcherServlet的viewResolvers里面已经包含了我们自定义的视图解析器</li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">later in this document</a>)).静态资源文件夹路径，webjars</p>
</li>
<li><p>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</p>
<ul>
<li>Converter:转换器 类型转换使用</li>
<li>Formatter:格式化器日期的转换</li>
</ul>
</li>
<li><p>Support for <code>HttpMessageConverters</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters" target="_blank" rel="noopener">later in this document</a>).</p>
<ul>
<li>HttpMessageConverters:SpringMVC用来转换Http请求和响应的；User–Json</li>
</ul>
</li>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes" target="_blank" rel="noopener">later in this document</a>).</p>
<ul>
<li>定义错误代码生成规则的</li>
</ul>
</li>
<li><p>Static <code>index.html</code> support.(静态首页访问)</p>
</li>
<li><p>Custom <code>Favicon</code> support (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon" target="_blank" rel="noopener">later in this document</a>).（favicon.ico）</p>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer" target="_blank" rel="noopener">later in this document</a>).</p>
<ul>
<li><p>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的</p>
<p> 初始化WebDataBinder;<br>请求数据===JavaBean</p>
</li>
</ul>
</li>
</ul>
<p>If you want to keep those Spring Boot MVC customizations and make more <a href="https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p>
<h4 id="使用WebMvcConfigurerAdapter扩展SpringMVC的功能"><a href="#使用WebMvcConfigurerAdapter扩展SpringMVC的功能" class="headerlink" title="使用WebMvcConfigurerAdapter扩展SpringMVC的功能"></a>使用WebMvcConfigurerAdapter扩展SpringMVC的功能</h4><p>编写一个配置类（@Configuration）,是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc。</p>
<p>既保留了所有的自动配置，也能用我们扩展的配置</p>
<pre><code>//作用：请求me的时候会到success页面
@Configuration
public class MyConfig extends WebMvcConfigurerAdapter{

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/me&quot;).setViewName(&quot;success&quot;);
    }
}
</code></pre><p>原理：</p>
<ol>
<li><p>WebMvcAutoConfiguration 是SpringMVC的自动配置类</p>
</li>
<li><p>在做其他自动配置时会导入@Import(EnableWebMvcConfiguration.class)</p>
<pre><code>@Configuration(proxyBeanMethods = false)
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {

private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

//从容器中获取所有WebMvcConfigurer的配置
@Autowired(required = false)
public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
    if (!CollectionUtils.isEmpty(configurers)) {
    this.configurers.addWebMvcConfigurers(configurers);
        //一个参考实现，将所有的WebMvcConfigurer相关配置都来一起调用
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            for (WebMvcConfigurer delegate : this.delegates) {
                delegate.addViewControllers(registry);
            }
        }
    }
}
</code></pre></li>
<li><p>容器中所有的WebMvcConfigurer都会一起起作用，包括自己写的配置类</p>
</li>
</ol>
<h4 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h4><p>SpringBoot对SpringMVC的自动配置不需要，所有都是我们自己配，只需要在配置类中添加@EnableWebMvc</p>
<pre><code>原理：

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {//这个注解上导入了DelegatingWebMvcConfiguration
}

@Configuration(proxyBeanMethods = false)
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {//DelegatingWebMvcConfiguration.class又继承了WebMvcConfigurationSupport

@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
//容器种没有（WebMvcConfigurationSupport）这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
        ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {

@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；
导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；
</code></pre><h4 id="如何修改SpringBoot的默认配置"><a href="#如何修改SpringBoot的默认配置" class="headerlink" title="如何修改SpringBoot的默认配置"></a>如何修改SpringBoot的默认配置</h4><ol>
<li>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean,@Component）如果有就用用户配置的，如果没有才自动配置；如果有些组件可以有多个，他是将用户配置的和自己默认的组合起来</li>
<li>在SpringBoot种会有非常多的xxxConfigurer帮助我们进行扩展配置</li>
</ol>
<h4 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h4><pre><code> //所有的WebMvcConfigurerAdapter组件都会一起起作用
@Bean//将组件注册到容器中
public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;);
        }
    };
    return adapter;
}
</code></pre><h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h4><ol>
<li>编写国际化文件，抽取页面需要显示的国际化消息</li>
</ol>
<p><img src="/2020/05/26/SpringBoot系列/批注 2020-05-30 103915.png" alt=""></p>
<ol start="2">
<li><p>SpringBoot自动配置好了管理国际化资源文件的组件</p>
<p> @Configuration(proxyBeanMethods = false)<br>@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)<br>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)<br>@Conditional(ResourceBundleCondition.class)<br>@EnableConfigurationProperties<br>public class MessageSourceAutoConfiguration {</p>
<p> private static final Resource[] NO_RESOURCES = {};</p>
<p> @Bean<br> @ConfigurationProperties(prefix = “spring.messages”)<br> public MessageSourceProperties messageSourceProperties() {</p>
<pre><code>return new MessageSourceProperties();
</code></pre><p> }</p>
<p> @Bean<br> public MessageSource messageSource(MessageSourceProperties properties) {</p>
<pre><code>ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
if (StringUtils.hasText(properties.getBasename())) {
    //设置国际化资源文件的基础名
    messageSource.setBasenames(StringUtils
            .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));
}
if (properties.getEncoding() != null) {
    messageSource.setDefaultEncoding(properties.getEncoding().name());
}
messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
Duration cacheDuration = properties.getCacheDuration();
if (cacheDuration != null) {
    messageSource.setCacheMillis(cacheDuration.toMillis());
}
messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
return messageSource;
</code></pre><p> }</p>
</li>
<li><p>去页面获取国际化的值</p>
</li>
</ol>
<p>idea  file-setting-FileEncodings-fileEncodeing将properties编码改成UTF-8，让他自动转成ascii码（只对当前项目生效）<br>要改默认的在file-Other Setting-DefaultSetting来修改全局默认设置</p>
<p><img src="/2020/05/26/SpringBoot系列/批注 2020-05-30 114127.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/23/mongo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/23/mongo/" itemprop="url">mongo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-23T08:51:04+08:00">
                2020-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/mongo/" itemprop="url" rel="index">
                    <span itemprop="name">mongo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB ?"></a>什么是MongoDB ?</h1><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<br>在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。<br>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
<h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><ul>
<li><p>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</p>
</li>
<li><p>你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。</p>
</li>
<li><p>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</p>
</li>
<li><p>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</p>
</li>
<li><p>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</p>
</li>
<li><p>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</p>
</li>
<li><p>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。</p>
</li>
<li><p>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</p>
</li>
<li><p>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</p>
</li>
<li><p>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</p>
</li>
<li><p>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</p>
</li>
<li><p>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</p>
</li>
<li><p>MongoDB安装简单。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1></li>
</ul>
<ol>
<li><p>下载mongodb-linux-x86_64-3.6.3.tar.gz</p>
</li>
<li><p>解压tar -zxvf mongodb-linux-x86_64-3.0.6.tgz</p>
</li>
<li><p>在与bin同级的目录下建立data文件夹</p>
</li>
<li><p>mongo.config文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port=27017</span><br><span class="line">logpath=/airthink/mongodb-linux-x86_64-3.6.3/mongod.log</span><br><span class="line">pidfilepath=/airthink/mongodb-linux-x86_64-3.6.3/mongod.pid</span><br><span class="line">logappend=true</span><br><span class="line">fork=true</span><br><span class="line">maxConns=3000</span><br><span class="line">dbpath=/airthink/mongodb-linux-x86_64-3.6.3/data</span><br><span class="line">auth=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动./mongodb-linux-x86_64-3.6.3/bin/mongo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var schema = db.system.version.findOne(&#123;_id:&quot;authSchema&quot;&#125;);//驱动版本5--SCRAM-SHA-1需要修改成：3--Mongodb-CR</span><br><span class="line">schema. currentVersion = 3;</span><br><span class="line">db.system.version.save(schema);</span><br><span class="line"></span><br><span class="line">db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;mypass&quot;,roles:[&quot;readWriteAnyDatabase&quot;, &quot;userAdminAnyDatabase&quot;, &quot;dbAdminAnyDatabase&quot;]&#125;);</span><br><span class="line"></span><br><span class="line">windows下的启动命令到bin目录下  start mongod</span><br></pre></td></tr></table></figure>
<h1 id="MongoDB用户角色配置"><a href="#MongoDB用户角色配置" class="headerlink" title="MongoDB用户角色配置"></a>MongoDB用户角色配置</h1></li>
</ol>
<h2 id="基本知识介绍"><a href="#基本知识介绍" class="headerlink" title="基本知识介绍"></a>基本知识介绍</h2><p>MongoDB基本的角色</p>
<ol>
<li>数据库用户角色：read、readWrite;</li>
<li>数据库管理角色：dbAdmin、dbOwner、userAdmin；</li>
<li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</li>
<li>备份恢复角色：backup、restore；</li>
<li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li>
<li>超级用户角色：root (这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase,其中MongoDB默认是没有开启用户认证的，也就是说游客也拥有超级管理员的权限。userAdminAnyDatabase：有分配角色和用户的权限，但没有查写的权限)</li>
</ol>
<h2 id="连接到MongoDB服务器"><a href="#连接到MongoDB服务器" class="headerlink" title="连接到MongoDB服务器"></a>连接到MongoDB服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">建库操作开始</span><br><span class="line"></span><br><span class="line">./mongodb-linux-x86_64-3.6.3/bin/mongo   进入mongo shell</span><br><span class="line"></span><br><span class="line">use admin(使用)</span><br><span class="line"></span><br><span class="line">db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;password&quot;,roles:[&quot;root&quot;]&#125;)//创建root用户</span><br><span class="line"></span><br><span class="line">db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;admin&quot;,roles:[&#123;role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;)（创建admin用户）</span><br><span class="line"></span><br><span class="line">db.auth(&apos;admin&apos;, &apos;admin&apos;);（授权）</span><br><span class="line"></span><br><span class="line">修改mongod.conf文件</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">authorization: enabled//启用授权</span><br><span class="line"></span><br><span class="line">重启MongoDB服务器</span><br><span class="line"></span><br><span class="line">service mongod restart</span><br><span class="line"></span><br><span class="line">创建数据库读写权限用户</span><br><span class="line"></span><br><span class="line">use admin</span><br><span class="line">db.auth(&quot;admin&quot;,&quot;password&quot;);</span><br><span class="line">use ballmatch</span><br><span class="line">db.createUser(&#123;</span><br><span class="line">    user: &quot;baidu&quot;,</span><br><span class="line">    pwd: &quot;password&quot;,</span><br><span class="line">    roles: [&#123;role: &quot;readWrite&quot;,db: &quot;baidu&quot;&#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Java程序连接MongoDB"><a href="#Java程序连接MongoDB" class="headerlink" title="Java程序连接MongoDB"></a>Java程序连接MongoDB</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MongoCredential credential = MongoCredential.createCredential(&quot;username&quot;, &quot;dbName&quot;, &quot;password&quot;.toCharArray());</span><br><span class="line">ServerAddress serverAddress = new ServerAddress(&quot;192.168.10.242&quot;, 27017);</span><br><span class="line">MongoClient mongoClient = new MongoClient(serverAddress, Arrays.asList(credential));</span><br><span class="line">DB db = mongoClient.getDB(&quot;dbName&quot;);</span><br><span class="line">returndb;</span><br><span class="line"></span><br><span class="line">//方式二</span><br><span class="line">String sURI = String.format(&quot;mongodb://%s:%s@%s:%d/%s&quot;, &quot;username&quot;, &quot;password&quot;, &quot;192.168.10.242&quot;, 27017, &quot;dbName&quot;); </span><br><span class="line">MongoClientURI uri = new MongoClientURI(sURI); </span><br><span class="line">MongoClient mongoClient = new MongoClient(uri); </span><br><span class="line">DB db = mongoClient.getDB(&quot;dbName&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">修改用户密码</span><br><span class="line">db.updateUser( &quot;admin&quot;,&#123;pwd:&quot;password&quot;&#125;);</span><br><span class="line"></span><br><span class="line">密码认证</span><br><span class="line">db.auth(&quot;admin&quot;,&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">MongoDB连接信息查询</span><br><span class="line">db.serverStatus().connections;</span><br><span class="line"></span><br><span class="line">关闭MongoDB服务</span><br><span class="line">use admin;</span><br><span class="line">db.shutdownServer();</span><br><span class="line"></span><br><span class="line">删除用户</span><br><span class="line">删除用户(需要root权限，会将所有数据库中的football用户删除)</span><br><span class="line">db.system.users.remove(&#123;user:&quot;baidu&quot;&#125;);</span><br><span class="line"></span><br><span class="line">删除用户(权限要求没有那么高，只删除本数据中的football用户)</span><br><span class="line">db.dropUser(&quot;baidu&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="mongoTemplate使用示例"><a href="#mongoTemplate使用示例" class="headerlink" title="mongoTemplate使用示例"></a>mongoTemplate使用示例</h1><h2 id="对匹配到的数据进行更新-inc"><a href="#对匹配到的数据进行更新-inc" class="headerlink" title="对匹配到的数据进行更新(inc)"></a>对匹配到的数据进行更新(inc)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Query query = new Query();</span><br><span class="line">query.addCriteria(Criteria.where(&quot;accountName&quot;).is(username));</span><br><span class="line">if (null != password)&#123;</span><br><span class="line">        query.addCriteria(Criteria.where(&quot;accountPwd&quot;).is(password));</span><br><span class="line">&#125;</span><br><span class="line">Account account = this.mongoTemplate.findOne(query, Account.class);</span><br><span class="line">if (account != null) &#123;</span><br><span class="line">    Update update = new Update();</span><br><span class="line">    update.inc(&quot;loginTimes&quot;, 1);</span><br><span class="line">    this.mongoTemplate.updateFirst(query, update, Account.class);//查找并更新</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mongoTemplate.updateFirst(Query.query(Criteria.where(&quot;_id&quot;).is(favor.getTypeId())),new Update().inc(&quot;favorTimes&quot;, 1), News.class);</span><br><span class="line"></span><br><span class="line">mongoTemplate.updateFirst(Query.query(Criteria.where(&quot;_id&quot;).is(favor.getTypeId())),new Update().inc(&quot;favorTimes&quot;, -1), News.class);</span><br></pre></td></tr></table></figure>
<h2 id="查询一条记录和保存（findOne-save）"><a href="#查询一条记录和保存（findOne-save）" class="headerlink" title="查询一条记录和保存（findOne/save）"></a>查询一条记录和保存（findOne/save）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account account = mongoTemplate.findOne(Query.query(Criteria.where(&quot;accountName&quot;).is(accountName)),Account.class);</span><br><span class="line"></span><br><span class="line">account.setAccountPwd(passwd);</span><br><span class="line"></span><br><span class="line">mongoTemplate.save(account);</span><br></pre></td></tr></table></figure>
<h2 id="多条件匹配（并的关系）"><a href="#多条件匹配（并的关系）" class="headerlink" title="多条件匹配（并的关系）"></a>多条件匹配（并的关系）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.andOperator(Criteria.where(&quot;phone&quot;).is(phone), Criteria.where(&quot;status&quot;).is(0));</span><br><span class="line">List&lt;VerifyCode&gt; codes = mongoTemplate.find(Query.query(criteria), VerifyCode.class);</span><br><span class="line"></span><br><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.andOperator(Criteria.where(&quot;entityID&quot;).is(entityID), Criteria.where(&quot;accountType&quot;).is(accountType), Criteria.where(&quot;weUnionId&quot;).ne(&quot;&quot;).ne(null));</span><br><span class="line">Account Account = mongoTemplate.findOne(Query.query(criteria), Account.class);</span><br><span class="line"></span><br><span class="line">Boolean isFavor = mongoTemplate.exists(Query.query(Criteria.where(&quot;typeId&quot;).is(favor.getTypeId()).and(&quot;type&quot;).is(favor.getType()).and(&quot;userId&quot;).is(favor.getUserId())), Favor.class);</span><br></pre></td></tr></table></figure>
<h2 id="多条件匹配（或的关系）"><a href="#多条件匹配（或的关系）" class="headerlink" title="多条件匹配（或的关系）"></a>多条件匹配（或的关系）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.orOperator(Criteria.where(&quot;status&quot;).is(1), Criteria.where(&quot;status&quot;).is(0));</span><br><span class="line">List&lt;VerifyCode&gt; codes = mongoTemplate.find(Query.query(criteria), VerifyCode.class);</span><br></pre></td></tr></table></figure>
<h2 id="根据id查找并删除"><a href="#根据id查找并删除" class="headerlink" title="根据id查找并删除"></a>根据id查找并删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account account = mongoTemplate.findById(id, Account.class); </span><br><span class="line">mongoTemplate.remove(account);</span><br></pre></td></tr></table></figure>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count = mongoTemplate.count(Query.query(Criteria.where(&quot;accountName&quot;).is(accountName)), Account.class);</span><br></pre></td></tr></table></figure>
<h2 id="模糊匹配并排序"><a href="#模糊匹配并排序" class="headerlink" title="模糊匹配并排序"></a>模糊匹配并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.andOperator(Criteria.where(&quot;province&quot;).regex(province));//正则</span><br><span class="line">mongoTemplate.find(Query.query(criteria).with(new Sort(Direction.ASC, &quot;order&quot;)), Bbatch.class);</span><br></pre></td></tr></table></figure>
<h2 id="distinct查询"><a href="#distinct查询" class="headerlink" title="distinct查询"></a>distinct查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> DBObject dbObject = new BasicDBObject(&quot;schoolId&quot;, bschool.get_id());</span><br><span class="line">List&lt;String&gt; provinces = mongoTemplate.getCollection(</span><br><span class="line">mongoTemplate.getCollectionName(BschoolScoreline.class)) .distinct(&quot;province&quot;, dbObject);</span><br><span class="line">bschool.setProvinces(provinces);</span><br></pre></td></tr></table></figure>
<h2 id="查找并所有排序"><a href="#查找并所有排序" class="headerlink" title="查找并所有排序"></a>查找并所有排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoTemplate.find(new Query().with(new Sort(Direction.ASC, &quot;order&quot;,&quot;createTime&quot;)), Bschool.class);</span><br></pre></td></tr></table></figure>
<h2 id="in查询"><a href="#in查询" class="headerlink" title="in查询"></a>in查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MpropValue&gt; mpropValueList = mongoTemplate.find(Query.query(Criteria.where(&quot;propId&quot;).in(mprop1.get_id())), MpropValue.class);</span><br></pre></td></tr></table></figure>
<h2 id="设置唯一字段"><a href="#设置唯一字段" class="headerlink" title="设置唯一字段"></a>设置唯一字段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//used 是1 将其他所有是1的更新为0</span><br><span class="line">    if(address.getUsed()==1)&#123;</span><br><span class="line">    Query q = new Query(Criteria.where(&quot;userId&quot;).is(user.get_id()));//查询</span><br><span class="line">    Update u = new Update().set(&quot;used&quot;,0);</span><br><span class="line">    BulkOperations ops = mongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED, &quot;address&quot;);</span><br><span class="line">    ops.updateMulti(q,u);//全部更新</span><br><span class="line">    ops.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReturnStatus upsert(List&lt;BspecialLink&gt; specialLinks) &#123;</span><br><span class="line">    ReturnStatus status;</span><br><span class="line">    mongoTemplate.insertAll(specialLinks);</span><br><span class="line">    status = new ReturnStatus(true);</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取数据库所有集合名称"><a href="#获取数据库所有集合名称" class="headerlink" title="获取数据库所有集合名称"></a>获取数据库所有集合名称</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; sets = mongoTemplage.getDb().getCollectionNames();</span><br></pre></td></tr></table></figure>
<h2 id="查询当天数据"><a href="#查询当天数据" class="headerlink" title="查询当天数据"></a>查询当天数据</h2><pre><code>private static Date getStartTime() {
    Calendar todayStart = Calendar.getInstance();
    todayStart.set(Calendar.HOUR_OF_DAY, 0);
    todayStart.set(Calendar.MINUTE, 0);
    todayStart.set(Calendar.SECOND, 0);
    todayStart.set(Calendar.MILLISECOND, 0);
    return todayStart.getTime();
}

private static Date getEndTime() {
    Calendar todayEnd = Calendar.getInstance();
    todayEnd.set(Calendar.HOUR_OF_DAY, 23);
    todayEnd.set(Calendar.MINUTE, 59);
    todayEnd.set(Calendar.SECOND, 59);
    todayEnd.set(Calendar.MILLISECOND, 999);
    return todayEnd.getTime();
}

Criteria criteria = new Criteria();
criteria.andOperator(
        Criteria.where(&quot;type&quot;).is(type),
        Criteria.where(&quot;typeId&quot;).is(typeId),
        Criteria.where(&quot;userId&quot;).is(user.get_id()),
        Criteria.where(&quot;createTime&quot;).gte(getStartTime())
                .lte(getEndTime()));
return mongoTemplate.exists(Query.query(criteria), Zan.class);
</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p>删除字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.yourcollection.update(&#123;&#125;,&#123;$unset:&#123;&quot;需要删除的字段&quot;:&quot;&quot;&#125;&#125;,false,true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将匹配到的值全部更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(&quot;bschool&quot;).update(&#123;&quot;state&quot;:0&#125;,&#123;$set:&#123;&quot;state&quot;:&quot;1&quot;&#125;&#125;,&#123;&apos;multi&apos;:true&#125;)</span><br></pre></td></tr></table></figure>
<p>db.getCollection(“pdfChapterItem”).update({}, {$rename : {“remark” : “abbr”}}, false, true)//更新所有字段名</p>
</li>
<li><p>建立索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.bschoolScorelineDetail.ensureIndex(&#123;&quot;schoolId&quot;:1,&quot;type&quot;:1,&quot;batch&quot;:1,&quot;province&quot;:1&#125;,&#123;&quot;name&quot;：&quot;schoolScorelineDetail&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>mongo中建立索引用ensureIndex({“字段1”:1,”字段2”:”-1”},{“name”:”索引名”}) 1和-1代表正序和倒序</p>
</li>
<li><p>mongo数据库备份操作(在mongo的安装目录的bin下执行如下命令)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">不带验证的数据库备份：</span><br><span class="line"></span><br><span class="line">mongodump -d mrmf -o /tools/test   mrmf数据库名   /tools/test要备份到的地方</span><br><span class="line"></span><br><span class="line">不带验证的数据库恢复</span><br><span class="line"></span><br><span class="line">mongorestore --db mrmf /tools/test/mrmf   mrmf数据库名   /tools/test要恢复的数据</span><br><span class="line"></span><br><span class="line">带验证的数据库备份：</span><br><span class="line"></span><br><span class="line">mongodump -d mrmf -u admin -p &quot;ie8*kskIkd123&quot; --authenticationDatabase=admin -o /tools/test  </span><br><span class="line"></span><br><span class="line">带验证的数据库恢复：</span><br><span class="line"></span><br><span class="line">mongorestore --db mrmf -u admin -p &quot;ie8*kskIkd123&quot; --authenticationDatabase=admin /tools/test/red</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启慢日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在客户端调用db.setProfilingLevel(级别) 命令来实时配置。可以通过db.getProfilingLevel()命令来获取当前的Profile级别。</span><br><span class="line"></span><br><span class="line">&gt; db.setProfilingLevel(2); </span><br><span class="line">&gt; &#123;&quot;was&quot; : 0 , &quot;ok&quot; : 1&#125; </span><br><span class="line">&gt; db.getProfilingLevel()</span><br><span class="line">上面斜体的级别可以取0，1，2 三个值，他们表示的意义如下：</span><br><span class="line">0 – 不开启</span><br><span class="line">1 – 记录慢命令 (默认为&gt;100ms)</span><br><span class="line">2 – 记录所有命令</span><br><span class="line">Profile 记录在级别1时会记录慢命令，那么这个慢的定义是什么?上面我们说到其默认为100ms，当然有默认就有设置，其设置方法和级别一样有两种，一种是通过添加–slowms启动参数配置。第二种是调用db.setProfilingLevel时加上第二个参数：</span><br><span class="line">db.setProfilingLevel( level , slowms ) </span><br><span class="line">db.setProfilingLevel( 1 , 10 );</span><br><span class="line">Mongo Profile 记录是直接存在系统db里的，记录位置 system.profile ，所以，我们只要查询这个Collection的记录就可以获取到我们的 Profile 记录了。</span><br><span class="line"></span><br><span class="line">Profile 信息内容详解：</span><br><span class="line"></span><br><span class="line">ts-该命令在何时执行.</span><br><span class="line"></span><br><span class="line">millis Time-该命令执行耗时，以毫秒记.</span><br><span class="line"></span><br><span class="line">info-本命令的详细信息.</span><br><span class="line"></span><br><span class="line">query-表明这是一个query查询操作.</span><br><span class="line"></span><br><span class="line">ntoreturn-本次查询客户端要求返回的记录数.比如, findOne()命令执行时 ntoreturn 为 1.有limit(n) 条件时ntoreturn为n.</span><br><span class="line"></span><br><span class="line">query-具体的查询条件(如x&gt;3).</span><br><span class="line"></span><br><span class="line">nscanned-本次查询扫描的记录数.</span><br><span class="line"></span><br><span class="line">reslen-返回结果集的大小.</span><br><span class="line"></span><br><span class="line">nreturned-本次查询实际返回的结果集.</span><br><span class="line"></span><br><span class="line">update-表明这是一个update更新操作.</span><br><span class="line"></span><br><span class="line">upsert-表明update的upsert参数为true.此参数的功能是如果update的记录不存在，则用update的条件insert一条记录.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>　　moved-表明本次update是否移动了硬盘上的数据，如果新记录比原记录短，通常不会移动当前记录，如果新记录比原记录长，那么可能会移动记录到其它位置，这时候会导致相关索引的更新.磁盘操作更多，加上索引更新，会使得这样的操作比较慢.</p>
<p>　　insert-这是一个insert插入操作.</p>
<p>　　getmore-这是一个getmore 操作，getmore通常发生在结果集比较大的查询时，第一个query返回了部分结果，后续的结果是通过getmore来获取的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#下面是一个超过200ms的查询语句</span><br><span class="line">&#123; </span><br><span class="line">&quot;op&quot; : &quot;query&quot;,                     #操作类型，有insert、query、update、remove、getmore、command  </span><br><span class="line">&quot;ns&quot; : &quot;F10data3.f10_2_8_3_jgcc&quot;, </span><br><span class="line">&quot;query&quot; : &#123;                         #具体的查询语句 包括过滤条件，limit行数  排序字段</span><br><span class="line">    filter&quot; : &#123;</span><br><span class="line">        &quot;jzrq&quot; : &#123;</span><br><span class="line">            &quot;$gte&quot; : ISODate(&quot;2017-03-31T16:00:00.000+0000&quot;), </span><br><span class="line">            &quot;$lte&quot; : ISODate(&quot;2017-06-30T15:59:59.000+0000&quot;)</span><br><span class="line">        &#125;, </span><br><span class="line">        &quot;jglxfldm&quot; : 10.0</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;ntoreturn&quot; : 200.0,    </span><br><span class="line">    &quot;sort&quot; : &#123;                      #如果有排序  则显示排序的字段 这里是 RsId</span><br><span class="line">        &quot;RsId&quot; : 1.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, </span><br><span class="line">&quot;keysExamined&quot; : 0.0,               #索引扫描数量 这里是全表扫描，没有用索引 所以是 0</span><br><span class="line">&quot;docsExamined&quot; : 69608.0,           #浏览的文档数 这里是全表扫描 所以是整个collection中的全部文档数</span><br><span class="line">&quot;numYield&quot; : 546.0,                 #该操作为了使其他操作完成而放弃的次数。通常来说，当他们需要访问</span><br><span class="line">                                    还没有完全读入内存中的数据时，操作将放弃。这使得在MongoDB为了</span><br><span class="line">                                    放弃操作进行数据读取的同时，还有数据在内存中的其他操作可以完成。</span><br><span class="line">&quot;locks&quot; : &#123;                         #锁信息，R：全局读锁；W：全局写锁；r：特定数据库的读锁；w：特定数据库的写锁</span><br><span class="line">    &quot;Global&quot; : &#123;</span><br><span class="line">        &quot;acquireCount&quot; : &#123;</span><br><span class="line">            &quot;r&quot; : NumberLong(1094)  #该操作获取一个全局级锁花费的时间。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;Database&quot; : &#123;</span><br><span class="line">        &quot;acquireCount&quot; : &#123;</span><br><span class="line">            &quot;r&quot; : NumberLong(547)  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;Collection&quot; : &#123;</span><br><span class="line">        &quot;acquireCount&quot; : &#123;</span><br><span class="line">            &quot;r&quot; : NumberLong(547)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, </span><br><span class="line">&quot;nreturned&quot; : 200.0,                #返回的文档数量</span><br><span class="line">&quot;responseLength&quot; : 57695.0,         #返回字节长度，如果这个数字很大，考虑值返回所需字段</span><br><span class="line">&quot;millis&quot; : 264.0,                   #消耗的时间（毫秒）</span><br><span class="line">&quot;planSummary&quot; : &quot;COLLSCAN, COLLSCAN&quot;, #执行概览 从这里看来 是全表扫描 </span><br><span class="line">&quot;execStats&quot; : &#123;                       #详细的执行计划 这里先略过 后续可以用 explain来具体分析</span><br><span class="line">&#125;, </span><br><span class="line">&quot;ts&quot; : ISODate(&quot;2017-08-24T02:32:49.768+0000&quot;),  #命令执行的时间</span><br><span class="line">&quot;client&quot; : &quot;10.3.131.96&quot;,                        #访问的ip或者主机</span><br><span class="line">&quot;allUsers&quot; : [</span><br><span class="line">], </span><br><span class="line">&quot;user&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MongoDB 查询优化</p>
<ol>
<li>　如果发现 millis 值比较大，那么就需要作优化。</li>
<li>　如果docsExamined数很大，或者接近记录总数（文档数），那么可能没有用到索引查询，而是全表扫描。</li>
<li>　如果keysExamined数为0，也可能是没用索引。</li>
<li>　结合 planSummary 中的显示，上例中是 “COLLSCAN, COLLSCAN” 确认是全表扫描</li>
<li>　如果 keysExamined 值高于 nreturned 的值，说明数据库为了找到目标文档扫描了很多文档。这时可以考虑创建索引来提高效率。</li>
<li>　索引的键值选择可以根据 query 中的输出参考，上例中 filter:包含了 jzrq和jglxfldm 并且按照RsId排序，所以 我们的索引索引可以这么建: db.f10_2_8_3_jgcc.ensureindex({jzrq:1,jglxfldm:1,RsId:1})</li>
</ol>
<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例一</span><br><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.andOperator(Criteria.where(&quot;userId&quot;).is(uid), Criteria.where(&quot;type&quot;).is(2));//查询条件</span><br><span class="line">Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(criteria),Aggregation.group(&quot;content&quot;).count().as(&quot;count&quot;),Aggregation.sort(Sort.Direction.ASC,&quot;count&quot;));</span><br><span class="line">AggregationResults&lt;SearchKeyWords&gt; ar = mongoTemplate.aggregate(aggregation,</span><br><span class="line">Searched.class, SearchKeyWords.class);//Searched为要查询的类，SearchKeyWords为查询结果的vo对象</span><br><span class="line">List&lt;SearchKeyWords&gt; list = ar.getMappedResults();</span><br><span class="line"></span><br><span class="line">public class SearchKeyWords &#123;</span><br><span class="line"></span><br><span class="line">    public String _id;//_id: &quot;中华&quot;  重复的字段</span><br><span class="line">    public int count;//count: 57   重复次数</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCount(int count) &#123;</span><br><span class="line">        this.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/23/mongo/aggregation.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">示例二</span><br><span class="line">//分组group、排序sort统计每个分类下商品个数</span><br><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(criteria),</span><br><span class="line">        Aggregation.group(&quot;categoryId&quot;).count().as(&quot;count&quot;),Aggregation.sort(Sort.Direction.ASC,&quot;count&quot;));</span><br><span class="line"></span><br><span class="line">AggregationResults&lt;BasicDBObject&gt; ar = mongoTemplate.aggregate(aggregation,</span><br><span class="line">        Goods.class, BasicDBObject.class);</span><br><span class="line">for (BasicDBObject basicDBObject : ar) &#123;</span><br><span class="line">    logger.info(JsonUtils.toJson(basicDBObject));</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] &#123;&quot;_id&quot;:&quot;6430379335205566832&quot;,&quot;count&quot;:1&#125;//分类id和当前分类下商品个数</span><br><span class="line">2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] &#123;&quot;_id&quot;:&quot;8732390723817262538&quot;,&quot;count&quot;:2&#125;</span><br><span class="line">2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] &#123;&quot;_id&quot;:&quot;4479460853249390323&quot;,&quot;count&quot;:2&#125;</span><br><span class="line">2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] &#123;&quot;_id&quot;:&quot;6571438787886532072&quot;,&quot;count&quot;:16&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例三</span><br><span class="line">//两个集合关联查询 Aggregation.lookup</span><br><span class="line">//若 A集合关联B集合</span><br><span class="line">//参数： from B集合名</span><br><span class="line">//localField A集合存外键的字段</span><br><span class="line">//foreignField B集合与A集合关联的字段</span><br><span class="line">//as 重新组合成C集合名称</span><br><span class="line">语法</span><br><span class="line">db.collection.aggregate([&#123;</span><br><span class="line">   $lookup:</span><br><span class="line">     &#123;</span><br><span class="line">       from: &lt;collection to join&gt;,</span><br><span class="line">       localField: &lt;field from the input documents&gt;,</span><br><span class="line">       foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;,</span><br><span class="line">       as: &lt;output array field&gt;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;])</span><br><span class="line"></span><br><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.andOperator(Criteria.where(&quot;_id&quot;).is(&quot;6118446118773213048&quot;));</span><br><span class="line">Aggregation aggregation = Aggregation.newAggregation(</span><br><span class="line">        Aggregation.match(criteria),</span><br><span class="line">        Aggregation.lookup(&quot;goodsCategory&quot;, &quot;categoryId&quot;, &quot;_id&quot;, &quot;goodsCategory&quot;),</span><br><span class="line">        Aggregation.unwind(&quot;goodsCategory&quot;),</span><br><span class="line">        Aggregation.project(&quot;title&quot;,&quot;price&quot;).and(&quot;goodsCategory.name&quot;).as(&quot;categoryName&quot;).and(&quot;goodsCategory.order&quot;).as(&quot;categoryOrder&quot;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">AggregationResults&lt;BasicDBObject&gt; ar = mongoTemplate.aggregate(</span><br><span class="line">        aggregation, Goods.class, BasicDBObject.class);</span><br><span class="line">for (BasicDBObject basicDBObject : ar) &#123;</span><br><span class="line">    logger.info(JsonUtils.toJson(basicDBObject));</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">2019-05-06 21:17:26 [com.badou.service.basic.goods.GoodsService]-[INFO] &#123;&quot;_id&quot;:&quot;6118446118773213048&quot;,&quot;title&quot;:&quot;小学生必备国学常识&amp;小学生必读国学经典&quot;,&quot;price&quot;:&quot;10.0&quot;,&quot;categoryName&quot;:&quot;小学生&quot;,&quot;categoryOrder&quot;:&quot;1&quot;&#125;</span><br><span class="line"></span><br><span class="line">示例四(未曾验证)</span><br><span class="line">//全文搜索查询</span><br><span class="line">//设置索引：db.logInfo.ensureIndex(msg:&quot;text&quot;)</span><br><span class="line">Query query = TextQuery.query(new TextCriteria().matching(&quot;coffee&quot;).matching(&quot;-cake&quot;));</span><br><span class="line">//-cake表示不匹配不包含cake与notMatching类似</span><br><span class="line">//Query query = TextQuery.searching((new TextCriteria().matching(&quot;coffee&quot;).notMatching(&quot;-cake&quot;))</span><br><span class="line">List&lt;LogInfoCol&gt; lfs = mongoTemplate.find(query,LogInfoCol.class);</span><br><span class="line">if(lfs!=null)&#123;</span><br><span class="line">    for(LogInfoCol logInfoCol:lfs)&#123;</span><br><span class="line">        logger.info(JSON.toString(logInfoCol));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例五(未曾验证)</span><br><span class="line">//得到范围内数据：以Circle构造函数，第一第二个参数为坐标，第三个参数为距离半径查找符合条件的</span><br><span class="line">Circle circle = new Circle(4.2341111,63.00001,0.01);</span><br><span class="line">List&lt;PositionCol&gt; positionCols = mongoTemplate.find(new Query(Criteria.where(&quot;location&quot;).within(circle)),PositionCol.class);</span><br><span class="line">if(positionCols!=null)&#123;</span><br><span class="line">    for(PositionCol positionCol:positionCols)&#123;</span><br><span class="line">        logger.info(JSON.toJSONString(positionCol))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例六(未曾验证)</span><br><span class="line">//查找坐标周围10KM内的所有商店</span><br><span class="line">Point location = new Point(116.425253,39.925338);</span><br><span class="line">NearQuery query = NearQuery.near(location).maxDistance(new Distance(10,Metrice.KILOMETERS));</span><br><span class="line">GeoResults&lt;PositionCol&gt; positions = mongoTemplate.geoNear(query,PositionCol.class);</span><br><span class="line">if(positionCols!=null)&#123;</span><br><span class="line">    for(GeoResults&lt;PositionCol&gt;geoResult :positions)&#123;</span><br><span class="line">        logger.info(geoResult.getContent().getBuissName()+&quot;-&quot;+geoResult.getDistance().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">示例七</span><br><span class="line">mongo支持的查询参数实例</span><br><span class="line">fpi.getParams().put(&quot;state|integer&quot;, &quot;1&quot;);           相当于is       一对一</span><br><span class="line">fpi.getParams().put(&quot;ne:state|integer&quot;, &quot;1&quot;);           相当于not is       一对一</span><br><span class="line">fpi.getParams().put(&quot;all:keywords&quot;, keyword);        keywords为list 多对一</span><br><span class="line">fpi.getParams().put(&quot;in:_id|array&quot;, &quot;0,1&quot;);          包含    一对多</span><br><span class="line">fpi.getParams().put(&quot;nin:_id|array&quot;, &quot;0,1&quot;);         排除id  一对多</span><br><span class="line">fpi.getParams().put(&quot;gte:serialNum&quot;, start);        </span><br><span class="line">fpi.getParams().put(&quot;lte:serialNum&quot;, end); </span><br><span class="line">//日期查询</span><br><span class="line">Date currentDate = DateUtil.currentDate();</span><br><span class="line">String d = DateUtil.format(currentDate,&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">fpi.getParams().put(&quot;gte:endDate|datetime&quot;, d);  大于当前日期的翻页查询</span><br><span class="line"></span><br><span class="line">聚合查询</span><br><span class="line">1、Criteria idcardCriteria = new Criteria();</span><br><span class="line">                idcardCriteria.orOperator(Criteria.where(&quot;idcard&quot;).regex(studentIdcard.toLowerCase()),</span><br><span class="line">                        Criteria.where(&quot;idcard&quot;).regex(studentIdcard.toUpperCase()));</span><br><span class="line">                criteria.andOperator(idcardCriteria);</span><br><span class="line"></span><br><span class="line">Mongodb: Sort operation used more than the maximum 33554432 bytes of RAM</span><br><span class="line">mongo中所有排序字段加上索引比较好</span><br><span class="line"></span><br><span class="line">Criteria criteria = new Criteria();</span><br><span class="line">criteria.andOperator(Criteria.where(&quot;shakyId&quot;).in(gshakyIds), Criteria.where(&quot;userId&quot;).in(userIds));//筛选条件（限定数据范围）</span><br><span class="line">Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(criteria),</span><br><span class="line">        Aggregation.group(&quot;userId&quot;, &quot;shakyId&quot;).count().as(&quot;count&quot;),Aggregation.sort(Sort.Direction.ASC, &quot;count&quot;));//分组  单个字段分组，直接取count;两个字段key 确定唯一一条记录,后续需要手动统计</span><br></pre></td></tr></table></figure>
<p>AggregationResults ar = mongoTemplate.aggregate(aggregation,<br>Ugclock.class, BasicDBObject.class);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for (BasicDBObject basicDBObject : ar) &#123;</span><br><span class="line">    String id = basicDBObject.getString(&quot;shakyId&quot;);</span><br><span class="line">    int count = 1;</span><br><span class="line">    if (shakyCount.containsKey(id)) &#123;</span><br><span class="line">        count = shakyCount.get(id);</span><br><span class="line">        count++;</span><br><span class="line">        shakyCount.put(id, count);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        shakyCount.put(id, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、以id为group by计算num的总值sum（）</span><br><span class="line">Aggregation agg = Aggregation.newAggregation(</span><br><span class="line">                Aggregation.group(new String[] &#123;&quot;_id&quot;&#125;).sum(&quot;num&quot;).as(&quot;num&quot;)</span><br><span class="line">                );</span><br><span class="line">3、以id为group by找出num的最大值max()                </span><br><span class="line">Aggregation agg = Aggregation.newAggregation(</span><br><span class="line">                Aggregation.group(new String[] &#123;&quot;_id&quot;&#125;).max(&quot;num&quot;).as(&quot;num&quot;)</span><br><span class="line">                );                </span><br><span class="line">Aggregation agg = Aggregation.newAggregation(</span><br><span class="line">                Aggregation.group(new String[] &#123;&quot;_id&quot;&#125;).min(&quot;num&quot;).as(&quot;num&quot;)</span><br><span class="line">                );</span><br><span class="line">4、以id为group by计算num的平均值avg(）</span><br><span class="line">Aggregation agg = Aggregation.newAggregation(</span><br><span class="line">                Aggregation.group(new String[] &#123;&quot;_id&quot;&#125;).avg(&quot;num&quot;).as(&quot;num&quot;)</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>
<h1 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h1><p>项目当中模拟插入了120W条数据，在同一个文档当中单纯查询数据的速度还不错，主要是对查询的文档字段添加了索引，但是对查询结果的前台分页确有问题。具体来说是不设置任何查询条件的时候，会查询出来将近120W条满足条件的结果，使用mongodb的limit()和skip() 来取出来 第一页前20条数据，这样在后台的java程序当中只是这20条数据占用内存。<br>代码具体形式类似于用mongodb客户端执行db.feedbackInfo.find(criteria).skip(0).limit(20) 获得第一页0-20条数据db.feedbackInfo.find(criteria).skip(20).limit(20) 获得第二页20-40条数据……db.feedbackInfo.find(criteria).skip(N).limit(20) 获得第二页N-N+20条数据但问题在于随着不断翻页，skip的值N会越来越大，前台的反应越来越慢。很直接的一个表现就是在前台从第一页直接跳转进入最后一页根本反应不过来。对于这个实际问题，原因就是本书这里所言的skip略过大量结果会带来性能问题，再根源地说是mongodb还不够完善，索引本身还比较简单。具体的这个分页效率的问题，有两种思路：第一，等mongodb升级，优化这个skip的执行效率。第二，不用skip()而实现分页效果。这个思路的基础就是mongodb本身对于where查询和limit()的效率还比较不错，也就是本来分页的那个查询用where和limit速度还可以的前提（一般就是需要建立必要的索引）。假如这个前提不成立，那没法讨论。本书接下来具体讨论了不使用skip对结果分页的实现例子，这个本质是对信息系统增加一个查询中间量——上次查询的业务数值，在逻辑上承担起跟skip相对等价的功能。比如说是第一页查询是按照一个日期date值查询，第一次用db.foo.find().sort({“date”,-1}).limit(20)而点击下一页的时候，事先将上次查询的date的边界值给传递过去，第二页查询的时候就使用新的find条件查询db.foo.find({“date”:{“$gt”:latest.date}}); 而后再对查询结果排序即可这种绕过skip的方式评价：第一，很难比较方便地解决所有的分页问题，简单来说 对于使用正则表达式的查询，根本无法通过记录边界条件来实现。第二，不得不多传递上次查询的那个边界条件，增加了工作量，不够优雅。第三，只能够解决一页一页往下翻页的问题，如果我要从第1页直接跳到100页，就束手无策</p>
<h2 id="翻页的实现一"><a href="#翻页的实现一" class="headerlink" title="翻页的实现一"></a>翻页的实现一</h2><h3 id="skip实现跳页（比较简单，数据量大了不行）"><a href="#skip实现跳页（比较简单，数据量大了不行）" class="headerlink" title="skip实现跳页（比较简单，数据量大了不行）"></a>skip实现跳页（比较简单，数据量大了不行）</h3><pre><code> /**
 *db.getCollection(&apos;user&apos;).find({})是指查询全部。
 *sort()设置排序，本示例是指以_id作为条件，正序排序。若将数字1改为-1，则为倒序。
 *skip()设置跳页，本示例是指跳过前10条，从第11条开始显示。
 *limit()设置每页的显示数量，本例是指每页限制显示10条。
 */
db.getCollection(&apos;user&apos;).find({}).sort({&quot;ID&quot;:1}).skip(10).limit(10)
</code></pre><h3 id="非skip实现跳页"><a href="#非skip实现跳页" class="headerlink" title="非skip实现跳页"></a>非skip实现跳页</h3><pre><code>原理：以自增_id作为主条件，获取前一页的最后一条记录，查询之后的指定条记录

//根据_id，查询前10条
var a = db. getCollection(&apos;user&apos;).find({}).sort(&quot;_id&quot;,1).limit(10)
//定义变量last
var last  = null
//循环遍历
while(a.hasNext()){
    last=a.next;//循环到最后，last接收的是最后一条的信息
}
//核心是&quot;_id&quot;:{&quot;$gt&quot;:last._id}，即查询大于最后一条的_id的后10条信息
db.getCollection(&apos;slt&apos;).find({&quot;_id&quot;:{&quot;$gt&quot;:last._id}}).sort({_id:1}).limit(10)
</code></pre><h2 id="翻页的实现二（非skip实现跳页，以自增-id作为主条件）"><a href="#翻页的实现二（非skip实现跳页，以自增-id作为主条件）" class="headerlink" title="翻页的实现二（非skip实现跳页，以自增_id作为主条件）"></a>翻页的实现二（非skip实现跳页，以自增_id作为主条件）</h2><pre><code>private List&lt;JSONObject&gt; findOrderList(Map&lt;String,Object&gt; paramOptions,int page,int size,String sidx,String sord) throws Exception {
            //连接数据库
    MongoCollection&lt;Document&gt; mongoCollection = getMdbCollection();
    //进行第一次查询，条件中没有skip
    MongoCursor&lt;Document&gt; iterable = mongoCollection.find().limit(size).sort(new BasicDBObject(&quot;_id&quot;, 1)).iterator(); 
    //定义orderItems，用以接收查询的信息
    List&lt;JSONObject&gt; orderItems = new ArrayList&lt;JSONObject&gt;();

    //如果只有一页或第一页，则走此条件，否，则走else
        if(page == 1){     
　　　　  //遍历        
            while (iterable.hasNext()) {
              Document next = iterable.next();
              JSONObject a =JSONObject.parseObject(next.toJson());
              orderItems.add(a);
            }
　　　　　}else{ 
　　　　　　MongoCursor&lt;Document&gt; iterable2 = mongoCollection.find().limit(size*(page-1)).sort(new BasicDBObject(&quot;_id&quot;, 1)).iterator(); 
         //定义变量last，用以存储每页的最后一条记录 
　　　　　Document last = null; 
　　　　　while (iterable2.hasNext()) { 
　　　　　　　　last = iterable2.next(); 
　　　　　} 
         //定义condition，用以添加【$gt:每页最后一条记录的_id值】，作为查询条件 
　　　　　　Map&lt;String, Object&gt; condition = new HashMap&lt;&gt;(); 
　　　　　　if (null != last.get(&quot;_id&quot;)) { 
　　　　　　　　condition.put(&quot;$gt&quot;,last.get(&quot;_id&quot;)); 
 　　　　　 } 
　　　　　 MongoCursor&lt;Document&gt; iterable3 = mongoCollection.find(condition).limit(size).sort(new BasicDBObject(&quot;_id&quot;, 1)).iterator(); 
　　　　　　//遍历 
　　　　　　while (iterable.hasNext()) { 
　　　　　　　　　　Document next = iterable.next(); 
　　　　　　　　　　JSONObject a =JSONObject.parseObject(next.toJson()); 
　　　　　　　　　　orderItems.add(a);
　　　　　　} 
　　　　　　return orderItems; 
}
 注：上面是按_id正序排列的，如果想要按照倒序排列，则需要将condition.put(&quot;$gt&quot;,last.get(&quot;_id&quot;))改为condition.put(&quot;$lt&quot;,last.get(&quot;_id&quot;))，将sort(new BasicDBObject(&quot;_id&quot;, 1)改为sort(new BasicDBObject(&quot;_id&quot;, -1)。
</code></pre><h1 id="mongo高级"><a href="#mongo高级" class="headerlink" title="mongo高级"></a>mongo高级</h1><h2 id="本地搭建副本集"><a href="#本地搭建副本集" class="headerlink" title="本地搭建副本集"></a>本地搭建副本集</h2><h3 id="mongo的版本"><a href="#mongo的版本" class="headerlink" title="mongo的版本"></a>mongo的版本</h3><p> version 3.6.5</p>
<h3 id="副本集文件夹准备"><a href="#副本集文件夹准备" class="headerlink" title="副本集文件夹准备"></a>副本集文件夹准备</h3><pre><code>mongodb3.6 同目录下建立文件夹，存放数据
data/mongo/27017,data/mongo/27018,data/mongo/27019
同目录下建立文件夹存放日志数据
data/mongo/27017log,data/mongo/27018log,data/mongo/27019log
</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>mongod --port 27017 --dbpath /data/mongo/27017 --logpath /data/mongo/27017log/27017.log --replSet rs-local-test --logappend
mongod --port 27018 --dbpath /data/mongo/27018 --logpath /data/mongo/27018log/27018.log --replSet rs-local-test --logappend
mongod --port 27019 --dbpath /data/mongo/27019 --logpath /data/mongo/27019log/27019.log --replSet rs-local-test --logappend
</code></pre><p>三个服务器启动完毕之后，不要关闭。另开一个cmd窗口，连接到27017端口的服务器（连接其他端口也可以），每次启动，主服务器可能会不一样，如果连接的是主服务器，前缀会变成如下PRIMARY，如果是从服务器，前缀会变成SECONDARY</p>
<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>创建一个配置文件，在配置文件中列出每一个成员，知道彼此的存在(第二次启动就不需要再配置)</p>
<pre><code>use test
witched to db test
     rs.initiate({
      &quot;_id&quot;:&quot;rs-local-test01&quot;,
      &quot;members&quot;:[
     {&quot;_id&quot;:0,&quot;host&quot;:&quot;127.0.0.1:27017&quot;},
      {&quot;_id&quot;:1,&quot;host&quot;:&quot;127.0.0.1:27018&quot;},
      {&quot;_id&quot;:2,&quot;host&quot;:&quot;127.0.0.1:27019&quot;}
    ]
})

{
&quot;ok&quot; : 1,
&quot;operationTime&quot; : Timestamp(1596076771, 1),
&quot;$clusterTime&quot; : {
    &quot;clusterTime&quot; : Timestamp(1596076771, 1),
        &quot;signature&quot; : {
            &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;
            &quot;keyId&quot; : NumberLong(0)
        }
    }
}
</code></pre><p>查看状态信息</p>
<pre><code>rs-local-test:OTHER&gt; rs.status()
{
&quot;set&quot; : &quot;rs-local-test&quot;,
&quot;date&quot; : ISODate(&quot;2020-07-30T02:40:29.243Z&quot;),
&quot;myState&quot; : 1,
&quot;term&quot; : NumberLong(1),
&quot;heartbeatIntervalMillis&quot; : NumberLong(2000),
&quot;optimes&quot; : {
&quot;lastCommittedOpTime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;readConcernMajorityOpTime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;appliedOpTime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;durableOpTime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
}
},
&quot;members&quot; : [
{
&quot;_id&quot; : 0,
&quot;name&quot; : &quot;127.0.0.1:27017&quot;,
&quot;health&quot; : 1,
&quot;state&quot; : 1,
&quot;stateStr&quot; : &quot;PRIMARY&quot;,
&quot;uptime&quot; : 286,
&quot;optime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;optimeDate&quot; : ISODate(&quot;2020-07-30T02:40:23Z&quot;),
&quot;infoMessage&quot; : &quot;could not find member to sync fr
&quot;electionTime&quot; : Timestamp(1596076782, 1),
&quot;electionDate&quot; : ISODate(&quot;2020-07-30T02:39:42Z&quot;),
&quot;configVersion&quot; : 1,
&quot;self&quot; : true
},
{
&quot;_id&quot; : 1,
&quot;name&quot; : &quot;127.0.0.1:27018&quot;,
&quot;health&quot; : 1,
&quot;state&quot; : 2,
&quot;stateStr&quot; : &quot;SECONDARY&quot;,
&quot;uptime&quot; : 57,
&quot;optime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;optimeDurable&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;optimeDate&quot; : ISODate(&quot;2020-07-30T02:40:23Z&quot;),
&quot;optimeDurableDate&quot; : ISODate(&quot;2020-07-30T02:40:2
&quot;lastHeartbeat&quot; : ISODate(&quot;2020-07-30T02:40:28.47
&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2020-07-30T02:40:2
),
&quot;pingMs&quot; : NumberLong(0),
&quot;syncingTo&quot; : &quot;127.0.0.1:27017&quot;,
&quot;configVersion&quot; : 1
},
{
&quot;_id&quot; : 2,
&quot;name&quot; : &quot;127.0.0.1:27019&quot;,
&quot;health&quot; : 1,
&quot;state&quot; : 2,
&quot;stateStr&quot; : &quot;SECONDARY&quot;,
&quot;uptime&quot; : 57,
&quot;optime&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;optimeDurable&quot; : {
&quot;ts&quot; : Timestamp(1596076823, 1),
&quot;t&quot; : NumberLong(1)
},
&quot;optimeDate&quot; : ISODate(&quot;2020-07-30T02:40:23Z&quot;),
&quot;optimeDurableDate&quot; : ISODate(&quot;2020-07-30T02:40:2
&quot;lastHeartbeat&quot; : ISODate(&quot;2020-07-30T02:40:28.47
&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2020-07-30T02:40:2
),
&quot;pingMs&quot; : NumberLong(0),
&quot;syncingTo&quot; : &quot;127.0.0.1:27018&quot;,
&quot;configVersion&quot; : 1
}
],
&quot;ok&quot; : 1,
&quot;operationTime&quot; : Timestamp(1596076823, 1),
&quot;$clusterTime&quot; : {
&quot;clusterTime&quot; : Timestamp(1596076823, 1),
&quot;signature&quot; : {
&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;
&quot;keyId&quot; : NumberLong(0)
}
}
}
</code></pre><p>如果是第二次启动，可以直接查看状态信息，不需要在设置配置文件。<br>查看状态信息，可以看到主服务器和备份服务器：</p>
<pre><code>rs-local-test:SECONDARY&gt;use test
switched to db test
rs-local-test:SECONDARY&gt; db.isMaster()
{
&quot;hosts&quot; : [
&quot;127.0.0.1:27017&quot;,
&quot;127.0.0.1:27018&quot;,
&quot;127.0.0.1:27019&quot;
],
&quot;setName&quot; : &quot;rs-local-test&quot;,
&quot;setVersion&quot; : 1,
&quot;ismaster&quot; : false,
&quot;secondary&quot; : true,
&quot;primary&quot; : &quot;127.0.0.1:27019&quot;,
&quot;me&quot; : &quot;127.0.0.1:27017&quot;,
&quot;lastWrite&quot; : {
&quot;opTime&quot; : {
&quot;ts&quot; : Timestamp(1596079583, 1),
&quot;t&quot; : NumberLong(5)
},
&quot;lastWriteDate&quot; : ISODate(&quot;2020-07-30T03:26:23Z&quot;),
&quot;majorityOpTime&quot; : {
&quot;ts&quot; : Timestamp(1596079583, 1),
&quot;t&quot; : NumberLong(5)
},
&quot;majorityWriteDate&quot; : ISODate(&quot;2020-07-30T03:26:23Z&quot;)
},
&quot;maxBsonObjectSize&quot; : 16777216,
&quot;maxMessageSizeBytes&quot; : 48000000,
&quot;maxWriteBatchSize&quot; : 100000,
&quot;localTime&quot; : ISODate(&quot;2020-07-30T03:26:25.289Z&quot;),
&quot;logicalSessionTimeoutMinutes&quot; : 30,
&quot;minWireVersion&quot; : 0,
&quot;maxWireVersion&quot; : 6,
&quot;readOnly&quot; : false,
&quot;ok&quot; : 1,
&quot;operationTime&quot; : Timestamp(1596079583, 1),
&quot;$clusterTime&quot; : {
&quot;clusterTime&quot; : Timestamp(1596079583, 1),
&quot;signature&quot; : {
&quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
&quot;keyId&quot; : NumberLong(0)
}
}
}
</code></pre><h3 id="读写测试"><a href="#读写测试" class="headerlink" title="读写测试"></a>读写测试</h3><p>连接主服务器后，可以写入数据：<br>重新启动一个cmd,连接一个备份服务器，查看是否数据被复制：<br>备份节点可能会落后于主节点，可能没有最新写入数据，所以备份节点默认情况下会拒绝读取请求，这是为了保护应用程序，以免意外连接到备份节点，读取到过期数据：</p>
<pre><code>rs-local-test:SECONDARY&gt; db.foo.find()
Error: error: {
        &quot;operationTime&quot; : Timestamp(1596079503, 1),
        &quot;ok&quot; : 0,
        &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,
        &quot;code&quot; : 13435,
        &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,
        &quot;$clusterTime&quot; : {
                &quot;clusterTime&quot; : Timestamp(1596079503, 1),
                &quot;signature&quot; : {
                        &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),
                        &quot;keyId&quot; : NumberLong(0)
                }
        }
}

从备份节点读取数据，需要设置标识：
db.getMongo().setSlaveOk();
</code></pre><h3 id="节点变更"><a href="#节点变更" class="headerlink" title="节点变更"></a>节点变更</h3><p>在主节点插入数据后，如果有备份节点服务器没有启动，当在该备份启动后，也可以查询到写入的数据：<br>不能对备份节点执行写入操作，备份节点只能通过复制功能写入数据，不接受客户端的写入请求：<br>rs-local-test:SECONDARY&gt;</p>
<p>可以随时添加或删除成员,先按之前的方法创建一个备用服务器，再添加进去：<br>rs.add(‘127.0.0.1’:4444)<br>rs是一个全局变量，其中包含与复制相关的辅助函数。<br>删除成员：<br>rs.remove(‘127.0.0.1’:4444)</p>
<p>添加或删除完可通过 db.isMaster()查看修改结果<br>也可rs.config();</p>
<pre><code>rs-local-test:SECONDARY&gt; rs.config()
{
        &quot;_id&quot; : &quot;rs-local-test&quot;,
        &quot;version&quot; : 1,
        &quot;protocolVersion&quot; : NumberLong(1),
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 0,
                        &quot;host&quot; : &quot;127.0.0.1:27017&quot;,
                        &quot;arbiterOnly&quot; : false,
                        &quot;buildIndexes&quot; : true,
                        &quot;hidden&quot; : false,
                        &quot;priority&quot; : 1,
                        &quot;tags&quot; : {

                        },
                        &quot;slaveDelay&quot; : NumberLong(0),
                        &quot;votes&quot; : 1
                },
                {
                        &quot;_id&quot; : 1,
                        &quot;host&quot; : &quot;127.0.0.1:27018&quot;,
                        &quot;arbiterOnly&quot; : false,
                        &quot;buildIndexes&quot; : true,
                        &quot;hidden&quot; : false,
                        &quot;priority&quot; : 1,
                        &quot;tags&quot; : {

                        },
                        &quot;slaveDelay&quot; : NumberLong(0),
                        &quot;votes&quot; : 1
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;host&quot; : &quot;127.0.0.1:27019&quot;,
                        &quot;arbiterOnly&quot; : false,
                        &quot;buildIndexes&quot; : true,
                        &quot;hidden&quot; : false,
                        &quot;priority&quot; : 1,
                        &quot;tags&quot; : {

                        },
                        &quot;slaveDelay&quot; : NumberLong(0),
                        &quot;votes&quot; : 1
                }
        ],
        &quot;settings&quot; : {
                &quot;chainingAllowed&quot; : true,
                &quot;heartbeatIntervalMillis&quot; : 2000,
                &quot;heartbeatTimeoutSecs&quot; : 10,
                &quot;electionTimeoutMillis&quot; : 10000,
                &quot;catchUpTimeoutMillis&quot; : -1,
                &quot;catchUpTakeoverDelayMillis&quot; : 30000,
                &quot;getLastErrorModes&quot; : {

                },
                &quot;getLastErrorDefaults&quot; : {
                        &quot;w&quot; : 1,
                        &quot;wtimeout&quot; : 0
                },
                &quot;replicaSetId&quot; : ObjectId(&quot;5f2232e3b3ef9f7db4cb682d&quot;)
        }
}
</code></pre><p>以上参考自 <a href="https://www.cnblogs.com/a-horse-mosaic/p/9284297.html" target="_blank" rel="noopener">https://www.cnblogs.com/a-horse-mosaic/p/9284297.html</a></p>
<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="如何开启读写分离"><a href="#如何开启读写分离" class="headerlink" title="如何开启读写分离"></a>如何开启读写分离</h3><p>默认情况下驱动是从Replica Set 集群中的 Primary 上进行读写的，应用可以在读多写少的场景下开启读写分离，提高效率。</p>
<p>读取偏好(Read Preference)参数</p>
<p>primary  主节点，默认模式，读操作只在主节点，如果主节点不可用，报错或者抛异常。</p>
<p>primaryPreferred 首选主节点，如果主节点不可用，如故障转移，读操作在从节点。</p>
<p>secondary 从节点，读操作只在从节点，如果从节点不可用，报错或者抛异常。</p>
<p>secondaryPreferred 首选从节点，大多情况下读操作在从节点，特殊情况（如单主节点架构）读操作在主节点。</p>
<p>nearest 最邻近节点，读操作在最邻近的成员，可能是主节点或者从节点</p>
<h3 id="在Mongodb中最多能创建多少集合？"><a href="#在Mongodb中最多能创建多少集合？" class="headerlink" title="在Mongodb中最多能创建多少集合？"></a>在Mongodb中最多能创建多少集合？</h3><p>默认情况下，MongoDB 的每个数据库的命名空间保存在一个 16MB 的 .ns 文件中，平均每个命名占用约 628 字节，也即整个数据库的命名空间的上限约为 24000。<br>每一个集合、索引都将占用一个命名空间。所以，如果每个集合有一个索引（比如默认的 _id 索引），那么最多可以创建 12000 个集合。如果索引数更多，则可创建的集合数就更少了。同时，如果集合数太多，一些操作也会变慢。甚至使得MongoDB集群无法服务的情况发生！</p>
<h3 id="MongoDB有传统数据库的事务和事务回滚么？"><a href="#MongoDB有传统数据库的事务和事务回滚么？" class="headerlink" title="MongoDB有传统数据库的事务和事务回滚么？"></a>MongoDB有传统数据库的事务和事务回滚么？</h3><p>没有，请不要把它当成关系型数据库来使用，对于MongoDB集群来说，默认情况下数据也不是强一致性的，而是最终一致性。如果对数据一致性比较敏感建议更改WriteConcern级别，但后果是降低了性能，请酌情考虑。</p>
<h3 id="MongoDB有命名规范么？"><a href="#MongoDB有命名规范么？" class="headerlink" title="MongoDB有命名规范么？"></a>MongoDB有命名规范么？</h3><ul>
<li>不能是空字符串</li>
<li>不能含有.、’’、*、/、\、&lt;、&gt;、:、?、$、\0。建议只使用ASCII码中字母和数字</li>
<li>数据库名区分大小写</li>
<li>数据库名长度最多为64字节</li>
<li>集合名不能包含\0字符，这个字符表示集合名的结束</li>
<li>集合名不能是空字符串””</li>
<li>集合名不能使用系统集合的保留前缀”system.”</li>
<li>集名名中不建议包含字符’$’，虽然很多驱动程序可以支持包含此字符的集合名</li>
</ul>
<h3 id="MongoDB有系统保留库名么？"><a href="#MongoDB有系统保留库名么？" class="headerlink" title="MongoDB有系统保留库名么？"></a>MongoDB有系统保留库名么？</h3><ul>
<li>admin</li>
<li>local</li>
<li>config</li>
</ul>
<h3 id="MongoDB有连接池么？"><a href="#MongoDB有连接池么？" class="headerlink" title="MongoDB有连接池么？"></a>MongoDB有连接池么？</h3><p>MongoDB驱动中其实已经是一个现成的连接池了，而且线程安全。这个内置的连接池默认初始了100个连接，每一个操作（增删改查等）都会获取一个连接，执行操作后释放连接。<br>【题外话】请务必记得关闭资源，并且设置合理的池子连接数和超时时间。</p>
<h3 id="内置连接池有多个重要参数，分别是"><a href="#内置连接池有多个重要参数，分别是" class="headerlink" title="内置连接池有多个重要参数，分别是"></a>内置连接池有多个重要参数，分别是</h3><ul>
<li>connectionsPerHost：每个主机答应的连接数（每个主机的连接池大小），当连接池被用光时，会被阻塞住，默认值为100</li>
<li>threadsAllowedToBlockForConnectionMultiplier：线程队列数，它和上面connectionsPerHost值相乘的结果就是线程队列最大值。如果连接线程排满了队列就会抛出“Out of semaphores to get db”错误，默认值为5，则最多有500个线程可以等待获取连接</li>
<li>maxWaitTime: 被阻塞线程从连接池获取连接的最长等待时间(ms)。默认值为120,000</li>
<li>connectTimeout：在建立（打开）套接字连接时的超时时间（ms）。默认值为10,000</li>
<li>socketTimeout：套接字超时时间（ms）。默认值为0，无限制（infinite）</li>
<li>autoConnectRetry：这个控制是否在连接时，会自动重试，2.13驱动已经【废弃】，请使用connectTimeout代替它</li>
</ul>
<p>连接池的MaximumPoolSize要有个合理值，否则这个值数据量的连接都被占用，后面再有新的连接创建时就要等待了，而不能超出池上限新建连接。除此之外还要设置合理的连接等待，连接超时时间，以防止一个连接占用时间过长，影响其它连接请求。</p>
<h3 id="connectTimeout-和-socketTimeout-的区别"><a href="#connectTimeout-和-socketTimeout-的区别" class="headerlink" title="connectTimeout 和 socketTimeout 的区别"></a>connectTimeout 和 socketTimeout 的区别</h3><p>一次完整的请求包括三个阶段：</p>
<ul>
<li>建立连接</li>
<li>数据传输</li>
<li>断开连接</li>
</ul>
<p>如果与服务器(这里指数据库)请求建立连接的时间超过ConnectTimeout，就会抛 ConnectionTimeOutException，即服务器连接超时，没有在规定的时间内建立连接。<br>如果与服务器连接成功，就开始数据传输了。<br>如果服务器处理数据用时过长，超过了SocketTimeOut，就会抛出SocketTimeOutExceptin，即服务器响应超时，服务器没有在规定的时间内返回给客户端数据。</p>
<p>所以这该死的超时该怎么配？<br>这里有一份国外写的关于超时的建议：<br><a href="http://blog.mongolab.com/2013/10/do-you-want-a-timeout/" target="_blank" rel="noopener">http://blog.mongolab.com/2013/10/do-you-want-a-timeout/</a><br>上文给出的通常情况下：connectTimeout=5000，socketTimeout=0</p>
<h3 id="关于WriteConcern"><a href="#关于WriteConcern" class="headerlink" title="关于WriteConcern"></a>关于WriteConcern</h3><p>MongoDB提供了一个配置参数：write concern 来让用户自己衡量性能和写安全。分布式数据库中这样的参数比较常见，记得Cassandra中也有一个类似参数，不过那个好像是要写入几个节点返回成功。其实道理都一样分布式的集群环境考虑到性能因素不能确保每个成员都写入后在返回成功，所以只能交给用户根据实际场景衡量。</p>
<ul>
<li>Unacknowledged</li>
<li>这个级别也属于比较低的级别，以前这个级别是驱动配置的默认级别，不过后来调整成Acknowledged级别。在这个级别下，这个驱动会根据当前系统的网络配置进行网络问题的检测，不等待Mongd的返回。代码测试：本地网络问题是否有异常？本地网络无问题是远程server问题是否异常？</li>
<li>Acknowledged</li>
<li>这个级别算是中等级别的配置，这个级别能够拿到mongod的返回信息：dupkey Error，以及一些其他的问题。现在这个级别是驱动的默认级别，估计是10gen公司发现好多人评价Mongodb不靠谱后改的。一般系统这个级别也就够用了。由于默认级别是Acknowledged，内部用getLastError方法检查是否写入成功的时候是也不用设置任何参数，对与Replset来说可以在配置中进行getLastErrorDefaults的配置，如果没有的话默认则是Master收到就ok。</li>
<li>Journaled</li>
<li>等到操作记录到Journal Log中才返回操作结果，也就是下一次JournaledLog提交。这种情况可以容忍服务器突然宕机，断电等意外的恢复。出去上边的配置还要在启动mongod的时候加上journaling 参数确保可以使用。commitlog提交间隔时间是可以配置的，单磁盘设备（physical volume, RAID device, or LVM volume）每100ms提交一次，和数据文件刷出相同频率，日志和数据分开磁盘设备的30ms提交一次。在插入数据是如果使用{j:true}则会缩短到已配置的默认设置1/3的时间。</li>
<li>Replica Acknowledged</li>
<li>在副本集中如果w设置为2的话则至少已经吸入到一个secondary中，我猜测写入secondary这个级别是Acknowledged级别，majority是多个secondary已经写入。如果手贱设置w参数大于replset中需要复制的secondarys的话，操作就一直等待直到达到已写入数据的服务器数量符合要求，也可以设置timeout值来指明最长等待时间。{ getLastError: 1, w: 2, wtimeout:5000 }</li>
</ul>
<h3 id="MongoDB的锁机制"><a href="#MongoDB的锁机制" class="headerlink" title="MongoDB的锁机制"></a>MongoDB的锁机制</h3><p>MongoDB的锁机制和一般关系数据库如 MySQL（InnoDB）, Oracle 有很大的差异，InnoDB 和 Oracle 能提供行级粒度锁，而 MongoDB v2 只能提供库级粒度锁，这意味着当 MongoDB 一个写锁处于占用状态时，其它的读写操作都得干等。</p>
<p>初看起来库级锁在大并发环境下有严重的问题，但是 MongoDB 依然能够保持大并发量和高性能，这是因为 MongoDB 的锁粒度虽然很粗放，但是在锁处理机制和关系数据库锁有很大差异，主要表现在</p>
<ul>
<li>MongoDB 没有完整事务支持，操作原子性只到单个 document 级别，所以通常操作粒度比较小；</li>
<li>MongoDB 锁实际占用时间是内存数据计算和变更时间，通常很快；</li>
<li>MongoDB 锁有一种临时放弃机制，当出现需要等待慢速 IO 读写数据时，可以先临时放弃，等 IO 完成之后再重新获取锁。</li>
</ul>
<p>通常不出问题不等于没有问题，如果数据操作不当，依然会导致长时间占用写锁，比如下面提到的前台建索引操作，当出现这种情况的时候，整个数据库就处于完全阻塞状态，无法进行任何读写操作，情况十分严重。</p>
<p>解决问题的方法，尽量避免长时间占用写锁操作，如果有一些集合操作实在难以避免，可以考虑把这个集合放到一个单独的 MongoDB 库里，因为 MongoDB 不同库锁是相互隔离的，分离集合可以避免某一个集合操作引发全局阻塞问题。</p>
<h3 id="建索引导致数据库阻塞"><a href="#建索引导致数据库阻塞" class="headerlink" title="建索引导致数据库阻塞"></a>建索引导致数据库阻塞</h3><p>上面提到了 MongoDB 库级锁的问题，建索引就是一个容易引起长时间写锁的问题，MongoDB 在前台建索引时需要占用一个写锁（而且不会临时放弃），如果集合的数据量很大，建索引通常要花比较长时间，特别容易引起问题。</p>
<p>解决的方法很简单，MongoDB 提供了两种建索引的访问，一种是 background 方式，不需要长时间占用写锁，另一种是非 background 方式，需要长时间占用锁。使用 background 方式就可以解决问题。<br>例如，为超大表 posts 建立索引</p>
<pre><code>//千万不用使用
db.posts.ensureIndex({user_id: 1})
//而应该使用
db.posts.ensureIndex({user_id: 1}, {background: 1})
</code></pre><p><a href="http://www.111com.net/database/165981.htm" target="_blank" rel="noopener">http://www.111com.net/database/165981.htm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/ffmpeg的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/04/ffmpeg的使用/" itemprop="url">ffmpeg的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-04T08:22:08+08:00">
                2020-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="视频格式小科普"><a href="#视频格式小科普" class="headerlink" title="视频格式小科普"></a>视频格式小科普</h2><p>在开始下面的教程之前有必要先简单科普一下视频格式的知识。</p>
<p>视频格式是一种非常不专业的叫法，事实上，视频有编码格式和容器格式两种。编码格式之于容器格式就像牛奶之于杯子一样。 常见的视频文件有mp4(mpeg4 part 14)，mkv，flv等，这些是视频的容器格式/封装格式(Container format)。它们包含视频流和音频流，mkv支持多条音轨和字幕，因此是目前最受欢迎的容器格式。比如在播放mkv视频的时候，可以选择不同语言的音轨/字幕。 至于视频编码格式(Encoding format)，则是这些容器所包含的视频流/音频流所采用的压缩方式，比如最常用的h.264/aac，mpeg4/mpeg3等。</p>
<h3 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h3><p>在mac os上安装ffmpeg：</p>
<p>brew install ffmpeg –with-fdk-aac –with-libass –with-sdl2<br>与默认安装相比，这里增加了对fdk-aac音频库和ass字幕库的支持，同时安装了ffplay播放器。</p>
<p>在linux上安装ffmpeg最简单的方式是使用官方提供的静态编译安装包，解压后即可使用。</p>
<p>ffmpeg命令通用格式<br>先来认识一下ffmpeg命令行工具的格式：</p>
<p><code>ffmpeg -global_options -input_1_options -i input_1 -input_2_options -i input_2 -output_1_options output_1</code> …<br>不管你看到的ffmpeg命令多么复杂，万变不离其宗，都可以按照这个格式拆分成几个单独的部分，各个选项的含义可以查阅ffmpeg的documentation。</p>
<p>需要注意的是： <em> 输入输出 </em> 至少有一个输入和输出 <em> 可以同时有多个输入和输出 </em> 输入、输出不一定是文件，可以是rtmp流的地址、摄像头对应的设备文件等 <em> 顺序很重要 </em> 所有的输入完了然后是输出 * 某个选项只对它后面的输入或输出起作用</p>
<h3 id="1、查看视频的信息"><a href="#1、查看视频的信息" class="headerlink" title="1、查看视频的信息"></a>1、查看视频的信息</h3><p><code>ffmpeg -hide_banner -i input.mkv  或者  ffprobe -hide_banner input.mkv</code></p>
<p>通过ffmpeg可以查看一个视频文件的以下基本信息：</p>
<p>视频/音频的编码格式<br>分辨率(1080p or 1080i, Progressive Interlaced)<br>时长(duration)/码率(bitrate)/帧率(fps,frames per second)<br>音轨(Audio)/字幕(Subtitle)</p>
<h3 id="2、转码-transcode"><a href="#2、转码-transcode" class="headerlink" title="2、转码(transcode)"></a>2、转码(transcode)</h3><p>转码是指对流(视频、音频和字幕)进行解码然后再编码，这个过程非常耗CPU。输出的编码格式通过-codec指定，如果不指定，ffmpeg并不会直接copy，而是采用根据容器格式采用相应的默认编码格式进行重新编码。</p>
<p>为了简单起见，把转换容器格式也归为转码，ffmpeg会通过输出文件的后缀判断输出的容器格式，因此不需要指定(-f)。</p>
<p>视频<br>将mkv转换成mp4</p>
<p>有时候我们需要将mkv转换成mp4：</p>
<p>很多视频网站不支持上传mkv格式<br>大部分视频剪辑软件，比如premiere等不支持导入mkv格式的视频<br>下面的命令将mkv的视频和音频流重新封装成mp4文件，不进行重新编码(无损)</p>
<p><code>ffmpeg -i input.mkv -codec copy output.mp4</code><br>制作mkv</p>
<p>mkv格式能够封装多个音频、字幕轨，是目前最为流行的视频分发格式，通常使用mkvtoolnix工具来编辑制作mkv视频，通过ffmpeg也能完成一些简单的任务。</p>
<p>将mpeg4/mp3编码的视频重新编码为h.264/aac，并和字幕一起封装成mkv文件：</p>
<p><code>ffmpeg -i input.avi -i input.srt -map 0:0 -map 0:1 -map 1:0 -c:v libx264 -c:a aac -c:s srt output.mkv</code><br>这里使用ffmpeg自带的aac音频编码器，而不是fdkaac。</p>
<p>音频<br>ffmpeg不仅能处理视频，音频文件也不在话下，因此，同样可以用ffmpeg转换音频格式。</p>
<p>将flac无损的音乐转换成高质量(High Quality，即320Kb)的mp3格式：</p>
<p><code>ffmpeg -i &quot;Michael Jackson - Billie Jean.flac&quot; -ab 320k &quot;Michael Jackson - Billie Jean.mp3&quot;</code></p>
<h3 id="3、截取-cut"><a href="#3、截取-cut" class="headerlink" title="3、截取(cut)"></a>3、截取(cut)</h3><p>从视频中截取出精彩片段是我们最常用的功能。</p>
<p>从第2分钟开始，截取30秒。所有流都直接拷贝。</p>
<p><code>ffmpeg -ss 00:02:00.0 -i input.mkv -t 30 -c copy output.mkv</code><br>-ss设置开始时间点，格式是HH:MM:SS.xxx或sec.msec。当作为输入选项时，可以快速seek到指定时间点； -t作为输出选项，设置时长。</p>
<p>截取最大的问题是难以做到精确控制时间点，大部分的视频剪辑软件都存在这样的问题：</p>
<p>视频开头卡顿/不流畅，画面与声音不同步<br>时间误差甚至能达到秒级，比如截取10秒的片段，可能会得到12秒的输出<br>原因是ffmpeg会seek到指定时间点前的一个关键帧，如果是copy视频流，seek点和起点之间的额外部分将会被保留，因此就产生了误差。解决办法是将-ss作为输出选项或进行重新编码：</p>
<p><code>ffmpeg -i input.mkv -ss 00:02:00.0 -t 30 -c copy output.mkv</code><br>-ss作为输出选项时，解码到指定的时间点，然后开始输出，相当于要扫描前面的所有帧。但是这种方式能获得更精确的输出。</p>
<p>如果还是出现上述问题，使用下面的终极解决方案(使用两次seek)：</p>
<p><code>ffmpeg -ss 00:01:30.0 -i input.mkv -ss 00:00:30.0 -t 30 output.mkv</code></p>
<h3 id="4、截图-screenshot"><a href="#4、截图-screenshot" class="headerlink" title="4、截图(screenshot)"></a>4、截图(screenshot)</h3><p>截图就是将某个视频帧保存为图片，例如：</p>
<p>在指定时间点截图</p>
<p><code>ffmpeg -ss 00:30:14.435 -i input.mkv -vframes 1 out.png</code></p>
<ul>
<li>-ss作为输入选项，可以快速定位到指定时间点；如果作为输出选项，需要读取指定时间点前面所有的帧，但可以获得更精确的位置。 * -vframes设置输出的帧数。</li>
</ul>
<p>结合fps视频滤镜，可以从视频中截取多张图片。例如：</p>
<p>每1分钟截一张图，在截图文件名中添加当前的时间</p>
<p><code>ffmpeg -i input.mkv -vf fps=1/60 -strftime 1 out_%Y%m%d%H%M%S.jpg</code></p>
<h3 id="5、压缩-compress"><a href="#5、压缩-compress" class="headerlink" title="5、压缩(compress)"></a>5、压缩(compress)</h3><p>一张蓝光原盘接近50G，而720p的电影可能只有2G，这是通过压缩实现的。在保证画质的前提下使用更小的文件存储，一直是压缩的目标。然而压缩并非那么简单，比如同样是720p的电影，有的只有2个G，有的却有5个G，然而从视觉上几乎看不出区别来。 这里只介绍压缩的一个简单用途：resize。</p>
<p>将1080p转成720p，宽度自适应</p>
<p><code>ffmpeg -i input.mkv -c copy -c:v libx264 -vf scale=-2:720 output.mkv</code><br>-vf是-filter:v的简写，-filter指定滤镜，:v是流选择器，表示对视频流应用滤镜。scale滤镜后面的参数是w:h，w和h可以包含一些变量，比如原始的宽高分别为iw和ih。当其中一个是负数时，假设为-n，ffmpeg自动使用另一个值按照原始的宽高比(aspect ratio)计算出该值，并且保证计算出来的值能被n整除。</p>
<p>因为scale滤镜是针对未编码的原始数据，所以视频流不能用copy，需要进行重新编码。-c copy -c:v libx264表示视频流使用h.264重新编码，其他流直接copy，顺序不能颠倒。</p>
<h3 id="6、字幕-subtitle"><a href="#6、字幕-subtitle" class="headerlink" title="6、字幕(subtitle)"></a>6、字幕(subtitle)</h3><p>对于视频发布者，给视频添加字幕很有必要。如果是mkv，可以采用制作mkv的方法将字幕文件封装到mkv文件里。如果是mp4视频，则需要进行烧录(draw)，即对视频重新编码的过程中将字幕融入视频流。</p>
<p><code>ffmpeg -i input.mkv -vf subtitles=input.srt output.mp4</code><br>该过程是通过subtitles滤镜完成的，安装ffmpeg的时候需要启用libass库。subtitles的参数是字幕文件，如果是mkv文件则表示使用mkv的默认字幕流。</p>
<p>如果是ass格式的字幕文件，则使用ass滤镜：</p>
<p><code>ffmpeg -i input.mkv -vf ass=input.ass output.mp4</code><br>据我所知，通常ass字幕具有更丰富的样式。</p>
<p>另一种常见的方法是使用-c:s mov_text将字幕流封装进mp4里，它不需要重新编码，但是目前大部分播放器对mp4的软字幕支持不好。</p>
<h3 id="7、提取-extract"><a href="#7、提取-extract" class="headerlink" title="7、提取(extract)"></a>7、提取(extract)</h3><p>有时候我们需要从电影中提取插曲或从视频中提取背景音乐，通过ffmpeg可以很容易从视频文件中提取音频：</p>
<p><code>ffmpeg -i cut.mp4 -vn output.mp3</code><br>-vn表示不输出视频流。</p>
<p>输出的mp3默认的码率是128kb，可以使用ab控制。结合截取中的-ss和-t还可以只提取一个部分的音频。</p>
<p>从mkv文件中提取字幕也是同样的方法。</p>
<h3 id="8、水印-watermark"><a href="#8、水印-watermark" class="headerlink" title="8、水印(watermark)"></a>8、水印(watermark)</h3><p>给视频添加水印是通过overlay滤镜实现的，overlay滤镜的作用是将一个视频覆盖另一个视频上面，它有两个输入，前一个是下层(main)，后一个是上层(overlaid)。 overlay的参数x:y是上层左上角的坐标，0:0表示位于下层的左上角。它可以包含以下参数：</p>
<p>W(w):下(上)层的宽<br>H(h):下(上)层的高<br>将水印/logo添加到视频的右上角，并且和边缘保持5像素的距离：</p>
<p><code>ffmpeg -i input.mkv -i input.png -filter_complex &quot;overlay=W-w-5:5&quot; -c copy -c:v libx264 output.mkv</code><br>input.png是带透明背景的logo，作为上层。</p>
<p>需要注意的是，视频需要重新编码，其他流(音频、字幕)则直接copy，顺序不能颠倒。</p>
<h3 id="9、混流-Muxing"><a href="#9、混流-Muxing" class="headerlink" title="9、混流(Muxing)"></a>9、混流(Muxing)</h3><p>如果我们拍摄了一段视频，想给它添加背景音乐，最好还是借助视频编辑软件，它能对音乐的开头和结尾分别进行增强和减弱的处理，如果不在意这些细节，完全可以用ffmpeg来代替。</p>
<p>替换音频<br><code>ffmpeg -i input.mkv -i input.mp3 -map 0:v -map 1:a -c copy -shortest output.mp4</code><br>-map的作用是手动选择输出的流：</p>
<p>-map 0:v – 从输入0(第1个输入，即input.mkv) 选择视频流<br>-map 1:a – 从输入1(第2个输入，即input.mp3) 选择音频流<br>第1个map对应输出的第1个流，第2个map对应输出的第2个流，以此类推。</p>
<p>合并音频<br>另一个常见的形式是将两个音频合并成一个，需要使用amerge滤镜：</p>
<p><code>ffmpeg -i input.mkv -i output.aac -filter_complex &quot;[0:a][1:a]amerge=inputs=2[a]&quot; -map 0:v -map &quot;[a]&quot; -c:v copy -c:a aac -ac 2 -shortest output.mp4</code></p>
<h3 id="10、制作gif"><a href="#10、制作gif" class="headerlink" title="10、制作gif"></a>10、制作gif</h3><p>结合前面讲到的截取和压缩，将输出文件的后缀改为gif就可以得到动态图</p>
<p><code>ffmpeg -ss 30 -t 5 -i input.mp4 -r 10 -vf scale=-1:144 -y output.gif</code><br>-r指定帧率，原始的帧率是25，降低帧率能减小gif图片的大小。</p>
<p>但是这种方式的效果很差，有一种粗糙的布料的感觉。 原因在于gif限制只能包含256种颜色，而原始视频可能包含数以百万的颜色，ffmpeg默认会使用一种通用的调色板(palettep)，因此导致颜色失真。2015年，ffmpeg通过引入palettegen和paletteuse两个滤镜来改进这个问题，它通过扫描整个视频，输出一个最佳的调色板，然后再转换成gif的过程中应用这个调色板从而避免颜色失真。</p>
<p>下面的命令从input.mp4的第30秒开始截取5秒，生成高144像素的gif动态图：</p>
<p><code>palette=&quot;/tmp/palette.png&quot;</code><br><code>filters=&quot;fps=10,scale=-1:144:flags=lanczos&quot;</code></p>
<p><code>ffmpeg -ss 30 -t 5 -i input.mp4 -vf &quot;$filters,palettegen&quot; -y $palette</code><br><code>ffmpeg -ss 30 -t 5 -i input.mp4 -i $palette -filter_complex &quot;$filters [x]; [x][1:v] paletteuse&quot; -y output.gif</code></p>
<p>与前一个输出相比，质量提升了很多。</p>
<p>另一个有待研究的难题是如何控制输出gif的大小。在不影响画质的前提下，我们希望体积越小越好。比如网上有的gif图很清晰，却不超过1M。而一段500K的视频文件，使用上面的方法转成gif后输出的gif却有1.6M。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/10/分布式环境下redis的使用优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/10/分布式环境下redis的使用优化/" itemprop="url">分布式环境下redis的使用优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-10T08:50:07+08:00">
                2020-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式与集群"><a href="#分布式与集群" class="headerlink" title="分布式与集群"></a>分布式与集群</h1><p>单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。但是，当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了。</p>
<p>从单机结构到集群结构，你的代码基本无需要作任何修改，你要做的仅仅是多部署几台服务器，每台服务器上运行相同的代码就行了。但是，当你要从集群结构演进到微服务结构的时候，之前的那套代码就需要发生较大的改动了。所以对于新系统我们建议，系统设计之初就采用微服务架构，这样后期运维的成本更低。但如果一套老系统需要升级成微服务结构的话，那就得对代码大动干戈了。所以，对于老系统而言，究竟是继续保持集群模式，还是升级成微服务架构，这需要你们的架构师深思熟虑、权衡投入产出比。OK，下面开始介绍所谓的分布式结构。分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。</p>
<p>举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。这样的好处有很多：系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发。</p>
<p><img src="/2020/03/10/分布式环境下redis的使用优化/redis0.png" alt=""></p>
<h1 id="集群环境下redis锁的进一步优化"><a href="#集群环境下redis锁的进一步优化" class="headerlink" title="集群环境下redis锁的进一步优化"></a>集群环境下redis锁的进一步优化</h1><h2 id="死锁的问题"><a href="#死锁的问题" class="headerlink" title="死锁的问题"></a>死锁的问题</h2><p><img src="/2020/03/10/分布式环境下redis的使用优化/redis1.png" alt=""></p>
<p>解决：<br><img src="/2020/03/10/分布式环境下redis的使用优化/redis2.png" alt=""></p>
<h2 id="假如程序被kill了，删除锁同样无法执行得到"><a href="#假如程序被kill了，删除锁同样无法执行得到" class="headerlink" title="假如程序被kill了，删除锁同样无法执行得到"></a>假如程序被kill了，删除锁同样无法执行得到</h2><p><img src="/2020/03/10/分布式环境下redis的使用优化/redis3.png" alt=""></p>
<p>解决：给锁增加过期时间</p>
<p><img src="/2020/03/10/分布式环境下redis的使用优化/redis4.png" alt=""></p>
<h2 id="过期时间的确定"><a href="#过期时间的确定" class="headerlink" title="过期时间的确定"></a>过期时间的确定</h2><p> 假如程序1执行到删除锁的时间大于了过期时间，也就是程序1还没执行完锁就被删掉了，此时另外一个线程也可以拿到锁。当线程1执行完去删除锁的时候删掉的就是线程2的锁了，程序就乱了。</p>
<p>解决：<br>保证当前线程只删除当前线程加的锁</p>
<p><img src="/2020/03/10/分布式环境下redis的使用优化/redis5.png" alt=""></p>
<p><img src="/2020/03/10/分布式环境下redis的使用优化/redis6.png" alt=""></p>
<h2 id="redisson-org的使用"><a href="#redisson-org的使用" class="headerlink" title="redisson.org的使用"></a>redisson.org的使用</h2><pre><code>&lt;dependency&gt;
        &lt;groupId&gt;org.redisson&lt;/groupId&gt;
        &lt;artifactId&gt;redisson&lt;/artifactId&gt;
        &lt;version&gt;3.6.5&lt;/version&gt;
    &lt;/dependency&gt;


  @Bean
    @ConditionalOnProperty(name=&quot;redisson.address&quot;)
    RedissonClient redissonSingle() {
        Config config = new Config();
        SingleServerConfig serverConfig = config.useSingleServer()
                .setAddress(redssionProperties.getAddress())
                .setTimeout(redssionProperties.getTimeout())
                .setConnectionPoolSize(redssionProperties.getConnectionPoolSize())
                .setConnectionMinimumIdleSize(redssionProperties.getConnectionMinimumIdleSize());

        if(StringUtils.isNotBlank(redssionProperties.getPassword())) {
            serverConfig.setPassword(redssionProperties.getPassword());
        }

        return Redisson.create(config);
    }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/多核并发缓存架构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/04/多核并发缓存架构/" itemprop="url">多核并发缓存架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-04T14:41:02+08:00">
                2020-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h1><p>现代计算机模型是基于-冯诺依曼计算机模型，主要包括五大核心部分，1.控制器，2.运算器，3.存储器，4.输入，5.输出。<br>图如下：</p>
<p><img src="/2020/03/04/多核并发缓存架构/cpu0.png" alt=""></p>
<h1 id="CPU的基本结构及其工作原理"><a href="#CPU的基本结构及其工作原理" class="headerlink" title="CPU的基本结构及其工作原理"></a>CPU的基本结构及其工作原理</h1><p>中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，ArithmeTIc Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。</p>
<h2 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h2><p>从功能上看，一般CPU的内部结构可分为：控制单元、逻辑运算单元、存储单元（包括内部总线和缓冲器）三大部分。其中控制单元完成数据处理整个过程中的调配工作，逻辑单元则完成各个指令以便得到程序最终想要的结果，存储单元就负责存储原始数据以及运算结果。浑然一体的配合使得CPU拥有了强大的功能，可以完成包括浮点、多媒体等指令在内的众多复杂运算，也为数字时代加入了更多的活力。</p>
<p>　　逻辑部件</p>
<p>　　英文Logic components；运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。</p>
<p>　　寄存器</p>
<p>　　寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。</p>
<p>　　控制部件</p>
<p>　　英文Control unit；控制部件，主要是负责对指令译码，并且发出为完成每条指令所要执行的各个操作的控制信号。</p>
<p>　　其结构有两种：一种是以微存储为核心的微程序控制方式；一种是以逻辑硬布线结构为主的控制方式。</p>
<p>　　微存储中保持微码，每一个微码对应于一个最基本的微操作，又称微指令；各条指令是由不同序列的微码组成，这种微码序列构成微程序。中央处理器在对指令译码以后，即发出一定时序的控制信号，按给定序列的顺序以微周期为节拍执行由这些微码确定的若干个微操作，即可完成某条指令的执行。</p>
<p>　　简单指令是由（3～5）个微操作组成，复杂指令则要由几十个微操作甚至几百个微操作组成。</p>
<h2 id="CPU的逻辑单元"><a href="#CPU的逻辑单元" class="headerlink" title="CPU的逻辑单元"></a>CPU的逻辑单元</h2><p>CPU大致可分为如下八个逻辑单元：</p>
<p>指令高速缓存，俗称指令寄存器 ： 它是芯片上的指令仓库，有了它CPU就不必停下来查找计算机内存中的指令，从而大幅提高了CPU的运算速度。</p>
<p>译码单元，俗称指令译码器 ： 它负责将复杂的机器语言指令解译成运算逻辑单元（ALU）和寄存器能够理解的简单格式，就像一位外交官。</p>
<p>控制单元 ： 既然指令可以存入CPU，而且有相应指令来完成运算前的准备工作，背后自然有一个扮演推动作用的角色——它便是负责整个处理过程的操作控制器。根据来自译码单元的指令，它会生成控制信号，告诉运算逻辑单元（ALU）和寄存器如何运算、对什么进行运算以及对结果进行怎样的处理。</p>
<p>寄存器 ： 它对于CPU来说非常的重要，除了存放程序的部分指令，它还负责存储指针跳转信息以及循环操作命令，是运算逻辑单元（ALU）为完成控制单元请求的任务所使用的数据的小型存储区域，其数据来源可以是高速缓存、内存、控制单元中的任何一个。</p>
<p>逻辑运算单元（ALU） ： 它是CPU芯片的智能部件，能够执行加、减、乘、除等各种命令。此外，它还知道如何读取逻辑命令，如或、与、非。来自控制单元的讯息将告诉运算逻辑单元应该做些什么，然后运算单元会从寄存器中间断或连续提取数据，完成最终的任务。</p>
<p>预取单元 ： CPU效能发挥对其依赖非常明显，预取命中率的高低直接关系到CPU核心利用率的高低，进而带来指令执行速度上的不同。根据命令或要执行任务所提出的要求，何时时候，预取单元都有可能从指令高速缓存或计算机内存中获取数据和指令。当指令到达时，预取单元最重要的任务就是确保所有指令均排列正确，然后发送给译码单元。</p>
<p>总线单元 ： 它就像一条高速公路，快速完成各个单元间的数据交换，也是数据从内存流进和流出CPU的地方。</p>
<p>数据高速缓存 ： 存储来自译码单元专门标记的数据，以备逻辑运算单元使用，同时还准备了分配到计算机不同部分的最终结果。</p>
<p>通过以上介绍可以看出CPU虽小，方寸之地却能容纳大世界，内部更像一个发达的装配工厂，环环相扣，层层相套。正因为有了相互间的协作配合，才使得指令最终得以执行，才构成了图文并茂、影像结合的神奇数字世界。</p>
<h2 id="CPU的工作原理"><a href="#CPU的工作原理" class="headerlink" title="CPU的工作原理"></a>CPU的工作原理</h2><p>CPU的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元，这三部分由CPU内部总线连接起来。如下所示：</p>
<p><img src="/2020/03/04/多核并发缓存架构/cpu3.png" alt=""></p>
<p>控制单元：控制单元是整个CPU的指挥控制中心，由指令寄存器IR（InstrucTIon Register）、指令译码器ID（InstrucTIon Decoder）和操作控制器OC（OperaTIon Controller）等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</p>
<p>运算单元：是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。</p>
<p>存储单元：包括CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少CPU访问内存的次数，从而提高了CPU的工作速度。但因为受到芯片面积和集成度所限，寄存器组的容量不可能很大。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据。而通用寄存器用途广泛并可由程序员规定其用途，通用寄存器的数目因微处理器而异。这个是我们以后要介绍这个重点，这里先提一下。</p>
<p>我们将上图细化一下，可以得出CPU的工作原理概括如下：</p>
<p><img src="/2020/03/04/多核并发缓存架构/cpu4.png" alt=""></p>
<p>1、取指令：CPU的控制器从内存读取一条指令并放入指令寄存器。</p>
<p>操作码就是汇编语言里的mov，add，jmp等符号码；操作数地址说明该指令需要的操作数所在的地方，是在内存里还是在CPU的内部寄存器里。</p>
<p>2、指令译码：指令寄存器中的指令经过译码，决定该指令应进行何种操作（就是指令里的操作码）、操作数在哪里（操作数的地址）。</p>
<p>3、 执行指令，分两个阶段“取操作数”和“进行运算”。</p>
<p>4、 修改指令计数器，决定下一条指令的地址。</p>
<p>CPU在运算数据的时候（比如 1+1＝2），会首先从CUP寄存器读取数据（速度最快，因为内置在CPU里面），如果没有，就从三级缓存里读取，如果三级缓存也没有，则会经过系统总线及内存总线，从总存储器中读取（此处的总存储器主要是指主内存）。</p>
<p>首先CPU工作的时候，由控制单元充当大脑，负责协调。让运算单元做运算的时候，会首先从最靠近CPU的寄存器（其实是和CPU一体的）上读取数据，在寄存器上有CPU运行的常用指令，如果寄存器上没有想要的数据，则就从三级缓存的L1级缓存中获取，如果L1取到数据了，会加载到寄存器中，再转输给CPU运算单元。如果L1中没有，则从L2级缓存中读取，同理，如果没有，则从L3中取。如果L3中也没有，这个时候，就比较麻烦了。要从主内存中取。而从主内存中取的时候，会经过系统总线及内存总线。这时因受到总线的限制，速度会大大降低。</p>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a><strong>缓存一致性问题</strong></h3><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存<br>（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是<br>也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一<br>块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步<br>回到主内存时以谁的缓存数据为准呢？<br>为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，在读写时要根据协议来进行操作。常用的方法是总线加锁或是缓存一致性协议-MESI </p>
<p><img src="/2020/03/04/多核并发缓存架构/cpu5.png" alt=""></p>
<p>这里重点说一个什么是缓存一致性协议mesi:<br>概念：CPU最小存储单元：缓存行<br>MESI代表的四种状态：<br>M：修改<br>E：独享。互斥<br>S：共享<br>I：无效<br>MESI缓存一致性协议原理：<br>假如现在有CPU1和CPU2，主内存有变量X＝ 1 。现在要做 x+1的操作。<br>如果在变量 x = 1 上加上volatile，则就会触发MESI<br>当CPU1从主内存中读取到X＝1时，CPU1会把此变量标记成独享状态<br>并监听总线，是否有其它CPU去读取此变量<br>当CPU2从主内存中读取X＝1变量时，CPU1会通过嗅探机制监听到。<br>此时CPU1的X变量会变成共享状态。继续进行计算，计算完变成X＝2。<br>此时要回写到主内存之前。先锁住缓存行。并标记X变量为修改状态。并向总线发消息。<br>其它CPU2监听总线时，会监听到，并把X标记成无效状态。<br>CPU1把变量X＝2回写到主内存后，会由修改状态变成独享状态。<br>此时，如果CPU2如果想修改X变量时，要重启从主内存中读取。然后开始新的轮回。</p>
<h3 id="指令重排序问题"><a href="#指令重排序问题" class="headerlink" title="指令重排序问题"></a><strong>指令重排序问题</strong></h3><p>为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执 行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该 结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的 顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不 能靠代码的先后顺序来保证。<br>与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有 类似的指令重排序（Instruction Reorder）优化</p>
<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>java线程内存模型跟cpu缓存模型类似，是基于cpu缓存模型来建立的，java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Airthink">
          <p class="site-author-name" itemprop="name">Airthink</p>
           
              <p class="site-description motion-element" itemprop="description">The Pursuit of Happyness</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ikangbow" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Airthink</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
