---
title: 多核并发缓存架构
date: 2020-03-04 14:41:02
tags: java
category: java
---

# 计算机架构

现代计算机模型是基于-冯诺依曼计算机模型，主要包括五大核心部分，1.控制器，2.运算器，3.存储器，4.输入，5.输出。
图如下：

![](cpu0.png)

# CPU的基本结构及其工作原理

中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，ArithmeTIc Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。

## CPU的基本结构

从功能上看，一般CPU的内部结构可分为：控制单元、逻辑运算单元、存储单元（包括内部总线和缓冲器）三大部分。其中控制单元完成数据处理整个过程中的调配工作，逻辑单元则完成各个指令以便得到程序最终想要的结果，存储单元就负责存储原始数据以及运算结果。浑然一体的配合使得CPU拥有了强大的功能，可以完成包括浮点、多媒体等指令在内的众多复杂运算，也为数字时代加入了更多的活力。

　　逻辑部件

　　英文Logic components；运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。

　　寄存器

　　寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。

　　控制部件

　　英文Control unit；控制部件，主要是负责对指令译码，并且发出为完成每条指令所要执行的各个操作的控制信号。

　　其结构有两种：一种是以微存储为核心的微程序控制方式；一种是以逻辑硬布线结构为主的控制方式。

　　微存储中保持微码，每一个微码对应于一个最基本的微操作，又称微指令；各条指令是由不同序列的微码组成，这种微码序列构成微程序。中央处理器在对指令译码以后，即发出一定时序的控制信号，按给定序列的顺序以微周期为节拍执行由这些微码确定的若干个微操作，即可完成某条指令的执行。

　　简单指令是由（3～5）个微操作组成，复杂指令则要由几十个微操作甚至几百个微操作组成。

## CPU的逻辑单元

CPU大致可分为如下八个逻辑单元：

指令高速缓存，俗称指令寄存器 ： 它是芯片上的指令仓库，有了它CPU就不必停下来查找计算机内存中的指令，从而大幅提高了CPU的运算速度。

译码单元，俗称指令译码器 ： 它负责将复杂的机器语言指令解译成运算逻辑单元（ALU）和寄存器能够理解的简单格式，就像一位外交官。

控制单元 ： 既然指令可以存入CPU，而且有相应指令来完成运算前的准备工作，背后自然有一个扮演推动作用的角色——它便是负责整个处理过程的操作控制器。根据来自译码单元的指令，它会生成控制信号，告诉运算逻辑单元（ALU）和寄存器如何运算、对什么进行运算以及对结果进行怎样的处理。

寄存器 ： 它对于CPU来说非常的重要，除了存放程序的部分指令，它还负责存储指针跳转信息以及循环操作命令，是运算逻辑单元（ALU）为完成控制单元请求的任务所使用的数据的小型存储区域，其数据来源可以是高速缓存、内存、控制单元中的任何一个。

逻辑运算单元（ALU） ： 它是CPU芯片的智能部件，能够执行加、减、乘、除等各种命令。此外，它还知道如何读取逻辑命令，如或、与、非。来自控制单元的讯息将告诉运算逻辑单元应该做些什么，然后运算单元会从寄存器中间断或连续提取数据，完成最终的任务。

预取单元 ： CPU效能发挥对其依赖非常明显，预取命中率的高低直接关系到CPU核心利用率的高低，进而带来指令执行速度上的不同。根据命令或要执行任务所提出的要求，何时时候，预取单元都有可能从指令高速缓存或计算机内存中获取数据和指令。当指令到达时，预取单元最重要的任务就是确保所有指令均排列正确，然后发送给译码单元。

总线单元 ： 它就像一条高速公路，快速完成各个单元间的数据交换，也是数据从内存流进和流出CPU的地方。

数据高速缓存 ： 存储来自译码单元专门标记的数据，以备逻辑运算单元使用，同时还准备了分配到计算机不同部分的最终结果。

通过以上介绍可以看出CPU虽小，方寸之地却能容纳大世界，内部更像一个发达的装配工厂，环环相扣，层层相套。正因为有了相互间的协作配合，才使得指令最终得以执行，才构成了图文并茂、影像结合的神奇数字世界。

## CPU的工作原理

CPU的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元，这三部分由CPU内部总线连接起来。如下所示：

![](cpu3.png)

控制单元：控制单元是整个CPU的指挥控制中心，由指令寄存器IR（InstrucTIon Register）、指令译码器ID（InstrucTIon Decoder）和操作控制器OC（OperaTIon Controller）等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。

运算单元：是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。

存储单元：包括CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少CPU访问内存的次数，从而提高了CPU的工作速度。但因为受到芯片面积和集成度所限，寄存器组的容量不可能很大。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据。而通用寄存器用途广泛并可由程序员规定其用途，通用寄存器的数目因微处理器而异。这个是我们以后要介绍这个重点，这里先提一下。

我们将上图细化一下，可以得出CPU的工作原理概括如下：

![](cpu4.png)

1、取指令：CPU的控制器从内存读取一条指令并放入指令寄存器。

操作码就是汇编语言里的mov，add，jmp等符号码；操作数地址说明该指令需要的操作数所在的地方，是在内存里还是在CPU的内部寄存器里。

2、指令译码：指令寄存器中的指令经过译码，决定该指令应进行何种操作（就是指令里的操作码）、操作数在哪里（操作数的地址）。

3、 执行指令，分两个阶段“取操作数”和“进行运算”。

4、 修改指令计数器，决定下一条指令的地址。



CPU在运算数据的时候（比如 1+1＝2），会首先从CUP寄存器读取数据（速度最快，因为内置在CPU里面），如果没有，就从三级缓存里读取，如果三级缓存也没有，则会经过系统总线及内存总线，从总存储器中读取（此处的总存储器主要是指主内存）。

首先CPU工作的时候，由控制单元充当大脑，负责协调。让运算单元做运算的时候，会首先从最靠近CPU的寄存器（其实是和CPU一体的）上读取数据，在寄存器上有CPU运行的常用指令，如果寄存器上没有想要的数据，则就从三级缓存的L1级缓存中获取，如果L1取到数据了，会加载到寄存器中，再转输给CPU运算单元。如果L1中没有，则从L2级缓存中读取，同理，如果没有，则从L3中取。如果L3中也没有，这个时候，就比较麻烦了。要从主内存中取。而从主内存中取的时候，会经过系统总线及内存总线。这时因受到总线的限制，速度会大大降低。

### **缓存一致性问题**

在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存
（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是
也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一
块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步
回到主内存时以谁的缓存数据为准呢？
为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，在读写时要根据协议来进行操作。常用的方法是总线加锁或是缓存一致性协议-MESI 

![](cpu5.png)

这里重点说一个什么是缓存一致性协议mesi:
概念：CPU最小存储单元：缓存行
MESI代表的四种状态：
M：修改
E：独享。互斥
S：共享
I：无效
MESI缓存一致性协议原理：
假如现在有CPU1和CPU2，主内存有变量X＝ 1 。现在要做 x+1的操作。
如果在变量 x = 1 上加上volatile，则就会触发MESI
当CPU1从主内存中读取到X＝1时，CPU1会把此变量标记成独享状态
并监听总线，是否有其它CPU去读取此变量
当CPU2从主内存中读取X＝1变量时，CPU1会通过嗅探机制监听到。
此时CPU1的X变量会变成共享状态。继续进行计算，计算完变成X＝2。
此时要回写到主内存之前。先锁住缓存行。并标记X变量为修改状态。并向总线发消息。
其它CPU2监听总线时，会监听到，并把X标记成无效状态。
CPU1把变量X＝2回写到主内存后，会由修改状态变成独享状态。
此时，如果CPU2如果想修改X变量时，要重启从主内存中读取。然后开始新的轮回。

### **指令重排序问题**

为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执 行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该 结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的 顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不 能靠代码的先后顺序来保证。
与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有 类似的指令重排序（Instruction Reorder）优化

# JMM内存模型

java线程内存模型跟cpu缓存模型类似，是基于cpu缓存模型来建立的，java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别。