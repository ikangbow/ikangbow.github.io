---
title: 消息队列5个应用场景
date: 2020-06-08 15:49:23
tags: java
category: java
---
消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削峰等问题，实现高性能、高可用、可伸缩和最终一致性架构，使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ。

## 消息队列应用场景

### 异步处理

场景说明：用户注册后，需要发送注册邮件和注册短信，传统的做法有两种，串行的方式和并行的方式。

串行方式：将注册信息写入数据库成功后，发送注册邮件，在发送注册短信，以上三个任务全部完成后，返回给用户。

![](批注 2020-06-08 160339.png)

并行的方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信，以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。

![](批注 2020-06-08 160514.png)

假设三个业务节点每个使用50毫秒，不考虑网络等其他开销，则串行方式时间是150毫秒，并行的时间是100毫秒。

因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内的吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求是10（1000/100）次。

如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈，如何解决呢？

引入消息队列，将不是必须的业务逻辑，异步处理，改造后如下

![](批注 2020-06-08 160530.png)

按照以上约定，用户的响应时间想当与是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能就是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了2倍。

### 应用解耦

场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：

![](批注 2020-06-08 161344.png)

缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统存在耦合

解决：引入应用消息队列

![](批注 2020-06-08 161632.png)

订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。

库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。

假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。

### 流量削峰

流量削峰也是消息队列中常用的场景，一般在秒杀或团抢活动中使用广泛。

应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端假如消息队列。

可以控制活动的人数，可以缓解短时间内高流量压垮应用。

![](批注 2020-06-08 162324.png)

用户的请求，服务器接收到后先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误的页面。

秒杀业务根据消息队列中的请求信息，再做后续处理。

### 日志处理

日志处理是指将消息ui列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：

![](批注 2020-06-08 162722.png)

日志采集客户端，负责日志数据采集，定时写入Kafka队列；Kafak消息队列，负责日志数据的接收，存储和转发；日志处理应用：订阅并消费kafaka队列中的日志数据。

以下是新浪kafka日志处理应用案例：

![](批注 2020-06-08 163012.png)

 Kafka:接收用户日志的消息队列；

 Logstach:做日志解析，统一成JSON传输给Elasticsearch;

 Elasticsearch:实时日志分析服务的核心技术，一个schemaless,实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。

 Kibaba:基于Elasticsearch的数据可视化组件，超强的数据可视化能力

### 消息通讯

消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。

![](批注 2020-06-08 163623.png)

客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。

## 实战用redis实现简单的发布/订阅

场景：两台tomcat做集群，配置文件不同时生效的问题

    <bean id="messageContainer"
		class="org.springframework.data.redis.listener.RedisMessageListenerContainer"
		destroy-method="destroy">
		<property name="connectionFactory" ref="jedisConnectionFactory" />
		<property name="messageListeners">
			<map>
				<entry key-ref="subService">
					<ref bean="channelTopic" />
				</entry>
			</map>
		</property>
	</bean>
	<bean id="channelTopic" class="org.springframework.data.redis.listener.ChannelTopic">
		<constructor-arg value="server:topic" />
	</bean>

    @Service
	public class PubServiceImpl implements PubService {
	
		private static final Logger logger = Logger.getLogger(PubService.class);
	
		@Autowired
		private RedisTemplate<String, String> redisTemplate;
	
		private String channelTopic = "server:topic";
	
		public void publish(String str) {
			//String str = JsonUtils.toJson(message);
			logger.error("Publish message:" + str + ", topic:" + channelTopic);
			redisTemplate.convertAndSend(channelTopic, str);
		}
	
		public void publish(Map<String, Object> message) {
			String str = JsonUtils.toJson(message);
			logger.error("Publish message:" + str + ", topic:" + channelTopic);
			redisTemplate.convertAndSend(channelTopic, str);
		}
	}

	@Service("subService")
	public class SubServiceImpl implements MessageListener {
	
		private static final Logger logger = Logger.getLogger(SubServiceImpl.class);
	
		@Autowired
		private ChannelTopic channelTopic;
		
		@Override
		public void onMessage(Message message, byte[] pattern) {
			String str = message.toString();
			logger.error("Subscribe message:" + str + ", topic:" + channelTopic.getTopic());
			try {
				String type =  m.getType();
				if ("config".equals(type)) {
					System.out.println("接收到消息，doSomething========");
				}else if("me".equals(type)){
					System.out.println("接收到消息，doSomething========");
				}else{
					System.out.println("接收到消息，doSomething========");
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}




