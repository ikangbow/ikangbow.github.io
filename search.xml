<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《围城》-钱钟书]]></title>
    <url>%2F2019%2F12%2F07%2F%E5%9B%B4%E5%9F%8E-%E9%92%B1%E9%92%9F%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[#零围在城里的人想逃出来，城外的人想冲进去，对婚姻也罢，职业也罢，人生的愿望大都如此。 壹天生人是教他们孤独的，一个个该各归各，老死不相往来。身体里容不下的东西，或消化，或排泄，是个人的事；为什么心里容不下的情感，要找同伴来分摊？聚在一起，动不动自己冒犯人，或者人开罪自己，好像一只刺猬，只好保持着彼此间的距离，要亲密团结，不是你刺痛我的肉，就是我擦破你的皮。（引自第199页） #贰我们一天要想到不知多少人，亲戚、朋友、仇人，以及不相干的见过面的人。真正像一个人，记挂着他，希望跟他接近，这少得很。人事太忙了，不许我们全神贯注，无间断地怀念一个人。我们一生对于最亲爱的人的想念，加起来恐怕不到一点钟，此外不过是念头在他身上瞥过，想到而已。（引自第161页） #叁写信的时候总觉得这是慰情聊胜于无，比不上见面，到见了面，许多话倒将不出来，想还不如写信。见面有瘾的；最初，约着见一面就能使见面的前后几天都沾着光，变成好日子渐渐地恨不能天天见面了；到后来，恨不能刻刻见面了。写好信发出，他总担心这信像支火箭，到落地市，火已熄了，对方收到的只是一段枯炭。（引自第79页） #肆像咱们这种旅行，最实验得出一个人的品性。旅行市最劳顿，最麻烦，叫人本相毕现的时候。经过长期苦旅行而彼此不讨厌的人，才可以结交作朋友–且慢，你听我说–结婚以后的蜜月旅行是次序颠倒的，应该先同旅行一个月，一个月舟车仆仆以后，双方还没有彼此看破，彼此厌恶，还没有吵嘴翻脸，还要维持原来的婚约，这种夫妇保证不会离婚（引自第188页） #伍年龄是个自然历程里不能超越的事实，就像饮食男女，像死亡。有时，这种年辈意识比阶级意识更鲜明。随你政见、学说或趣味如何相同，年辈的老少总替你隐隐分了界限，仿佛瓷器上的裂纹，平时一点没有什么，一旦受着震动，这条裂纹先扩大成裂缝。（引自第248页） #陆忠厚老实人的恶毒，像饭菜里的沙砾或者出骨鱼片里未净的刺，会给人一种不期待的伤。（引自第5页） #柒心里仿佛黑牢里的禁锢者摸索着一根火柴，刚划亮，火柴就熄了，眼前没看清的一片又滑回黑暗里。譬如黑夜里两条船相迎擦过，一个在这条船上，瞥见对面船舱的灯光正式自己梦寐不忘的脸，没来得及叫唤，彼此早距离远了。这一刹那的接近，反见得睽隔的渺茫。 #捌在旅行的时候，人生的地平线移近；坐汽车只几个钟点，而乘客仿佛下半世全在车里消磨的，只要坐定了，身心像得到归宿，一劳永逸地看书、看报、抽烟、吃东西、瞌睡，路程以外的事暂时等于身后身外的事。 #玖对于丑人，细看是一种残忍–除非他是坏人，你要惩罚他。 #拾天下只有两种人，譬如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留在最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。只不过事实上适得其反，缘故是第二种人还有希望，第一种人只有回忆。从恋爱到白头偕老，好比一串葡萄，总有最好的一颗，最好的只有一颗，留着希望，多么好？你希望的好葡萄在后面呢，我们是坏葡萄，别倒了你的胃口。（引自第一页） ##十一一个人的缺点正像猴子的尾巴，猴子蹲在地面的时候，尾巴是看不见的，直到他向树上爬，就把后部供大众瞻仰，可是这红臀长尾巴本来就有，并非地位爬高了的新标识。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成小程序]]></title>
    <url>%2F2019%2F05%2F18%2F%E9%9B%86%E6%88%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[web.xml&lt;servlet&gt; &lt;servlet-name&gt;WeixinMiniServiceServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/weixinmini-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;WeixinMiniServiceServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/wm/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; src/main/resources增加weixinmimi-context.xml配置，添加对modulewxmini包的扫描 &lt;context:component-scan base-package=&quot;com.material.modulewxmini&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot; /&gt; &lt;/context:component-scan&gt; 添加过滤器WeixinMiniInterceptor weixin包里增加WxMiniVoucherService及WxMinigetInfo WeMiniVoucher类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>系统集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[项目拷贝1.项目右键 –&gt; properties –&gt; Web Project Settings –&gt; 修改Context root 2.pom.xml 3.工作空间中找到当前项目下.project文件 4.工作空间中找到当前项目，打开.settings文件夹，找到org.eclipse.wst.common.component文件 5..component hexo 记录1.hexo new ‘页面名称’ 2.hexo clean 清除 3.hexo g 4.hexo d]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongo]]></title>
    <url>%2F2019%2F04%2F06%2Fmongo%2F</url>
    <content type="text"><![CDATA[什么是MongoDB ?MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 主要特点 MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。 Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 MongoDB安装简单。安装 下载mongodb-linux-x86_64-3.6.3.tar.gz 解压tar -zxvf mongodb-linux-x86_64-3.0.6.tgz 在与bin同级的目录下建立data文件夹 mongo.config文件内容 port=27017 logpath=/airthink/mongodb-linux-x86_64-3.6.3/mongod.log pidfilepath=/airthink/mongodb-linux-x86_64-3.6.3/mongod.pid logappend=true fork=true maxConns=3000 dbpath=/airthink/mongodb-linux-x86_64-3.6.3/data auth=true 启动./mongodb-linux-x86_64-3.6.3/bin/mongo var schema = db.system.version.findOne({_id:&quot;authSchema&quot;});//驱动版本5--SCRAM-SHA-1需要修改成：3--Mongodb-CR schema. currentVersion = 3; db.system.version.save(schema); db.createUser({user:&quot;admin&quot;,pwd:&quot;mypass&quot;,roles:[&quot;readWriteAnyDatabase&quot;, &quot;userAdminAnyDatabase&quot;, &quot;dbAdminAnyDatabase&quot;]}); MongoDB用户角色配置 基本知识介绍MongoDB基本的角色 数据库用户角色：read、readWrite; 数据库管理角色：dbAdmin、dbOwner、userAdmin； 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 备份恢复角色：backup、restore； 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase 超级用户角色：root (这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase,其中MongoDB默认是没有开启用户认证的，也就是说游客也拥有超级管理员的权限。userAdminAnyDatabase：有分配角色和用户的权限，但没有查写的权限) 连接到MongoDB服务器建库操作开始 ./mongodb-linux-x86_64-3.6.3/bin/mongo 进入mongo shell use admin(使用) db.createUser({user:&quot;root&quot;,pwd:&quot;password&quot;,roles:[&quot;root&quot;]})//创建root用户 db.createUser({user:&quot;admin&quot;,pwd:&quot;admin&quot;,roles:[{role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}]})（创建admin用户） db.auth(&apos;admin&apos;, &apos;admin&apos;);（授权） 修改mongod.conf文件 security: authorization: enabled//启用授权 重启MongoDB服务器 service mongod restart 创建数据库读写权限用户 use admin db.auth(&quot;admin&quot;,&quot;password&quot;); use ballmatch db.createUser({ user: &quot;baidu&quot;, pwd: &quot;password&quot;, roles: [{role: &quot;readWrite&quot;,db: &quot;baidu&quot;}] }) Java程序连接MongoDBMongoCredential credential = MongoCredential.createCredential(&quot;username&quot;, &quot;dbName&quot;, &quot;password&quot;.toCharArray()); ServerAddress serverAddress = new ServerAddress(&quot;192.168.10.242&quot;, 27017); MongoClient mongoClient = new MongoClient(serverAddress, Arrays.asList(credential)); DB db = mongoClient.getDB(&quot;dbName&quot;); returndb; //方式二 String sURI = String.format(&quot;mongodb://%s:%s@%s:%d/%s&quot;, &quot;username&quot;, &quot;password&quot;, &quot;192.168.10.242&quot;, 27017, &quot;dbName&quot;); MongoClientURI uri = new MongoClientURI(sURI); MongoClient mongoClient = new MongoClient(uri); DB db = mongoClient.getDB(&quot;dbName&quot;); 命令介绍修改用户密码 db.updateUser( &quot;admin&quot;,{pwd:&quot;password&quot;}); 密码认证 db.auth(&quot;admin&quot;,&quot;password&quot;); MongoDB连接信息查询 db.serverStatus().connections; 关闭MongoDB服务 use admin; db.shutdownServer(); 删除用户 删除用户(需要root权限，会将所有数据库中的football用户删除) db.system.users.remove({user:&quot;baidu&quot;}); 删除用户(权限要求没有那么高，只删除本数据中的football用户) db.dropUser(&quot;baidu&quot;); mongoTemplate使用示例对匹配到的数据进行更新(inc)Query query = new Query(); query.addCriteria(Criteria.where(&quot;accountName&quot;).is(username)); if (null != password){ query.addCriteria(Criteria.where(&quot;accountPwd&quot;).is(password)); } Account account = this.mongoTemplate.findOne(query, Account.class); if (account != null) { Update update = new Update(); update.inc(&quot;loginTimes&quot;, 1); this.mongoTemplate.updateFirst(query, update, Account.class);//查找并更新 } mongoTemplate.updateFirst(Query.query(Criteria.where(&quot;_id&quot;).is(favor.getTypeId())),new Update().inc(&quot;favorTimes&quot;, 1), News.class); mongoTemplate.updateFirst(Query.query(Criteria.where(&quot;_id&quot;).is(favor.getTypeId())),new Update().inc(&quot;favorTimes&quot;, -1), News.class); 查询一条记录和保存（findOne/save）Account account = mongoTemplate.findOne(Query.query(Criteria.where(&quot;accountName&quot;).is(accountName)),Account.class); account.setAccountPwd(passwd); mongoTemplate.save(account); 多条件匹配（并的关系）Criteria criteria = new Criteria(); criteria.andOperator(Criteria.where(&quot;phone&quot;).is(phone), Criteria.where(&quot;status&quot;).is(0)); List&lt;VerifyCode&gt; codes = mongoTemplate.find(Query.query(criteria), VerifyCode.class); Criteria criteria = new Criteria(); criteria.andOperator(Criteria.where(&quot;entityID&quot;).is(entityID), Criteria.where(&quot;accountType&quot;).is(accountType), Criteria.where(&quot;weUnionId&quot;).ne(&quot;&quot;).ne(null)); Account Account = mongoTemplate.findOne(Query.query(criteria), Account.class); Boolean isFavor = mongoTemplate.exists(Query.query(Criteria.where(&quot;typeId&quot;).is(favor.getTypeId()).and(&quot;type&quot;).is(favor.getType()).and(&quot;userId&quot;).is(favor.getUserId())), Favor.class); 多条件匹配（或的关系）Criteria criteria = new Criteria(); criteria.orOperator(Criteria.where(&quot;status&quot;).is(1), Criteria.where(&quot;status&quot;).is(0)); List&lt;VerifyCode&gt; codes = mongoTemplate.find(Query.query(criteria), VerifyCode.class); 根据id查找并删除Account account = mongoTemplate.findById(id, Account.class); mongoTemplate.remove(account); 计数long count = mongoTemplate.count(Query.query(Criteria.where(&quot;accountName&quot;).is(accountName)), Account.class); 模糊匹配并排序Criteria criteria = new Criteria(); criteria.andOperator(Criteria.where(&quot;province&quot;).regex(province));//正则 mongoTemplate.find(Query.query(criteria).with(new Sort(Direction.ASC, &quot;order&quot;)), Bbatch.class); distinct查询 DBObject dbObject = new BasicDBObject(&quot;schoolId&quot;, bschool.get_id()); List&lt;String&gt; provinces = mongoTemplate.getCollection( mongoTemplate.getCollectionName(BschoolScoreline.class)) .distinct(&quot;province&quot;, dbObject); bschool.setProvinces(provinces); 查找并所有排序mongoTemplate.find(new Query().with(new Sort(&quot;order&quot;, &quot;DESC&quot;)), Bschool.class); in查询List&lt;MpropValue&gt; mpropValueList = mongoTemplate.find(Query.query(Criteria.where(&quot;propId&quot;).in(mprop1.get_id())), MpropValue.class); 设置唯一字段//used 是1 将其他所有是1的更新为0 if(address.getUsed()==1){ Query q = new Query(Criteria.where(&quot;userId&quot;).is(user.get_id()));//查询 Update u = new Update().set(&quot;used&quot;,0); BulkOperations ops = mongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED, &quot;address&quot;); ops.updateMulti(q,u);//全部更新 ops.execute(); } 插入多条数据public ReturnStatus upsert(List&lt;BspecialLink&gt; specialLinks) { ReturnStatus status; mongoTemplate.insertAll(specialLinks); status = new ReturnStatus(true); return status; } 获取数据库所有集合名称Set&lt;String&gt; sets = mongoTemplage.getDb().getCollectionNames(); 其他 删除字段 db.yourcollection.update({},{$unset:{&quot;需要删除的字段&quot;:&quot;&quot;}},false,true) 将匹配到的值全部更新 db.getCollection(&quot;bschool&quot;).update({&quot;state&quot;:0},{$set:{&quot;state&quot;:&quot;1&quot;}},{&apos;multi&apos;:true}) 建立索引 db.bschoolScorelineDetail.ensureIndex({&quot;schoolId&quot;:1,&quot;type&quot;:1,&quot;batch&quot;:1,&quot;province&quot;:1},{&quot;name&quot;：&quot;schoolScorelineDetail&quot;}) mongo中建立索引用ensureIndex({“字段1”:1,”字段2”:”-1”},{“name”:”索引名”}) 1和-1代表正序和倒序 mongo数据库备份操作(在mongo的安装目录的bin下执行如下命令) 不带验证的数据库备份： mongodump -d mrmf -o /tools/test mrmf数据库名 /tools/test要备份到的地方 不带验证的数据库恢复 mongorestore --db mrmf /tools/test/mrmf mrmf数据库名 /tools/test要恢复的数据 带验证的数据库备份： mongodump -d mrmf -u admin -p &quot;ie8*kskIkd123&quot; --authenticationDatabase=admin -o /tools/test 带验证的数据库恢复： mongorestore --db mrmf -u admin -p &quot;ie8*kskIkd123&quot; --authenticationDatabase=admin /tools/test/red 开启慢日志 在客户端调用db.setProfilingLevel(级别) 命令来实时配置。可以通过db.getProfilingLevel()命令来获取当前的Profile级别。 &gt; db.setProfilingLevel(2); &gt; {&quot;was&quot; : 0 , &quot;ok&quot; : 1} &gt; db.getProfilingLevel() 上面斜体的级别可以取0，1，2 三个值，他们表示的意义如下： 0 – 不开启 1 – 记录慢命令 (默认为&gt;100ms) 2 – 记录所有命令 Profile 记录在级别1时会记录慢命令，那么这个慢的定义是什么?上面我们说到其默认为100ms，当然有默认就有设置，其设置方法和级别一样有两种，一种是通过添加–slowms启动参数配置。第二种是调用db.setProfilingLevel时加上第二个参数： db.setProfilingLevel( level , slowms ) db.setProfilingLevel( 1 , 10 ); Mongo Profile 记录是直接存在系统db里的，记录位置 system.profile ，所以，我们只要查询这个Collection的记录就可以获取到我们的 Profile 记录了。 Profile 信息内容详解： ts-该命令在何时执行. millis Time-该命令执行耗时，以毫秒记. info-本命令的详细信息. query-表明这是一个query查询操作. ntoreturn-本次查询客户端要求返回的记录数.比如, findOne()命令执行时 ntoreturn 为 1.有limit(n) 条件时ntoreturn为n. query-具体的查询条件(如x&gt;3). nscanned-本次查询扫描的记录数. reslen-返回结果集的大小. nreturned-本次查询实际返回的结果集. update-表明这是一个update更新操作. upsert-表明update的upsert参数为true.此参数的功能是如果update的记录不存在，则用update的条件insert一条记录. moved-表明本次update是否移动了硬盘上的数据，如果新记录比原记录短，通常不会移动当前记录，如果新记录比原记录长，那么可能会移动记录到其它位置，这时候会导致相关索引的更新.磁盘操作更多，加上索引更新，会使得这样的操作比较慢. insert-这是一个insert插入操作. getmore-这是一个getmore 操作，getmore通常发生在结果集比较大的查询时，第一个query返回了部分结果，后续的结果是通过getmore来获取的。 #下面是一个超过200ms的查询语句 { &quot;op&quot; : &quot;query&quot;, #操作类型，有insert、query、update、remove、getmore、command &quot;ns&quot; : &quot;F10data3.f10_2_8_3_jgcc&quot;, &quot;query&quot; : { #具体的查询语句 包括过滤条件，limit行数 排序字段 filter&quot; : { &quot;jzrq&quot; : { &quot;$gte&quot; : ISODate(&quot;2017-03-31T16:00:00.000+0000&quot;), &quot;$lte&quot; : ISODate(&quot;2017-06-30T15:59:59.000+0000&quot;) }, &quot;jglxfldm&quot; : 10.0 }, &quot;ntoreturn&quot; : 200.0, &quot;sort&quot; : { #如果有排序 则显示排序的字段 这里是 RsId &quot;RsId&quot; : 1.0 } }, &quot;keysExamined&quot; : 0.0, #索引扫描数量 这里是全表扫描，没有用索引 所以是 0 &quot;docsExamined&quot; : 69608.0, #浏览的文档数 这里是全表扫描 所以是整个collection中的全部文档数 &quot;numYield&quot; : 546.0, #该操作为了使其他操作完成而放弃的次数。通常来说，当他们需要访问 还没有完全读入内存中的数据时，操作将放弃。这使得在MongoDB为了 放弃操作进行数据读取的同时，还有数据在内存中的其他操作可以完成。 &quot;locks&quot; : { #锁信息，R：全局读锁；W：全局写锁；r：特定数据库的读锁；w：特定数据库的写锁 &quot;Global&quot; : { &quot;acquireCount&quot; : { &quot;r&quot; : NumberLong(1094) #该操作获取一个全局级锁花费的时间。 } }, &quot;Database&quot; : { &quot;acquireCount&quot; : { &quot;r&quot; : NumberLong(547) } }, &quot;Collection&quot; : { &quot;acquireCount&quot; : { &quot;r&quot; : NumberLong(547) } } }, &quot;nreturned&quot; : 200.0, #返回的文档数量 &quot;responseLength&quot; : 57695.0, #返回字节长度，如果这个数字很大，考虑值返回所需字段 &quot;millis&quot; : 264.0, #消耗的时间（毫秒） &quot;planSummary&quot; : &quot;COLLSCAN, COLLSCAN&quot;, #执行概览 从这里看来 是全表扫描 &quot;execStats&quot; : { #详细的执行计划 这里先略过 后续可以用 explain来具体分析 }, &quot;ts&quot; : ISODate(&quot;2017-08-24T02:32:49.768+0000&quot;), #命令执行的时间 &quot;client&quot; : &quot;10.3.131.96&quot;, #访问的ip或者主机 &quot;allUsers&quot; : [ ], &quot;user&quot; : &quot;&quot; } MongoDB 查询优化 如果发现 millis 值比较大，那么就需要作优化。 如果docsExamined数很大，或者接近记录总数（文档数），那么可能没有用到索引查询，而是全表扫描。 如果keysExamined数为0，也可能是没用索引。 结合 planSummary 中的显示，上例中是 “COLLSCAN, COLLSCAN” 确认是全表扫描 如果 keysExamined 值高于 nreturned 的值，说明数据库为了找到目标文档扫描了很多文档。这时可以考虑创建索引来提高效率。 索引的键值选择可以根据 query 中的输出参考，上例中 filter:包含了 jzrq和jglxfldm 并且按照RsId排序，所以 我们的索引索引可以这么建: db.f10_2_8_3_jgcc.ensureindex({jzrq:1,jglxfldm:1,RsId:1}) 聚合操作示例一 Criteria criteria = new Criteria(); criteria.andOperator(Criteria.where(&quot;userId&quot;).is(uid), Criteria.where(&quot;type&quot;).is(2));//查询条件 Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(criteria),Aggregation.group(&quot;content&quot;).count().as(&quot;count&quot;),Aggregation.sort(Sort.Direction.ASC,&quot;count&quot;)); AggregationResults&lt;SearchKeyWords&gt; ar = mongoTemplate.aggregate(aggregation, Searched.class, SearchKeyWords.class);//Searched为要查询的类，SearchKeyWords为查询结果的vo对象 List&lt;SearchKeyWords&gt; list = ar.getMappedResults(); public class SearchKeyWords { public String _id;//_id: &quot;中华&quot; 重复的字段 public int count;//count: 57 重复次数 public int getCount() { return count; } public void setCount(int count) { this.count = count; } } 示例二 //分组group、排序sort统计每个分类下商品个数 Criteria criteria = new Criteria(); Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(criteria), Aggregation.group(&quot;categoryId&quot;).count().as(&quot;count&quot;),Aggregation.sort(Sort.Direction.ASC,&quot;count&quot;)); AggregationResults&lt;BasicDBObject&gt; ar = mongoTemplate.aggregate(aggregation, Goods.class, BasicDBObject.class); for (BasicDBObject basicDBObject : ar) { logger.info(JsonUtils.toJson(basicDBObject)); } //输出结果 2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] {&quot;_id&quot;:&quot;6430379335205566832&quot;,&quot;count&quot;:1}//分类id和当前分类下商品个数 2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] {&quot;_id&quot;:&quot;8732390723817262538&quot;,&quot;count&quot;:2} 2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] {&quot;_id&quot;:&quot;4479460853249390323&quot;,&quot;count&quot;:2} 2019-05-06 11:13:11 [com.badou.service.basic.goods.GoodsService]-[INFO] {&quot;_id&quot;:&quot;6571438787886532072&quot;,&quot;count&quot;:16} 示例三 //两个集合关联查询 Aggregation.lookup //若 A集合关联B集合 //参数： from B集合名 //localField A集合存外键的字段 //foreignField B集合与A集合关联的字段 //as 重新组合成C集合名称 语法 db.collection.aggregate([{ $lookup: { from: &lt;collection to join&gt;, localField: &lt;field from the input documents&gt;, foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;, as: &lt;output array field&gt; } }]) Criteria criteria = new Criteria(); criteria.andOperator(Criteria.where(&quot;_id&quot;).is(&quot;6118446118773213048&quot;)); Aggregation aggregation = Aggregation.newAggregation( Aggregation.match(criteria), Aggregation.lookup(&quot;goodsCategory&quot;, &quot;categoryId&quot;, &quot;_id&quot;, &quot;goodsCategory&quot;), Aggregation.unwind(&quot;goodsCategory&quot;), Aggregation.project(&quot;title&quot;,&quot;price&quot;).and(&quot;goodsCategory.name&quot;).as(&quot;categoryName&quot;).and(&quot;goodsCategory.order&quot;).as(&quot;categoryOrder&quot;) ); AggregationResults&lt;BasicDBObject&gt; ar = mongoTemplate.aggregate( aggregation, Goods.class, BasicDBObject.class); for (BasicDBObject basicDBObject : ar) { logger.info(JsonUtils.toJson(basicDBObject)); } //输出结果 2019-05-06 21:17:26 [com.badou.service.basic.goods.GoodsService]-[INFO] {&quot;_id&quot;:&quot;6118446118773213048&quot;,&quot;title&quot;:&quot;小学生必备国学常识&amp;小学生必读国学经典&quot;,&quot;price&quot;:&quot;10.0&quot;,&quot;categoryName&quot;:&quot;小学生&quot;,&quot;categoryOrder&quot;:&quot;1&quot;} 示例四(未曾验证) //全文搜索查询 //设置索引：db.logInfo.ensureIndex(msg:&quot;text&quot;) Query query = TextQuery.query(new TextCriteria().matching(&quot;coffee&quot;).matching(&quot;-cake&quot;)); //-cake表示不匹配不包含cake与notMatching类似 //Query query = TextQuery.searching((new TextCriteria().matching(&quot;coffee&quot;).notMatching(&quot;-cake&quot;)) List&lt;LogInfoCol&gt; lfs = mongoTemplate.find(query,LogInfoCol.class); if(lfs!=null){ for(LogInfoCol logInfoCol:lfs){ logger.info(JSON.toString(logInfoCol)); } } 示例五(未曾验证) //得到范围内数据：以Circle构造函数，第一第二个参数为坐标，第三个参数为距离半径查找符合条件的 Circle circle = new Circle(4.2341111,63.00001,0.01); List&lt;PositionCol&gt; positionCols = mongoTemplate.find(new Query(Criteria.where(&quot;location&quot;).within(circle)),PositionCol.class); if(positionCols!=null){ for(PositionCol positionCol:positionCols){ logger.info(JSON.toJSONString(positionCol)) } } 示例六(未曾验证) //查找坐标周围10KM内的所有商店 Point location = new Point(116.425253,39.925338); NearQuery query = NearQuery.near(location).maxDistance(new Distance(10,Metrice.KILOMETERS)); GeoResults&lt;PositionCol&gt; positions = mongoTemplate.geoNear(query,PositionCol.class); if(positionCols!=null){ for(GeoResults&lt;PositionCol&gt;geoResult :positions){ logger.info(geoResult.getContent().getBuissName()+&quot;-&quot;+geoResult.getDistance().getValue()); } }]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS]]></title>
    <url>%2F2019%2F03%2F03%2FJS%2F</url>
    <content type="text"><![CDATA[js委托事件概述什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。举个栗子：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 为什么要用事件委托一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 事件委托原理事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 实现给指定li 加上class属性 class=”liShow” $(&quot;.test&quot;).on(&quot;click&quot;,&quot;.liShow&quot;,function() { //获取到当前点击事件的属性id var thisId = $(this).attr(&apos;data-id&apos;); //执行事件 })]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云web应用部署]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%98%BF%E9%87%8C%E4%BA%91web%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[阿里云服务器 阿里云服务器的注册及申请 添加安全组规则。安全组在云端提供类似虚拟防火墙功能，用于设置单个或多个 ECS 实例的网络访问控制，它是重要的安全隔离手段。在创建 ECS 实例时，必须选择一个安全组。您还可以添加安全组规则，对该安全组下的所有 ECS 实例的出方向和入方向进行网络控制。 若没有配置安全组规则，直接在本地ping服务器，结果ping不通，ssh也连不上。 默认安全组中的默认规则仅设置针对ICMP协议、SSH 22端口、RDP 3389端口、HTTP 80端口和HTTPS 443端口的入方向规则。网络类型不同，安全且规则不同。 安全组常用配置 例如：redis端口6379/mongo数据库端口27017/mysql端口3306/ 服务器环境部署 使用shell工具上传 JDK；安装svn，安装maven；新建项目文件夹上传tomcat、mongo、redis安装包。 配置环境变量 java环境变量 JAVA_HOME=/usr/local/jdk1.8.0_162 export JRE_HOME=/usr/local/jdk1.8.0_162/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH:$MAVEN_HOME/bin export MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4 redis配置 找到redis.conf文件将bind 127.0.0.1注释，改为bind 0.0.0.0这样就可以支持远程连接 找到requirepass 设置redis登录密码 mongo配置 找到mongo.conf配置auth先设置false port=27017 logpath=/airthink/mongodb-linux-x86_64-3.6.3/mongod.log pidfilepath=/airthink/mongodb-linux-x86_64-3.6.3/mongod.pid logappend=true fork=true maxConns=3000 dbpath=/airthink/mongodb-linux-x86_64-3.6.3/data auth=false ./mongodb-linux-x86_64-3.6.3/bin/mongo 进入mongo shell 创建超级管理员admin账户 use admin db.createUser( { user: &quot;admin&quot;, pwd: &quot;123456&quot;, roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ] } ) 现在启用auth 将配置文件中auth=false 改为 auth=true use admin db.auth(&apos;admin&apos;,&apos;123456&apos;);授权 创建数据库 db.createUser({user:&quot;用户名&quot;,pwd:&quot;密码&quot;,roles:[{role:&quot;readWrite&quot;,db:&quot;项目名&quot;}]}) 部署web项目在项目文件夹下使用svn命令svn checkout svn://路径(目录或文件的全路径) 首次checkout出项目后，运行自动发布脚本，删除开发配置文件，替换生产配置文件，使用mvn打包，将war包复制到tomcat的webapp下，重启tomcat。 问题Linux执行.sh文件，提示No such file or directory的问题的解决方法： 原因：在windows中写好shell脚本测试正常，但是上传到 Linux 上以脚本方式运行命令时提示No such file or directory错误，那么一般是文件格式是dos格式的缘故，改成unix 格式即可。一般有如下几种修改办法。 用vim打开该sh文件，输入：:set ff回车，显示fileformat=dos，重新设置下文件格式：:set ff=unix保存退出::wq再执行 免费ssh证书申请及配置参考https://help.aliyun.com/knowledge_detail/95496.html?spm=a2c4g.11186623.2.11.53674c07M5nwXN]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常及使用]]></title>
    <url>%2F2019%2F02%2F02%2FJava%E5%BC%82%E5%B8%B8%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java异常Java异常类层次结构图java 异常是程序运行过程中出现的错误。Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中定义了许多异常类,分为两大类，错误Error和异常Exception。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常(非runtimeException)，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。 Error与ExceptionError是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。 运行时异常和非运行时异常1.运行时异常: 都是RuntimeException类及其子类异常： IndexOutOfBoundsException：索引越界异常 ArithmeticException：数学计算异常 NullPointerException：空指针异常 ArrayOutOfBoundsException：数组索引越界异常 ClassNotFoundException：类文件未找到异常 ClassCastException：造型异常（类型转换异常） 这些异常是不检查异常（Unchecked Exception），程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的。 2.非运行时异常:是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如： IOException：文件读写异常 FileNotFoundException：文件未找到异常 EOFException：读写文件尾异常 MalformedURLException：URL格式错误异常 SocketException：Socket异常 SQLException：SQL数据库异常 异常的捕获和处理Java异常的捕获和处理是一个不容易把握的事情，如果处理不当，不但会让程序代码的可读性大大降低， 而且导致系统性能低下，甚至引发一些难以发现的错误。 1.try、catch方式： try{ //（尝试运行的）程序代码 }catch(异常类型 异常的变量名){ //异常处理代码 }finally{ //异常发生，方法返回之前，总是要执行的代码 } try、catch、finally三个语句块应注意的问题第一、try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、 try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。第二、try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。第三、多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。 2.抛异常给上一级方式： public static void demo() throws Exception{ //抛出一个检查异常 throw new Exception(&quot;方法demo中的Exception&quot;); } 上面的代码可以看到两个关键字，throw和throws关键字throw：是用于方法体内部，用来抛出一个Throwable类型的异常。throws：是用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出。异常处理是为了程序的健壮性。异常能处理就处理，不能处理就抛出，最终没有处理的异常JVM会进行处理。对于一个应用系统来说，应该有自己的一套异常处理框架，这样当异常发生时，也能得到统一的处理风格，将优雅的异常信息反馈给用户。 Java异常使用在开发业务系统中，目前绝大多数采用MVC模式。考虑如下场景：系统提供一个API，用于修改用户信息，服务器端采用json数据交互.首先我们定义BaseException，用来表示业务逻辑受理失败，它仅表示我们处理业务的时候发现无法继续执行下去。 /** * 业务受理失败异常 */ public class BaseException extends RuntimeException{ public ServiceException() { super(); } public BaseException(String arg0, Throwable arg1) { super(arg0, arg1); } public BaseException(String arg0) { super(arg0); } public BaseException(Throwable arg0) { super(arg0); } } 接下来Controller层 @RequestMapping pulic ReturnStatus updateUser(User user){ userService.updateUser(user); ReturnStatus status = new ReturnStatus(ture,&quot;更新成功&quot;); status.setEntity(user) return status; } 关于上述Controller写法乍一看会有一些冗余，如果无法理解，请仔细研读MVC设计模式. 先不管service，我们来考虑下。 一个业务系统不可能不对用户提交的数据进行验证，验证包括两方面：有效性和合法性 有效性: 比如用户所在岗位,是否属于数据库有记录的岗位ID,如果不存在,无效. 合法性: 比如用户名只允许输入最多12个字符,用户提交了20个字符,不合法. 有效性检查，可以交给java的校验框架执行，比如JSR303。假设用户提交的数据经过验证都合法，还是有一些情况是不能调用修改逻辑的。 要修改的用户ID不存在. 用户被锁定,不允许修改. 乐观锁机制发现用户已经被被人修改过. 由于某种原因,我们的程序无法保存到数据库. 一些程序员错误的开发了代码,导致保存过程中出现异常,比如NPE. 对于前3种，我们认为是有效性检查失败，第4种属与我们无法处理的异常，第5种就是程序员bug。 现在的问题是，前三种情况我们如何通知用户呢? 1.在ccontroller 调用userService的checkUserExist()方法.2.在controller直接书写业务逻辑.3.在service响应一个状态码机制,比如1 2 3表示错误信息,0 表示没有任何错误. 显然前2种方法都不可取，因为MVC设计模式告诉我们,controller是用来接收页面参数，并且调用逻辑处理，最后组织页面响应的地方。我们不可以在controller进行逻辑处理，controller只应该负责用户API入口和响应的处理(如若不然,思考一下如果有一天service的代码打包成jar放到另一个平台，没有controller了,该怎么办？) 状态码机制是个不错的选择，可是如此一来，用户保存逻辑变了，比如增加一个情况，不允许修改已经离职的用户，那么我们还需要修改controller的代码，代码量增加，维护成本增高，并且还耦合了service，不符合MVC设计模式。 那么怎么办呢？现在我们来看下service代码如何编写 public void updateUser(User user){ User userOrig = userDao.getUserById(user.getUserById); if(null == userOrig){ throw new BaseException(&quot;用户不存在&quot;); } if(userOrig.isLocked()){ throw new BaseException(&quot;用户被锁定,不允许修改&quot;); } if(!user.getVersion.equals(userOrig.getVersion)){ throw new BaseException(&quot;用户已经被别人修改,请刷新&quot;); } //TODO保存用户数据... } 这样一来只要我们检查到不允许保存的项目，我们就可以直接throw 一个新的异常，异常机制会帮助我们中断代码执行。 接下来有2种选择: 在controller 使用try-catch进行处理. 直接把异常抛给上层框架统一处 第1种方式是不可取的，注意我们抛出的BaseException，它仅仅逻辑处理异常,并且我们的方法前面没有声明throws BaseException，这表示他是一个非受查异常.controller也没有关心会发生什么异常。 为什么不定义成受查异常呢？如果是一个受查异常，那么意味着controller必须要处理你的异常。并且如果有一天你的业务逻辑变了，可能多一种检查项，就需要增加一个异常，反之需要删除一个异常，那么你的方法签名也需要改变，controller也随之要改变,这又变成了紧耦合，这和用状态码123表示处理结果没有什么不同。 我们可以为每一种检查项定义一个异常吗？可以，但是那样显得太多余了。因为业务逻辑处理失败的时候，根据我们需求，我们只需要通知用户失败的原因(通常应该是一段字符串)，以及服务器受理失败的一个状态码(有时可能不需要状态码,这要看你的设计了)，这样这需要一个包含原因属性的异常即可满足我们需求。 最后我们决定这个异常继承自RuntimeException。并且包含一个接受一个错误原因的构造器，这样controller层也不需要知道异常，只要全局捕获到BaseException做统一的处理即可，这无论是在struct1,2时代，还是springMVC中，甚至servlet年代，都是极为容易的！ 异常不提供无参构造器，因为绝对不允许你抛出一个逻辑处理异常，但是不指明原因，想想看，你是必须要告诉用户为什么受理失败的！ 如此一来，我们只需要全局统一处理下 BaseException 就可以了，很好，spring为我们提供了ControllerAdvice机制，有关ControllerAdvice，可以查阅springMVC使用文档，下面是一个简单的示例： @ControllerAdvice(basePackages = {&quot;com.xxx.xxx.bussiness.xxx&quot;}) public class ModuleControllerAdvice{ public static final Logger LOGGER = LoggerFactory.getLogger(ModuleControllerAdvice.class); public static final Logger BASE_LOGGER = LoggerFactory.getLogger(BaseException.class); /** * 业务受理失败 */ @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(BaseException.class) private ReturnStatus handleServiceException(BaseException exception){ String message = &quot;业务受理失败,原因：&quot;+exception.getLocalizedMessage(); SERVICE_LOGGER.info(message); ReturnStatus status = new ReturnStatus(MErrorCode.e2001.code(), MErrorCode.e2001.message());//自定义枚举异常类 return status; } } 在这个时候，我们就可以很轻松的处理各种情况了. 注意一点，在这个类中，我们定义了2个log对象，分别指向 BaseException.class 和 ModuleControllerAdvice.class。并且处理 BaseException的时候使用了info级别的日志输出，这是很有用的。 首先,BaseException一定要和其他的代码错误分离,不应该混为一谈.其次,BaseException并不一定要记录日志,我们应该提供独立的log对象,方便开关.接下来你可以在修改用户的时候想客户端响应这样的JSON { code : e2001, message : &quot;用户不存在&quot; } 如此一来没有任何地方需要关心异常，或者业务逻辑校验失败的情况。用户也可以得到很友好的错误提示。如果你只需要一句概括，那么直接定义一个简单的异常，用于中断处理，并且与用户保持友好交互即可。如果不可能一句话描述清楚，并且包含附加信息，比如需要在日志或者数据库记录消息ID，此时可能专门针对这种重要/复杂业务创建独立异常。上述两种情况因为web系统，是用户发起请求之后需要等待程序给予响应结果的。 如果是后台作业，或者复杂业务需要追溯性。这种通常用流程判断语句控制，要用异常处理。我们认为这些流程判断一定在一个原子性处理中。并且检查到(不是遇到)的问题(不是异常)需要记录到用户可友好查看的日志。这种情况属于处理反馈，并不叫异常。 综上，笔者通常分为如下几类:逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。代码错误，这类异常用于描述开发的代码错误，例如NPE，ILLARG，都属于程序员制造的BUG。专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。各类异常必须要有单独的日志记录，或者分级，分类可管理。有的时候仅仅想给三方运维看到逻辑异常。 注意 异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。上面这句话出自&lt;java编程思想&gt;，但是我们思考如下几点：业务逻辑检查，也是意外情况UnknownHostException，表示找不到这样的主机，这个异常和NoUserException有什么区别么？换言之，没有这样的主机是异常，没有这样的用户不是异常了么？所以一定要弄明白什么是用异常来控制逻辑，什么是定义程序异常。 异常处理效率很低 书中所示的例子，是在循环中大量使用try-catch进行检查，但是业务系统，用户发起请求的次数与该场景天壤地别。淘宝的11`11是个很好的反例。但是请你的系统上到这个级别再考虑这种问题。系统有千万并发，不可能还去考虑这些中规中矩的按部就班的方式，别忘了MVC本来就浪费很多资源，代码量增加很多。业务系统也存在很多巨量任务处理的情况。但是那些任务都是原子性的，现在MVC中的controller和service可不是原子性的，不然为什么要区分这么多层呢。如果那么在乎效率，考虑下重写Throwable的fillStackTrace方法。你要知道异常的开销大到底大在什么地方，fillStackTrace是一个native方法，会填充异常类内部的运行轨迹。 不要用异常进行业务逻辑处理 我们先来看一个例子: public void processMessage(Message&lt;String&gt; message){ try{ //处理消息验证 //处理消息解析 //处理消息入库 }catch(ValidateException e){ //验证失败 }catch(ParseException e){ //解析失败 }catch(PersistException e){ //入库失败 } } 上述代码就是典型的使用异常来处理业务逻辑。这种方式需要严重的禁止！上述代码最大的问题在于，我们如何利用异常来自动处理事务呢？然而这和我们的异常中断service没有什么冲突.也并不是一回事.我们提倡在 业务处理 的时候，如果发现无法处理直接抛出异常即可。而并不是在 逻辑处理 的时候，用异常来判断逻辑进行的状况。改正后的逻辑 public void processMessage(Message&lt;String&gt; message){ if(!message.isValud){ MessageLogService.log(&quot;消息验证失败&quot;+message.errors()); return; } ... //TODO ... }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker系列]]></title>
    <url>%2F2019%2F01%2F16%2Fdocker%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[CentOS Docker 安装Docker支持以下的CentOS版本： CentOS 7 (64-bit) CentOS 6.5 (64-bit) 或更高的版本 使用 yum 安装（CentOS 7下） 通过 uname -r 命令查看你当前的内核版本 [root@runoob ~]# uname -r 3.10.0-327.el7.x86_64 只需通过以下命令即可安装 Docker 软件： yum -y install docker-io 可使用以下命令，查看 Docker 是否安装成功 docker version Client: Version: 18.09.1 API version: 1.39 Go version: go1.10.6 Git commit: 4c52b90 Built: Wed Jan 9 19:35:01 2019 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 18.09.1 API version: 1.39 (minimum version 1.12) Go version: go1.10.6 Git commit: 4c52b90 Built: Wed Jan 9 19:06:30 2019 OS/Arch: linux/amd64 Experimental: false 若输出了 Docker 的版本号，则说明安装成功了，可通过以下命令启动 Docker 服务： service docker start 下载镜像使用以下命令查看本地所有的镜像： docker images 首先，访问 Docker 中文网，在首页中搜索名为“centos”的镜像，在搜索的结果中，有一个“官方镜像”，它就是我们所需的。 然后，进入 CentOS 官方镜像页面，在“Pull this repository”输入框中，有一段命令，把它复制下来，在自己的命令行上运行该命令，随后将立即下载该镜像。 最后，使用以下命令查看本地所有的镜像： REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE centos latest 1e1148e4cc2c 5 weeks ago 202MB 如果看到以上输出，说明您可以使用“centos”这个镜像了，或将其称为仓库（Repository），该镜像有一个名为“latest ”的标签（Tag），此外还有一个名为“1e1148e4cc2c ”的镜像 ID（可能您所看到的镜像 ID 与此处的不一致，那是正常现象，因为这个数字是随机生成的）。此外，我们可以看到该镜像只有 202MB MB，非常小巧，而不像虚拟机的镜像文件那样庞大。 启动容器容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。 只需使用以下命令即可启动容器： docker run -i -t -v /root/software/:/mnt/software/ 1e1148e4cc2c /bin/bash docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt;解析 -i：表示以“交互模式”运行容器 -t：表示容器启动后会进入其命令行 -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;假设我们的所有安装程序都放在了宿主机的/root/software/目录下，现在需要将其挂载到容器的/mnt/software/目录下。 需要说明的是，不一定要使用“镜像 ID”，也可以使用“仓库名:标签名”，例如：centos: latest。 初始命令表示一旦容器启动，需要运行的命令，此时使用“/bin/bash”，表示什么也不做，只需进入命令行即可。 安装相关软件为了搭建 Java Web 运行环境，我们需要安装 JDK 、数据库、redis与 Tomcat，首先要再宿主机上传JDK 、数据库、redis与 Tomcat压缩包，以/mnt/software/为例。下面的过程均在容器内部进行。我们不妨选择/opt/目录作为安装目录，首先需要通过cd /opt/命令进入该目录。 首先，解压程序包 tar -zxf /mnt/software/jdk-7u67-linux-x64.tar.gz tar -zxf /mnt/software/apache-tomcat-7.0.55.tar.gz tar -zxf /mnt/software/redis tar -zxf /mnt/software/mongo 设置环境变量 首先，编辑.bashrc文件 vi ~/.bashrc 然后，在该文件末尾添加如下配置： export JAVA_HOME=/opt/jdk export PATH=$PATH:$JAVA_HOME 最后，需要使用source命令，让环境变量生效： source ~/.bashrc 编写运行脚本 vi /root/run.sh 然后，编辑脚本内容如下： source ~/.bashrc sh /opt/tomcat/bin/catalina.sh run 注意：这里必须先加载环境变量，然后使用 Tomcat 的运行脚本来启动 Tomcat 服务。 最后，为运行脚本添加执行权限： chmod u+x /root/run.sh 退出容器当以上步骤全部完成后，可使用exit命令，退出容器。 随后，可使用如下命令查看正在运行的容器： docker ps//未输出 docker ps -a//输出 输出如下内容： CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 57c312bbaad1 docker.cn/docker/centos:centos6 &quot;/bin/bash&quot; 27 minutes ago Exited (0) 19 seconds ago naughty_goldstine 记住以上CONTAINER ID（容器 ID），随后我们将通过该容器，创建一个可运行 Java Web 的镜像。 创建 Java Web 镜像使用以下命令，根据某个“容器 ID”来创建一个新的“镜像”： docker commit 57c312bbaad1 ikangbow/javaweb:0.1 该容器的 ID 是“57c312bbaad1”，所创建的镜像名是“ikangbow/javaweb:0.1”，随后可使用镜像来启动 Java Web 容器。 启动 Java Web 容器首先使用docker images命令，查看当前所有的镜像： REPOSITORY TAG IMAGE ID CREATED SIZE ikangbow/javaweb 0.1 95b5f6b09ca6 6 hours ago 1.51GB centos latest 1e1148e4cc2c 5 weeks ago 202MB 可见，此时已经看到了最新创建的镜像“ikangbow/javaweb:0.1”，其镜像 ID 是“95b5f6b09ca6”。正如上面所描述的那样，我们可以通过“镜像名”或“镜像 ID”来启动容器，与上次启动容器不同的是，我们现在不再进入容器的命令行，而是直接启动容器内部的 Tomcat 服务。此时，需要使用以下命令： docker run -d -p 58080:8080 --name javaweb ikangbow/javaweb:0.1 /root/run.sh 稍作解释： -d：表示以“守护模式”执行/root/run.sh脚本，此时 Tomcat 控制台不会出现在输出终端上。 -p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 58080 端口，这样就向外界暴露了 58080 端口，可通过 Docker 网桥来访问容器内部的 8080 端口了。 –name：表示容器名称，用一个有意义的名称命名即可。 关于 Docker 网桥的内容，需要补充说明一下。实际上 Docker 在宿主机与容器之间，搭建了一座网络通信的桥梁，我们可通过宿主机 IP 地址与端口号来映射容器内部的 IP 地址与端口号， 在一系列参数后面的是“镜像名”或“镜像 ID”，怎么方便就怎么来。最后是“初始命令”，它是上面编写的运行脚本，里面封装了加载环境变量并启动 Tomcat 服务的命令。 当运行以上命令后，会立即输出一长串“容器 ID”，我们可通过docker ps命令来查看当前正在运行的容器。 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 82f47923f926 ikangbow/javaweb:0.1 &quot;/root/run.sh&quot; 4 seconds ago Up 3 seconds 0.0.0.0:58080-&gt;8080/tcp javaweb 此处实测有问题，需要继续研究。 附常用命令： 删除容器实例 寻找已经停止运行的container docker ps -a docker rm 容器id 删除实例 docker ps -a 查看实例已经删除 docker rm $(docker ps -a -q) 删除所有container 2.删除镜像 停止所有的container，这样才能够删除其中的images： docker stop $(docker ps -a -q) docker rmi &lt;image id&gt; docker images 查看所有镜像 docker rmi 镜像id 删除镜像 docker images 查看镜像 发现已经删除 实际应用docker stop application//停止应用 docker rm application//删除镜像 docker run -i -t -d -p 88:8080 -v /badou/badou/badou1.war:/usr/local/tomcat/webapps/badou.war -v /badou/conf/apiclient_cert.p12:/usr/local/tomcat/apiclient_cert.p12 -v /badou/badou/index.html:/usr/local/tomcat/webapps/ROOT/index.html --name=application andylaun/tomcat:v5 -v 挂载文件目录]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http基础]]></title>
    <url>%2F2019%2F01%2F07%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTP 简介HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： 1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 2.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 3.HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP 消息结构HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。 一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 实例下面实例是一点典型的使用GET来传递数据的实例： 客户端请求： GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi 服务端响应: HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: “34aa387-d-1568eb00”Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET: 请求指定的页面信息，并返回实体主体。 HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT: 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE: 请求服务器删除指定的页面。 CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS: 允许客户端查看服务器的性能。 TRACE: 回显服务器收到的请求，主要用于测试或诊断。 HTTP 响应头信息 Allow: 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding: 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档 的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept- Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length: 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type: 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date: 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires: 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified: 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文 档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location: 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh: 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜METAHTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一 个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它 Server: 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie: 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate: 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例 如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 HTTP状态码当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 HTTP状态码分类 200 OK 请求成功。一般用于GET与POST请求 401 Unauthorized 请求要求用户的身份认证 500 Internal Server Error 服务器内部错误，无法完成请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 HTTP content-typeContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final和static的作用]]></title>
    <url>%2F2019%2F01%2F06%2Ffinal%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[final关键字的作用 被final修饰的类不可以被继承 被final修饰的方法不可以被重写 被final修饰的变量不可被改变 重点 被fianl修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的。 被fina修饰的常量，在编译阶段会存入调用类的常量池中。 static关键字的作用 被static修饰的变量属于类变量，可以通过 类名.变量名 直接引用，而不需要new出一个类。 被static修饰的方法属于类方法，可以通过 类名.变量名 直接引用，而不需要new出一个类。 被static修饰的变量和方法属于类的静态资源，是类实例之间共享的。JDK把不同的静态资源放在了不同的类中而不把所有的静态资源放在一个类里面是因为： 不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样比较清晰 避免重名。不同的类之间有重名的静态变量名，静态方法名也是很正常。 避免静态资源类无限膨胀。 问题静态方法能不能引用非静态资源？静态方法里面能不能引用静态资源？非静态方法里面能不能引用静态资源？比如就以这段代码为例，是否有错？ public class A{ private int i = 1; public static void main(String[] args){ i = 1;//错误 } } 静态资源属于类，但是是独立于类存在的。从JVM类的加载机制的角度讲，静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的。类的初始化早于类的new,比如Class.forName(“xxx”),就是初始化了一个类，但是并没有new它，只是加载这个类的静态资源。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的；但是对于非静态资源来说就不一样了，它是new出来之后产生的，因此属于类的它都认识。所以结论是： 静态方法不能引用非静态资源。非静态资源在new对象的时候才会产生，晚于一初始化就存在的静态资源。 静态方法里面可以引用静态资源。都是类初始化的时候加载的。 非静态方法可以引用静态资源。非静态方法是new之后产生的，静态资源是类一初始化就存在的。 静态块静态块是static的重要应用之一。主要用于初始化一个类的时候做操作用的，和静态变量，静态方法一样，静态块里面的代码只执行一次，且只在类初始化的时候执行。 public class A{ private static int a = B(); static{ System.out.println(&quot;Enter A.static block&quot;); } public static void main(String[] args){ new A(); } public static int B(){ System.out.println(&quot;Enter A.B()&quot;); return 1; } } 打印结果： Enter A.B() Enter A.static block 结论： 静态资源的加载顺序是严格安装静态资源的定义顺序加载的。 public class A{ static { c = 3; System.out.println(c);//Cannot reference a field before it is defined } private static int c; } 结论： 静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。 public class A{ static { System.out.println(&quot;A.static block&quot;); } public A() { System.out.println(&quot;A.constructor()&quot;); } } public class B extends A{ static { System.out.println(&quot;B.static block&quot;); } public B() { System.out.println(&quot;B.constructor()&quot;); } public static void main(String[] args) { new B(); new B(); } } 打印结果： A.static block B.static block A.constructor() B.constructor() A.constructor() B.constructor() 结论： 静态代码块是严格按照父类静态代码块》子类静态代码块的顺序加载的，且只加载一次。 项目中用到的项目中的角色类型通常用static final修饰 public static final String TYPE_A = &quot;a&quot;; public static final String TYPE_B = &quot;b&quot;; public:使接口的实现类可以使用这个常量 static:static修饰的表示是属于类的，随着类的加载而存在。如果是非static的，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为satic final:fina修饰保证接口定义的常量不能被实现类去修改，如果没有final的话，任由子类随意去修改的话，接口建立这个常量就没有意义了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅的写代码]]></title>
    <url>%2F2018%2F12%2F19%2F%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[代码优化的目标1.减小代码的体积。 2.提高代码运行效率 代码规范 所有文件的开头都要有Java文档的注释（/* /） 常量应该全部大写，单词之间由下划线分隔(例如，MAX_WORK_HOURS) 数组标识：要用”int[] packets”，而不是”int packets[]”，后一种永远也不要用 不要在循环中构造和释放对象 不要在循环中频繁查询数据库 方法要通盘考虑，尽量做到复用。（多想） 代码优化细节尽量重用对象特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 string类是final类，不能被继承，并且它的成员方法都默认为final方法。在java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。从Java SE5/6开始，就渐渐摒弃这种方式了。因此在现在版本中并不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final. String类其实是通过char数组来保存字符串的。所以无论是substring、concat、replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。所以结论是：对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。 通过new关键字来生成对象是在堆区进行的，所以通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。 在class文件中有一部分来存储编译期间生成的字面常量以及符合的引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。下面代码 str1和str3都存储在常量池中，只存了一份。 public class Main { public static void main(String[] args) { String str1 = &quot;hello world&quot;; String str2 = new String(&quot;hello world&quot;); String str3 = &quot;hello world&quot;; String str4 = new String(&quot;hello world&quot;); System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str2==str4); } } 输出结果为false true false 既然已经有了String类，那为什么还需要StringBuilder、StringBuffer类呢 public class Main { public static void main(String[] args) { String string = &quot;&quot;; for(int i=0;i&lt;10000;i++){ string += &quot;hello&quot;; } } } 这句 string += “hello”;的过程相当于将原有的string变量指向的对象内容取出与”hello”作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。结论：使用String进行字符串拼接会造成内存资源浪费。 public class Main { public static void main(String[] args) { StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i&lt;10000;i++){ stringBuilder.append(&quot;hello&quot;); } } } 使用StringBuilder new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。 事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全的。 StringBuilder的insert方法： public StringBuilder insert(int index, char str[], int offset, int len){ super.insert(index, str, offset, len); return this; } StringBuffer的insert方法： public synchronized StringBuffer insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } 结论： 1.对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。这个可以用javap -c命令反编译生成的class文件进行验证。 对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 2.String、StringBuilder、StringBuffer三者的执行效率： StringBuilder &gt; StringBuffer &gt; String 当然这个是相对的，不一定在所有情况下都是这样。 比如String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高。 因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式； 当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 及时关闭流Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。尽量避免在for循环中进行数据库的操作。 尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： for (int i = 0; i &lt; list.size(); i++) {...} 替换为 for (int i = 0, length = list.size(); i &lt; length; i++) {...} 这样，在list.size()很大的时候，就减少了很多的消耗 尽量采用懒加载的策略，即在需要的时候才创建例如： String str = &quot;aaa&quot;; if (i == 1) { list.add(str); } 建议替换为： if (i == 1) { String str = &quot;aaa&quot;; list.add(str); } 慎用异常异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： StringBuilder() // 默认分配16个字符的空间 StringBuilder(int size) // 默认分配size个字符的空间 StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： 在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间 把原来的4096个字符拷贝到新的的字符数组中去。 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 循环内不要不断创建对象引用例如： for (int i = 1; i &lt;= count; i++){ Object obj = new Object(); } 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： Object obj = null; for (int i = 0; i &lt;= count; i++) { obj = new Object(); } 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList，尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销。实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历if (list instanceof RandomAccess){ for (int i = 0; i &lt; list.size(); i++){ ... } } else { Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext()){ iterator.next() } } 这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。 使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 字符串变量和字符串常量equals的时候将字符串常量写在前面把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢public static void main(String[] args){ int loopTime = 50000; Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++){ String str = String.valueOf(i); } System.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++){ String str = i.toString(); } System.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++){ String str = i + &quot;&quot;; } System.out.println(&quot;i + \&quot;\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); } 运行结果为： String.valueOf()：11ms Integer.toString()：5ms i + &quot;&quot;：25ms 三者对比下来，明显是2最快、1次之、3最慢。结论： 以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 Integer.toString()方法就不说了，直接调用了 i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 使用最有效率的方式去遍历Mappublic static void main(String[] args){ HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put(&quot;111&quot;, &quot;222&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext()) { Map.Entry&lt;String, String&gt; entry = iter.next(); System.out.println(entry.getKey() + &quot;\t&quot; + entry.getValue()); } } 如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet();”会比较合适一些]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis相关及实践]]></title>
    <url>%2F2018%2F12%2F15%2FRedis%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[定义redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。redis的官网地址，非常好记，是redis.io。（特意查了一下，域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地）目前，Vmware在资助着redis项目的开发和维护。详见百度百科 RedisTemplate常用集合-opsForValue1.set(K key, V value)新增一个字符串类型的值,key是键，value是值。 redisTemplate.opsForValue().set(&quot;stringValue&quot;,&quot;bbb&quot;); 2.get(Object key)获取key键对应的值 String stringValue = redisTemplate.opsForValue().get(&quot;stringValue&quot;)+&quot;&quot;; System.out.println(&quot;通过get(Object key)方法获取set(K key, V value)方法新增的字符串值:&quot; + stringValue); 3.append(K key, String value)在原有的值基础上新增字符串到末尾。 redisTemplate.opsForValue().append(&quot;stringValue&quot;,&quot;aaa&quot;); String stringValueAppend = redisTemplate.opsForValue().get(&quot;stringValue&quot;)+&quot;&quot;; ` System.out.println(&quot;通过append(K key, String value)方法修改后的字符串:&quot;+stringValueAppend); 4.get(K key, long start, long end)截取key键对应值得字符串，从开始下标位置开始到结束下标的位置(包含结束下标)的字符串。 String cutString = redisTemplate.opsForValue().get(&quot;stringValue&quot;,0,3); System.out.println(&quot;通过get(K key, long start, long end)方法获取截取的字符串:&quot;+cutString); 5.getAndSet(K key, V value)获取原来key键对应的值并重新赋新值。 String oldAndNewStringValue = redisTemplate.opsForValue().getAndSet(&quot;stringValue&quot;,&quot;ccc&quot;)+&quot;&quot;; System.out.print(&quot;通过getAndSet(K key, V value)方法获取原来的&quot; + oldAndNewStringValue + &quot;,&quot;); String newStringValue = redisTemplate.opsForValue().get(&quot;stringValue&quot;)+&quot;&quot;; System.out.println(&quot;修改过后的值:&quot;+newStringValue); 6.setBit(K key, long offset, boolean value)key键对应的值value对应的ascii码,在offset的位置(从左向右数)变为value。 redisTemplate.opsForValue().setBit(&quot;stringValue&quot;,1,false); newStringValue = redisTemplate.opsForValue().get(&quot;stringValue&quot;)+&quot;&quot;; System.out.println(&quot;通过setBit(K key,long offset,boolean value)方法修改过后的值:&quot;+newStringValue); 7.getBit(K key, long offset)判断指定的位置ASCII码的bit位是否为1。 boolean bitBoolean = redisTemplate.opsForValue().getBit(&quot;stringValue&quot;,1); boolean bitBoolean = redisTemplate.opsForValue().getBit(&quot;stringValue&quot;,1); 8.size(K key)获取指定字符串的长度。 Long stringValueLength = redisTemplate.opsForValue().size(&quot;stringValue&quot;); Long stringValueLength = redisTemplate.opsForValue().size(&quot;stringValue&quot;); 9.increment(K key, double delta) 以增量的方式将double值存储在变量中。 double stringValueDouble = redisTemplate.opsForValue().increment(&quot;doubleValue&quot;,5); System.out.println(&quot;通过increment(K key, double delta)方法以增量方式存储double值:&quot; + stringValueDouble); 10.increment(K key, long delta)以增量的方式将long值存储在变量中。 double stringValueLong = redisTemplate.opsForValue().increment(&quot;longValue&quot;,6); System.out.println(&quot;通过increment(K key, long delta)方法以增量方式存储long值:&quot; + stringValueLong); 11.setIfAbsent(K key, V value)如果键不存在则新增,存在则不改变已经有的值。 boolean absentBoolean = redisTemplate.opsForValue().setIfAbsent(&quot;absentValue&quot;,&quot;fff&quot;); System.out.println(&quot;通过setIfAbsent(K key, V value)方法判断变量值absentValue是否存在:&quot; + absentBoolean); if(absentBoolean){ String absentValue = redisTemplate.opsForValue().get(&quot;absentValue&quot;)+&quot;&quot;; System.out.print(&quot;,不存在，则新增后的值是:&quot;+absentValue); boolean existBoolean = redisTemplate.opsForValue().setIfAbsent(&quot;absentValue&quot;,&quot;eee&quot;); System.out.print(&quot;,再次调用setIfAbsent(K key, V value)判断absentValue是否存在并重新赋值:&quot; + existBoolean); if(!existBoolean){ absentValue = redisTemplate.opsForValue().get(&quot;absentValue&quot;)+&quot;&quot;; System.out.print(&quot;如果存在,则重新赋值后的absentValue变量的值是:&quot; + absentValue); } } 12.set(K key, V value, long timeout, TimeUnit unit)设置变量值的过期时间。 redisTemplate.opsForValue().set(&quot;timeOutValue&quot;,&quot;timeOut&quot;,5,TimeUnit.SECONDS); String timeOutValue = redisTemplate.opsForValue().get(&quot;timeOutValue&quot;)+&quot;&quot;; System.out.println(&quot;通过set(K key, V value, long timeout, TimeUnit unit)方法设置过期时间，过期之前获取的数据:&quot;+timeOutValue); Thread.sleep(5*1000); timeOutValue = redisTemplate.opsForValue().get(&quot;timeOutValue&quot;)+&quot;&quot;; System.out.print(&quot;,等待10s过后，获取的值:&quot;+timeOutValue); 13.set(K key, V value, long offset) 覆盖从指定位置开始的值。 redisTemplate.opsForValue().set(&quot;absentValue&quot;,&quot;dd&quot;,1); String overrideString = redisTemplate.opsForValue().get(&quot;absentValue&quot;)+&quot;&quot;; System.out.println(&quot;通过set(K key, V value, long offset)方法覆盖部分的值:&quot;+overrideString); 14.multiSet(Map&lt;? extends K,? extends V&gt; map)设置map集合到redis。 Map valueMap = new HashMap(); valueMap.put(&quot;valueMap1&quot;,&quot;map1&quot;); valueMap.put(&quot;valueMap2&quot;,&quot;map2&quot;); valueMap.put(&quot;valueMap3&quot;,&quot;map3&quot;); redisTemplate.opsForValue().multiSet(valueMap); 15.multiGet(Collection keys) 根据集合取出对应的value值。 //根据List集合取出对应的value值 List paraList = new ArrayList(); paraList.add(&quot;valueMap1&quot;); paraList.add(&quot;valueMap2&quot;); paraList.add(&quot;valueMap3&quot;); List&lt;String&gt; valueList = redisTemplate.opsForValue().multiGet(paraList); for (String value : valueList){ System.out.println(&quot;通过multiGet(Collection&lt;K&gt; keys)方法获取map值:&quot; + value); } 16.multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map)如果对应的map集合名称不存在，则添加，如果存在则不做修改。 Map valueMap = new HashMap(); valueMap.put(&quot;valueMap1&quot;,&quot;map1&quot;); valueMap.put(&quot;valueMap2&quot;,&quot;map2&quot;); valueMap.put(&quot;valueMap3&quot;,&quot;map3&quot;); redisTemplate.opsForValue().multiSetIfAbsent(valueMap); RedisTemplate常用集合-opsForList1.leftPush(K key, V value)在变量左边添加元素值。 redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;a&quot;); redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;b&quot;); redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;c&quot;); 2.index(K key, long index)获取集合指定位置的值。 String listValue = redisTemplate.opsForList().index(&quot;list&quot;,1) + &quot;&quot;; System.out.println(&quot;通过index(K key, long index)方法获取指定位置的值:&quot; + listValue); 3.range(K key, long start, long end)获取指定区间的值。 List&lt;Object&gt; list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过range(K key, long start, long end)方法获取指定范围的集合值:&quot;+list); 4.leftPush(K key, V pivot, V value)把最后一个参数值放到指定集合的第一个出现中间参数的前面，如果中间参数值存在的话。 redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;a&quot;,&quot;n&quot;); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过leftPush(K key, V pivot, V value)方法把值放到指定参数值前面:&quot; + list); 5.leftPushAll(K key, V… values)向左边批量添加参数元素。 redisTemplate.opsForList().leftPushAll(&quot;list&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过leftPushAll(K key, V... values)方法批量添加元素:&quot; + list); 6.leftPushAll(K key, Collection values)以集合的方式向左边批量添加元素。 List newList = new ArrayList(); newList.add(&quot;o&quot;); newList.add(&quot;p&quot;); newList.add(&quot;q&quot;); redisTemplate.opsForList().leftPushAll(&quot;list&quot;,newList); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过leftPushAll(K key, Collection&lt;V&gt; values)方法以集合的方式批量添加元素:&quot; + list); 7.leftPushIfPresent(K key, V value) 如果存在集合则添加元素。 redisTemplate.opsForList().leftPushIfPresent(&quot;presentList&quot;,&quot;o&quot;); list = redisTemplate.opsForList().range(&quot;presentList&quot;,0,-1); System.out.println(&quot;通过leftPushIfPresent(K key, V value)方法向已存在的集合添加元素:&quot; + list); 8.rightPush(K key, V value)向集合最右边添加元素。 redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;w&quot;); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过rightPush(K key, V value)方法向最右边添加元素:&quot; + list); 9.rightPush(K key, V pivot, V value)向集合中第一次出现第二个参数变量元素的右边添加第三个参数变量的元素值。 redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;w&quot;,&quot;r&quot;); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过rightPush(K key, V pivot, V value)方法向最右边添加元素:&quot; + list); 10.rightPushAll(K key, V… values)向右边批量添加元素。 redisTemplate.opsForList().rightPushAll(&quot;list&quot;,&quot;j&quot;,&quot;k&quot;); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过rightPushAll(K key, V... values)方法向最右边批量添加元素:&quot; + list); 11.rightPushAll(K key, Collection values)以集合方式向右边添加元素。 newList.clear(); newList.add(&quot;g&quot;); newList.add(&quot;h&quot;); redisTemplate.opsForList().rightPushAll(&quot;list&quot;,newList); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过rightPushAll(K key, Collection&lt;V&gt; values)方法向最右边以集合方式批量添加元素:&quot; + list); 12.rightPushIfPresent(K key, V value)向已存在的集合中添加元素。 redisTemplate.opsForList().rightPushIfPresent(&quot;presentList&quot;,&quot;d&quot;); list = redisTemplate.opsForList().range(&quot;presentList&quot;,0,-1); System.out.println(&quot;通过rightPushIfPresent(K key, V value)方法已存在的集合向最右边添加元素:&quot; + list); 13.size(K key)获取集合长度。 long listLength = redisTemplate.opsForList().size(&quot;list&quot;); System.out.println(&quot;通过size(K key)方法获取集合list的长度为:&quot; + listLength); 14.leftPop(K key)移除集合中的左边第一个元素。 Object popValue = redisTemplate.opsForList().leftPop(&quot;list&quot;); System.out.print(&quot;通过leftPop(K key)方法移除的元素是:&quot; + popValue); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;,剩余的元素是:&quot; + list); 15.leftPop(K key, long timeout, TimeUnit unit)移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 popValue = redisTemplate.opsForList().leftPop(&quot;presentList&quot;,1, TimeUnit.SECONDS); System.out.print(&quot;通过leftPop(K key, long timeout, TimeUnit unit)方法移除的元素是:&quot; + popValue); list = redisTemplate.opsForList().range(&quot;presentList&quot;,0,-1); System.out.println(&quot;,剩余的元素是:&quot; + list); 16.rightPop(K key)移除集合中右边的元素。 popValue = redisTemplate.opsForList().rightPop(&quot;list&quot;); System.out.print(&quot;通过rightPop(K key)方法移除的元素是:&quot; + popValue); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;,剩余的元素是:&quot; + list); 17.rightPop(K key, long timeout, TimeUnit unit)移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 popValue = redisTemplate.opsForList().rightPop(&quot;presentList&quot;,1, TimeUnit.SECONDS); System.out.print(&quot;通过rightPop(K key, long timeout, TimeUnit unit)方法移除的元素是:&quot; + popValue); list = redisTemplate.opsForList().range(&quot;presentList&quot;,0,-1); System.out.println(&quot;,剩余的元素是:&quot; + list); 18.rightPopAndLeftPush(K sourceKey, K destinationKey)移除集合中右边的元素，同时在左边加入一个元素。 popValue = redisTemplate.opsForList().rightPopAndLeftPush(&quot;list&quot;,&quot;12&quot;); System.out.print(&quot;通过rightPopAndLeftPush(K sourceKey, K destinationKey)方法移除的元素是:&quot; + popValue); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;,剩余的元素是:&quot; + list); 19.rightPopAndLeftPush(K sourceKey, K destinationKey, long timeout, TimeUnit unit) 移除集合中右边的元素在等待的时间里，同时在左边添加元素，如果超过等待的时间仍没有元素则退出。 popValue = redisTemplate.opsForList().rightPopAndLeftPush(&quot;presentList&quot;,&quot;13&quot;,1,TimeUnit.SECONDS); System.out.println(&quot;通过rightPopAndLeftPush(K sourceKey, K destinationKey, long timeout, TimeUnit unit)方法移除的元素是:&quot; + popValue); list = redisTemplate.opsForList().range(&quot;presentList&quot;,0,-1); System.out.print(&quot;,剩余的元素是:&quot; + list); 20.set(K key, long index, V value)在集合的指定位置插入元素,如果指定位置已有元素，则覆盖，没有则新增，超过集合下标+n则会报错。 redisTemplate.opsForList().set(&quot;presentList&quot;,3,&quot;15&quot;); list = redisTemplate.opsForList().range(&quot;presentList&quot;,0,-1); System.out.print(&quot;通过set(K key, long index, V value)方法在指定位置添加元素后:&quot; + list); 21.remove(K key, long count, Object value)从存储在键中的列表中删除等于值的元素的第一个计数事件。count&gt; 0：删除等于从左到右移动的值的第一个元素；count&lt; 0：删除等于从右到左移动的值的第一个元素；count = 0：删除等于value的所有元素。 long removeCount = redisTemplate.opsForList().remove(&quot;list&quot;,0,&quot;w&quot;); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过remove(K key, long count, Object value)方法移除元素数量:&quot; + removeCount); System.out.println(&quot;,剩余的元素:&quot; + list); 22.trim(K key, long start, long end)截取集合元素长度，保留长度内的数据。 redisTemplate.opsForList().trim(&quot;list&quot;,0,5); list = redisTemplate.opsForList().range(&quot;list&quot;,0,-1); System.out.println(&quot;通过trim(K key, long start, long end)方法截取后剩余元素:&quot; + list); RedisTemplate常用集合-opsForHash1.put(H key, HK hashKey, HV value)新增hashMap值。 redisTemplate.opsForHash().put(&quot;hashValue&quot;,&quot;map1&quot;,&quot;map1-1&quot;); redisTemplate.opsForHash().put(&quot;hashValue&quot;,&quot;map2&quot;,&quot;map2-2&quot;); 2.values(H key)获取指定变量中的hashMap值。 List&lt;Object&gt; hashList = redisTemplate.opsForHash().values(&quot;hashValue&quot;); System.out.println(&quot;通过values(H key)方法获取变量中的hashMap值:&quot; + hashList); 3.entries(H key)获取变量中的键值对。 Map&lt;Object,Object&gt; map = redisTemplate.opsForHash().entries(&quot;hashValue&quot;); System.out.println(&quot;通过entries(H key)方法获取变量中的键值对:&quot; + map); 4.get(H key, Object hashKey)获取变量中的指定map键是否有值,如果存在该map键则获取值，没有则返回null。 Object mapValue = redisTemplate.opsForHash().get(&quot;hashValue&quot;,&quot;map1&quot;); System.out.println(&quot;通过get(H key, Object hashKey)方法获取map键的值:&quot; + mapValue); 5.hasKey(H key, Object hashKey) 判断变量中是否有指定的map键。 boolean hashKeyBoolean = redisTemplate.opsForHash().hasKey(&quot;hashValue&quot;,&quot;map3&quot;); System.out.println(&quot;通过hasKey(H key, Object hashKey)方法判断变量中是否存在map键:&quot; + hashKeyBoolean); 6.keys(H key)获取变量中的键。 Set&lt;Object&gt; keySet = redisTemplate.opsForHash().keys(&quot;hashValue&quot;); System.out.println(&quot;通过keys(H key)方法获取变量中的键:&quot; + keySet); 7.size(H key)获取变量的长度。 long hashLength = redisTemplate.opsForHash().size(&quot;hashValue&quot;); System.out.println(&quot;通过size(H key)方法获取变量的长度:&quot; + hashLength); 8.increment(H key, HK hashKey, double delta)使变量中的键以double值的大小进行自增长。 double hashIncDouble = redisTemplate.opsForHash().increment(&quot;hashInc&quot;,&quot;map1&quot;,3); System.out.println(&quot;通过increment(H key, HK hashKey, double delta)方法使变量中的键以值的大小进行自增长:&quot; + hashIncDouble); 9.increment(H key, HK hashKey, long delta)使变量中的键以long值的大小进行自增长。 long hashIncLong = redisTemplate.opsForHash().increment(&quot;hashInc&quot;,&quot;map2&quot;,6); System.out.println(&quot;通过increment(H key, HK hashKey, long delta)方法使变量中的键以值的大小进行自增长:&quot; + hashIncLong); 10.multiGet(H key, Collection hashKeys)以集合的方式获取变量中的值。 List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); list.add(&quot;map1&quot;); list.add(&quot;map2&quot;); List mapValueList = redisTemplate.opsForHash().multiGet(&quot;hashValue&quot;,list); System.out.println(&quot;通过multiGet(H key, Collection&lt;HK&gt; hashKeys)方法以集合的方式获取变量中的值:&quot;+mapValueList); 11.putAll(H key, Map&lt;? extends HK,? extends HV&gt; m)以map集合的形式添加键值对。 Map newMap = new HashMap(); newMap.put(&quot;map3&quot;,&quot;map3-3&quot;); newMap.put(&quot;map5&quot;,&quot;map5-5&quot;); redisTemplate.opsForHash().putAll(&quot;hashValue&quot;,newMap); map = redisTemplate.opsForHash().entries(&quot;hashValue&quot;); System.out.println(&quot;通过putAll(H key, Map&lt;? extends HK,? extends HV&gt; m)方法以map集合的形式添加键值对:&quot; + map); 12.putIfAbsent(H key, HK hashKey, HV value)如果变量值存在，在变量中可以添加不存在的的键值对，如果变量不存在，则新增一个变量，同时将键值对添加到该变量。 redisTemplate.opsForHash().putIfAbsent(&quot;hashValue&quot;,&quot;map6&quot;,&quot;map6-6&quot;); map = redisTemplate.opsForHash().entries(&quot;hashValue&quot;); System.out.println(&quot;通过putIfAbsent(H key, HK hashKey, HV value)方法添加不存在于变量中的键值对:&quot; + map); 13.scan(H key, ScanOptions options)匹配获取键值对，ScanOptions.NONE为获取全部键对，ScanOptions.scanOptions().match(&quot;map1&quot;).build() 匹配获取键位map1的键值对,不能模糊匹配。 Cursor&lt;Map.Entry&lt;Object,Object&gt;&gt; cursor = redisTemplate.opsForHash().scan(&quot;hashValue&quot;,ScanOptions.scanOptions().match(&quot;map1&quot;).build()); //Cursor&lt;Map.Entry&lt;Object,Object&gt;&gt; cursor = redisTemplate.opsForHash().scan(&quot;hashValue&quot;,ScanOptions.NONE); while (cursor.hasNext()){ Map.Entry&lt;Object,Object&gt; entry = cursor.next(); System.out.println(&quot;通过scan(H key, ScanOptions options)方法获取匹配键值对:&quot; + entry.getKey() + &quot;----&gt;&quot; + entry.getValue()); } 14.delete(H key, Object… hashKeys)删除变量中的键值对，可以传入多个参数，删除多个键值对。 redisTemplate.opsForHash().delete(&quot;hashValue&quot;,&quot;map1&quot;,&quot;map2&quot;); map = redisTemplate.opsForHash().entries(&quot;hashValue&quot;); System.out.println(&quot;通过delete(H key, Object... hashKeys)方法删除变量中的键值对后剩余的:&quot; + map); RedisTemplate常用集合-opsForSet1.add(K key, V… values)向变量中批量添加值。 redisTemplate.opsForSet().add(&quot;setValue&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;B&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;); 2.members(K key) 获取变量中的值。 Set set = redisTemplate.opsForSet().members(&quot;setValue&quot;); System.out.println(&quot;通过members(K key)方法获取变量中的元素值:&quot; + set); 3.size(K key)获取变量中值的长度。 long setLength = redisTemplate.opsForSet().size(&quot;setValue&quot;); System.out.println(&quot;通过size(K key)方法获取变量中元素值的长度:&quot; + setLength); 4.randomMember(K key)随机获取变量中的元素。 Object randomMember = redisTemplate.opsForSet().randomMember(&quot;setValue&quot;); System.out.println(&quot;通过randomMember(K key)方法随机获取变量中的元素:&quot; + randomMember); 5.randomMembers(K key, long count)随机获取变量中指定个数的元素。 List randomMembers = redisTemplate.opsForSet().randomMembers(&quot;setValue&quot;,2); System.out.println(&quot;通过randomMembers(K key, long count)方法随机获取变量中指定个数的元素:&quot; + randomMembers); 6.isMember(K key, Object o)检查给定的元素是否在变量中。 boolean isMember = redisTemplate.opsForSet().isMember(&quot;setValue&quot;,&quot;A&quot;); System.out.println(&quot;通过isMember(K key, Object o)方法检查给定的元素是否在变量中:&quot; + isMember); 7.move(K key, V value, K destKey)转移变量的元素值到目的变量。 boolean isMove = redisTemplate.opsForSet().move(&quot;setValue&quot;,&quot;A&quot;,&quot;destSetValue&quot;); if(isMove){ set = redisTemplate.opsForSet().members(&quot;setValue&quot;); System.out.print(&quot;通过move(K key, V value, K destKey)方法转移变量的元素值到目的变量后的剩余元素:&quot; + set); set = redisTemplate.opsForSet().members(&quot;destSetValue&quot;); System.out.println(&quot;,目的变量中的元素值:&quot; + set); } 8.pop(K key)弹出变量中的元素。 Object popValue = redisTemplate.opsForSet().pop(&quot;setValue&quot;); System.out.print(&quot;通过pop(K key)方法弹出变量中的元素:&quot; + popValue); set = redisTemplate.opsForSet().members(&quot;setValue&quot;); System.out.println(&quot;,剩余元素:&quot; + set) 9.remove(K key, Object… values)批量移除变量中的元素。 long removeCount = redisTemplate.opsForSet().remove(&quot;setValue&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;); System.out.print(&quot;通过remove(K key, Object... values)方法移除变量中的元素个数:&quot; + removeCount); set = redisTemplate.opsForSet().members(&quot;setValue&quot;); System.out.println(&quot;,剩余元素:&quot; + set); 10.scan(K key, ScanOptions options)匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 //Cursor&lt;Object&gt; cursor = redisTemplate.opsForSet().scan(&quot;setValue&quot;, ScanOptions.NONE); Cursor&lt;Object&gt; cursor = redisTemplate.opsForSet().scan(&quot;setValue&quot;, ScanOptions.scanOptions().match(&quot;C&quot;).build()); while (cursor.hasNext()){ Object object = cursor.next(); System.out.println(&quot;通过scan(K key, ScanOptions options)方法获取匹配的值:&quot; + object); } 11.difference(K key, Collection otherKeys)通过集合求差值。 List list = new ArrayList(); list.add(&quot;destSetValue&quot;); Set differenceSet = redisTemplate.opsForSet().difference(&quot;setValue&quot;,list); System.out.println(&quot;通过difference(K key, Collection&lt;K&gt; otherKeys)方法获取变量中与给定集合中变量不一样的值:&quot; + differenceSet); 12.difference(K key, K otherKey)通过给定的key求2个set变量的差值。 differenceSet = redisTemplate.opsForSet().difference(&quot;setValue&quot;,&quot;destSetValue&quot;); System.out.println(&quot;通过difference(K key, Collection&lt;K&gt; otherKeys)方法获取变量中与给定变量不一样的值:&quot; + differenceSet); 13.differenceAndStore(K key, K otherKey, K destKey)将求出来的差值元素保存。 redisTemplate.opsForSet().differenceAndStore(&quot;setValue&quot;,&quot;destSetValue&quot;,&quot;storeSetValue&quot;); set = redisTemplate.opsForSet().members(&quot;storeSetValue&quot;); System.out.println(&quot;通过differenceAndStore(K key, K otherKey, K destKey)方法将求出来的差值元素保存:&quot; + set); 14.differenceAndStore(K key, Collection otherKeys, K destKey)将求出来的差值元素保存。 redisTemplate.opsForSet().differenceAndStore(&quot;setValue&quot;,list,&quot;storeSetValue&quot;); set = redisTemplate.opsForSet().members(&quot;storeSetValue&quot;); System.out.println(&quot;通过differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)方法将求出来的差值元素保存:&quot; + set); 15.distinctRandomMembers(K key, long count)获取去重的随机元素。 set = redisTemplate.opsForSet().distinctRandomMembers(&quot;setValue&quot;,2); System.out.println(&quot;通过distinctRandomMembers(K key, long count)方法获取去重的随机元素:&quot; + set); 16.intersect(K key, K otherKey)获取2个变量中的交集。 set = redisTemplate.opsForSet().intersect(&quot;setValue&quot;,&quot;destSetValue&quot;); System.out.println(&quot;通过intersect(K key, K otherKey)方法获取交集元素:&quot; + set); 17.intersect(K key, Collection otherKeys)获取多个变量之间的交集。 set = redisTemplate.opsForSet().intersect(&quot;setValue&quot;,list); System.out.println(&quot;通过intersect(K key, Collection&lt;K&gt; otherKeys)方法获取交集元素:&quot; + set); 18.intersectAndStore(K key, K otherKey, K destKey)获取2个变量交集后保存到最后一个参数上。 redisTemplate.opsForSet().intersectAndStore(&quot;setValue&quot;,&quot;destSetValue&quot;,&quot;intersectValue&quot;); set = redisTemplate.opsForSet().members(&quot;intersectValue&quot;); System.out.println(&quot;通过intersectAndStore(K key, K otherKey, K destKey)方法将求出来的交集元素保存:&quot; + set); 19.intersectAndStore(K key, Collection otherKeys, K destKey)获取多个变量的交集并保存到最后一个参数上。 redisTemplate.opsForSet().intersectAndStore(&quot;setValue&quot;,list,&quot;intersectListValue&quot;); set = redisTemplate.opsForSet().members(&quot;intersectListValue&quot;); System.out.println(&quot;通过intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)方法将求出来的交集元素保存:&quot; + set); 20.union(K key, K otherKey)获取2个变量的合集。 set = redisTemplate.opsForSet().union(&quot;setValue&quot;,&quot;destSetValue&quot;); System.out.println(&quot;通过union(K key, K otherKey)方法获取2个变量的合集元素:&quot; + set); 21.union(K key, Collection otherKeys)获取多个变量的合集。 set = redisTemplate.opsForSet().union(&quot;setValue&quot;,list); System.out.println(&quot;通过union(K key, Collection&lt;K&gt; otherKeys)方法获取多个变量的合集元素:&quot; + set); 22.unionAndStore(K key, K otherKey, K destKey)获取2个变量合集后保存到最后一个参数上。 redisTemplate.opsForSet().unionAndStore(&quot;setValue&quot;,&quot;destSetValue&quot;,&quot;unionValue&quot;); set = redisTemplate.opsForSet().members(&quot;unionValue&quot;); System.out.println(&quot;通过unionAndStore(K key, K otherKey, K destKey)方法将求出来的交集元素保存:&quot; + set); 23.unionAndStore(K key, Collection otherKeys, K destKey)获取多个变量的合集并保存到最后一个参数上。 redisTemplate.opsForSet().unionAndStore(&quot;setValue&quot;,list,&quot;unionListValue&quot;); set = redisTemplate.opsForSet().members(&quot;unionListValue&quot;); System.out.println(&quot;通过unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)方法将求出来的交集元素保存:&quot; + set); RedisTemplate常用集合-opsForZSet1.add(K key, V value, double score)添加元素到变量中同时指定元素的分值。 redisTemplate.opsForZSet().add(&quot;zSetValue&quot;,&quot;A&quot;,1); redisTemplate.opsForZSet().add(&quot;zSetValue&quot;,&quot;B&quot;,3); redisTemplate.opsForZSet().add(&quot;zSetValue&quot;,&quot;C&quot;,2); redisTemplate.opsForZSet().add(&quot;zSetValue&quot;,&quot;D&quot;,5); 2.range(K key, long start, long end)获取变量指定区间的元素。 Set zSetValue = redisTemplate.opsForZSet().range(&quot;zSetValue&quot;,0,-1); System.out.println(&quot;通过range(K key, long start, long end)方法获取指定区间的元素:&quot; + zSetValue); 3.rangeByLex(K key, RedisZSetCommands.Range range) 用于获取满足非score的排序取值。这个排序只有在有相同分数的情况下才能使用，如果有不同的分数则返回值不确定。 RedisZSetCommands.Range range = new RedisZSetCommands.Range(); //range.gt(&quot;A&quot;); range.lt(&quot;D&quot;); zSetValue = redisTemplate.opsForZSet().rangeByLex(&quot;zSetValue&quot;, range); System.out.println(&quot;通过rangeByLex(K key, RedisZSetCommands.Range range)方法获取满足非score的排序取值元素:&quot; + zSetValue); 4.rangeByLex(K key, RedisZSetCommands.Range range, RedisZSetCommands.Limit limit)用于获取满足非score的设置下标开始的长度排序取值。 RedisZSetCommands.Limit limit = new RedisZSetCommands.Limit(); limit.count(2); //起始下标为0 limit.offset(1); zSetValue = redisTemplate.opsForZSet().rangeByLex(&quot;zSetValue&quot;, range,limit); System.out.println(&quot;通过rangeByLex(K key, RedisZSetCommands.Range range, RedisZSetCommands.Limit limit)方法获取满足非score的排序取值元素:&quot; + zSetValue); 5.add(K key, Set&lt;ZSetOperations.TypedTuple&gt; tuples)通过TypedTuple方式新增数据。 ZSetOperations.TypedTuple&lt;Object&gt; typedTuple1 = new DefaultTypedTuple&lt;Object&gt;(&quot;E&quot;,6.0); ZSetOperations.TypedTuple&lt;Object&gt; typedTuple2 = new DefaultTypedTuple&lt;Object&gt;(&quot;F&quot;,7.0); ZSetOperations.TypedTuple&lt;Object&gt; typedTuple3 = new DefaultTypedTuple&lt;Object&gt;(&quot;G&quot;,5.0); Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = new HashSet&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt;(); typedTupleSet.add(typedTuple1); typedTupleSet.add(typedTuple2); typedTupleSet.add(typedTuple3); redisTemplate.opsForZSet().add(&quot;typedTupleSet&quot;,typedTupleSet); zSetValue = redisTemplate.opsForZSet().range(&quot;typedTupleSet&quot;,0,-1); System.out.println(&quot;通过add(K key, Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; tuples)方法添加元素:&quot; + zSetValue); 6.rangeByScore(K key, double min, double max)根据设置的score获取区间值。 zSetValue = redisTemplate.opsForZSet().rangeByScore(&quot;zSetValue&quot;,1,2); System.out.println(&quot;通过rangeByScore(K key, double min, double max)方法根据设置的score获取区间值:&quot; + zSetValue); 7.rangeByScore(K key, double min, double max,long offset, long count)根据设置的score获取区间值从给定下标和给定长度获取最终值。 zSetValue = redisTemplate.opsForZSet().rangeByScore(&quot;zSetValue&quot;,1,5,1,3); System.out.println(&quot;通过rangeByScore(K key, double min, double max, long offset, long count)方法根据设置的score获取区间值:&quot; + zSetValue); 8.rangeWithScores(K key, long start, long end) 获取RedisZSetCommands.Tuples的区间值。 Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = redisTemplate.opsForZSet().rangeWithScores(&quot;typedTupleSet&quot;,1,3); Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = typedTupleSet.iterator(); while (iterator.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next(); Object value = typedTuple.getValue(); double score = typedTuple.getScore(); System.out.println(&quot;通过rangeWithScores(K key, long start, long end)方法获取RedisZSetCommands.Tuples的区间值:&quot; + value + &quot;----&gt;&quot; + score ); } 9.rangeByScoreWithScores(K key, double min, double max)获取RedisZSetCommands.Tuples的区间值通过分值。 Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = redisTemplate.opsForZSet().rangeByScoreWithScores(&quot;typedTupleSet&quot;,5,8); iterator = typedTupleSet.iterator(); while (iterator.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next(); Object value = typedTuple.getValue(); double score = typedTuple.getScore(); System.out.println(&quot;通过rangeByScoreWithScores(K key, double min, double max)方法获取RedisZSetCommands.Tuples的区间值通过分值:&quot; + value + &quot;----&gt;&quot; + score ); } 10.rangeByScoreWithScores(K key, double min, double max, long offset, long count)获取RedisZSetCommands.Tuples的区间值从给定下标和给定长度获取最终值通过分值。 Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = redisTemplate.opsForZSet().rangeByScoreWithScores(&quot;typedTupleSet&quot;,5,8,1,1); iterator = typedTupleSet.iterator(); while (iterator.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next(); Object value = typedTuple.getValue(); double score = typedTuple.getScore(); System.out.println(&quot;通过rangeByScoreWithScores(K key, double min, double max, long offset, long count)方法获取RedisZSetCommands.Tuples的区间值从给定下标和给定长度获取最终值通过分值:&quot; + value + &quot;----&gt;&quot; + score ); } 11.count(K key, double min, double max)获取区间值的个数。 long count = redisTemplate.opsForZSet().count(&quot;zSetValue&quot;,1,5); System.out.println(&quot;通过count(K key, double min, double max)方法获取区间值的个数:&quot; + count); 12.rank(K key, Object o)获取变量中元素的索引,下标开始位置为0。 long index = redisTemplate.opsForZSet().rank(&quot;zSetValue&quot;,&quot;B&quot;); System.out.println(&quot;通过rank(K key, Object o)方法获取变量中元素的索引:&quot; + index); 13.scan(K key, ScanOptions options)匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 //Cursor&lt;Object&gt; cursor = redisTemplate.opsForSet().scan(&quot;setValue&quot;, ScanOptions.NONE); Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; cursor = redisTemplate.opsForZSet().scan(&quot;zSetValue&quot;, ScanOptions.NONE); while (cursor.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = cursor.next(); System.out.println(&quot;通过scan(K key, ScanOptions options)方法获取匹配元素:&quot; + typedTuple.getValue() + &quot;---&gt;&quot; + typedTuple.getScore()); } 14.score(K key, Object o) 获取元素的分值。 double score = redisTemplate.opsForZSet().score(&quot;zSetValue&quot;,&quot;B&quot;); System.out.println(&quot;通过score(K key, Object o)方法获取元素的分值:&quot; + score); 15.zCard(K key)获取变量中元素的个数。 long zCard = redisTemplate.opsForZSet().zCard(&quot;zSetValue&quot;); System.out.println(&quot;通过zCard(K key)方法获取变量的长度:&quot; + zCard); 16.incrementScore(K key, V value, double delta)修改变量中的元素的分值。 double incrementScore = redisTemplate.opsForZSet().incrementScore(&quot;zSetValue&quot;,&quot;C&quot;,5); System.out.print(&quot;通过incrementScore(K key, V value, double delta)方法修改变量中的元素的分值:&quot; + incrementScore); score = redisTemplate.opsForZSet().score(&quot;zSetValue&quot;,&quot;C&quot;); System.out.print(&quot;,修改后获取元素的分值:&quot; + score); zSetValue = redisTemplate.opsForZSet().range(&quot;zSetValue&quot;,0,-1); System.out.println(&quot;，修改后排序的元素:&quot; + zSetValue); 17.reverseRange(K key, long start, long end)索引倒序排列指定区间元素。 zSetValue = redisTemplate.opsForZSet().reverseRange(&quot;zSetValue&quot;,0,-1); System.out.println(&quot;通过reverseRange(K key, long start, long end)方法倒序排列元素:&quot; + zSetValue); 18.reverseRangeByScore(K key, double min, double max)倒序排列指定分值区间元素。 zSetValue = redisTemplate.opsForZSet().reverseRangeByScore(&quot;zSetValue&quot;,1,5); System.out.println(&quot;通过reverseRangeByScore(K key, double min, double max)方法倒序排列指定分值区间元素:&quot; + zSetValue); 19.reverseRangeByScore(K key, double min, double max, long offset, long count)倒序排列从给定下标和给定长度分值区间元素。 zSetValue = redisTemplate.opsForZSet().reverseRangeByScore(&quot;zSetValue&quot;,1,5,1,2); System.out.println(&quot;通过reverseRangeByScore(K key, double min, double max, long offset, long count)方法倒序排列从给定下标和给定长度分值区间元素:&quot; + zSetValue); 20.reverseRangeByScoreWithScores(K key, double min, double max)倒序排序获取RedisZSetCommands.Tuples的分值区间值。 Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = redisTemplate.opsForZSet().reverseRangeByScoreWithScores(&quot;zSetValue&quot;,1,5); iterator = typedTupleSet.iterator(); while (iterator.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next(); Object value = typedTuple.getValue(); double score1 = typedTuple.getScore(); System.out.println(&quot;通过reverseRangeByScoreWithScores(K key, double min, double max)方法倒序排序获取RedisZSetCommands.Tuples的区间值:&quot; + value + &quot;----&gt;&quot; + score1 ); } 21.reverseRangeByScoreWithScores(K key, double min, double max, long offset, long count)倒序排序获取RedisZSetCommands.Tuples的从给定下标和给定长度分值区间值。 Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = redisTemplate.opsForZSet().reverseRangeByScoreWithScores(&quot;zSetValue&quot;,1,5,1,2); iterator = typedTupleSet.iterator(); while (iterator.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next(); Object value = typedTuple.getValue(); double score1 = typedTuple.getScore(); System.out.println(&quot;通过reverseRangeByScoreWithScores(K key, double min, double max, long offset, long count)方法倒序排序获取RedisZSetCommands.Tuples的从给定下标和给定长度区间值:&quot; + value + &quot;----&gt;&quot; + score1 ); } 22.reverseRangeWithScores(K key, long start, long end)索引倒序排列区间值。 Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTupleSet = redisTemplate.opsForZSet().reverseRangeWithScores(&quot;zSetValue&quot;,1,5); iterator = typedTupleSet.iterator(); while (iterator.hasNext()){ ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next(); Object value = typedTuple.getValue(); double score1 = typedTuple.getScore(); System.out.println(&quot;通过reverseRangeWithScores(K key, long start, long end)方法索引倒序排列区间值:&quot; + value + &quot;-----&gt;&quot; + score1); } 23.reverseRank(K key, Object o)获取倒序排列的索引值。 long reverseRank = redisTemplate.opsForZSet().reverseRank(&quot;zSetValue&quot;,&quot;B&quot;); System.out.println(&quot;通过reverseRank(K key, Object o)获取倒序排列的索引值:&quot; + reverseRank); 24.intersectAndStore(K key, K otherKey, K destKey)获取2个变量的交集存放到第3个变量里面。 redisTemplate.opsForZSet().intersectAndStore(&quot;zSetValue&quot;,&quot;typedTupleSet&quot;,&quot;intersectSet&quot;); zSetValue = redisTemplate.opsForZSet().range(&quot;intersectSet&quot;,0,-1); System.out.println(&quot;通过intersectAndStore(K key, K otherKey, K destKey)方法获取2个变量的交集存放到第3个变量里面:&quot; + zSetValue); 25.intersectAndStore(K key, Collection otherKeys, K destKey)获取多个变量的交集存放到第3个变量里面。 List list = new ArrayList(); list.add(&quot;typedTupleSet&quot;); redisTemplate.opsForZSet().intersectAndStore(&quot;zSetValue&quot;,list,&quot;intersectListSet&quot;); zSetValue = redisTemplate.opsForZSet().range(&quot;intersectListSet&quot;,0,-1); System.out.println(&quot;通过intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)方法获取多个变量的交集存放到第3个变量里面:&quot; + zSetValue); 26.unionAndStore(K key, K otherKey, K destKey)获取2个变量的合集存放到第3个变量里面。 redisTemplate.opsForZSet().unionAndStore(&quot;zSetValue&quot;,&quot;typedTupleSet&quot;,&quot;unionSet&quot;); zSetValue = redisTemplate.opsForZSet().range(&quot;unionSet&quot;,0,-1); System.out.println(&quot;通过unionAndStore(K key, K otherKey, K destKey)方法获取2个变量的交集存放到第3个变量里面:&quot; + zSetValue); 27.unionAndStore(K key, Collection otherKeys, K destKey)获取多个变量的合集存放到第3个变量里面。 redisTemplate.opsForZSet().unionAndStore(&quot;zSetValue&quot;,list,&quot;unionListSet&quot;); zSetValue = redisTemplate.opsForZSet().range(&quot;unionListSet&quot;,0,-1); System.out.println(&quot;通过unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)方法获取多个变量的交集存放到第3个变量里面:&quot; + zSetValue); 28.remove(K key, Object… values)批量移除元素根据元素值。 long removeCount = redisTemplate.opsForZSet().remove(&quot;unionListSet&quot;,&quot;A&quot;,&quot;B&quot;); zSetValue = redisTemplate.opsForZSet().range(&quot;unionListSet&quot;,0,-1); System.out.print(&quot;通过remove(K key, Object... values)方法移除元素的个数:&quot; + removeCount); System.out.println(&quot;,移除后剩余的元素:&quot; + zSetValue); 29.removeRangeByScore(K key, double min, double max)根据分值移除区间元素。 removeCount = redisTemplate.opsForZSet().removeRangeByScore(&quot;unionListSet&quot;,3,5); zSetValue = redisTemplate.opsForZSet().range(&quot;unionListSet&quot;,0,-1); System.out.print(&quot;通过removeRangeByScore(K key, double min, double max)方法移除元素的个数:&quot; + removeCount); System.out.println(&quot;,移除后剩余的元素:&quot; + zSetValue); 30.removeRange(K key, long start, long end)根据索引值移除区间元素。 removeCount = redisTemplate.opsForZSet().removeRange(&quot;unionListSet&quot;,3,5); zSetValue = redisTemplate.opsForZSet().range(&quot;unionListSet&quot;,0,-1); System.out.print(&quot;通过removeRange(K key, long start, long end)方法移除元素的个数:&quot; + removeCount); System.out.println(&quot;,移除后剩余的元素:&quot; + zSetValue); RedisTemplate实践一参赛号的自增，利用自增获取参赛号的值，写入对象存库。 //参赛号为空，且起始值大于-1 if (StringUtils.isEmpty(enrollMatch.getSeq()) &amp;&amp; match.getSeqStart() &gt; -1) { //第一次参赛证生成 //判断redis里面是否有对应的比赛的key,如果没有， //执行redisTemplate.opsForHash().increment(&quot;match_seq&quot;, match.get_id(), match.getSeqStart()); //在起始参赛号自增1。 //redisTemplate.opsForHash().hasKey(&quot;match_seq&quot;, match.get_id()) if (!redisTemplate.opsForHash().hasKey(&quot;match_seq&quot;, match.get_id())) redisTemplate.opsForHash().increment(&quot;match_seq&quot;, match.get_id(), match.getSeqStart()); //非第一次 long num = redisTemplate.opsForHash().increment(&quot;match_seq&quot;, match.get_id(), 1); String numStr = &quot;&quot; + num; while (numStr.length() &lt; 5) // 凑够长度5 numStr = &quot;0&quot; + numStr; String seq = match.getSeqPrefix() + numStr; } 参赛证分配 数据结构：系统可以针对比赛设置赛区；赛区里设置考场，如第一考场，第二考场等；考场里设置有座位号，每个考场座位号从1开始，座位号个数可以系统设置。 需求：给每个参赛选手分配座位号。 实现过程： //查询所有需要分配考场座位的记录。根据比赛阶段（复赛，线下形式），已交报名费，已选赛点，未分配考场。 List&lt;MenrollPhase&gt; menrollPhaseList = mongoTemplate.find(Query.query(Criteria.where(&quot;phaseId&quot;).is(phaseId).and(&quot;state&quot;).is(2).and(&quot;matchPlaceId&quot;).ne(null).ne(&quot;&quot;).and(&quot;matchPlaceRoomId&quot;).in(null,&quot;&quot;)).with(new Sort(&quot;_id&quot;, &quot;ASC&quot;)), MenrollPhase.class); //查询比赛是否设置赛区、需要分配考场的记录不为空且size大于0 if(mphase.getMatchPlaceIds()!=null&amp;&amp;menrollPhaseList!=null&amp;&amp;menrollPhaseList.size()&gt;0){ lineNumber=menrollPhaseList.size();//要生成参赛证总数 //查询该比赛所有赛区 List&lt;MmatchPlace&gt; mmatchPlaceList = mongoTemplate.find(Query.query(Criteria.where(&quot;_id&quot;).in(mphase.getMatchPlaceIds())), MmatchPlace.class); if(mmatchPlaceList!=null&amp;&amp;mmatchPlaceList.size()&gt;0){ ListOperations&lt;String, Object&gt; lo = redisTemplate.opsForList(); //循环遍历赛区，将考场设置到赛区中 for(MmatchPlace mmatchPlace : mmatchPlaceList){ List&lt;MmatchPlaceRoom&gt; mmatchPlaceRoomList = mongoTemplate.find(Query.query(Criteria.where(&quot;placeId&quot;).in(mmatchPlace.get_id())).with(new Sort(&quot;order&quot;, &quot;ASC&quot;)), MmatchPlaceRoom.class); mmatchPlace.setMmatchPlaceRooms(mmatchPlaceRoomList); } //参赛证模板 String[] temp = mphase.getCertTpl().split(&quot;\\|&quot;); //文件名 String fileName = temp[2]; String quchu=null; //加锁，分布式环境下只能有一个线程去考场获取座位号 boolean groupAbsent = redisTemplate.opsForValue().setIfAbsent(&quot;placeRoom_&quot; + mphase.get_id(), &quot;roomsuo&quot;); //groupAbsent为true 可以执行当前代码 if(groupAbsent){ //遍历赛区 for(MmatchPlace mmatchPlace : mmatchPlaceList){ //比赛和赛区id共同组成key String mmatchPlaceIdKey = &quot;matchPlace_&quot; +mphase.get_id()+mmatchPlace.get_id(); //首次分配 if(!redisTemplate.hasKey(mmatchPlaceIdKey)&amp;&amp;mmatchPlace.getMmatchPlaceRooms()!=null&amp;&amp;mmatchPlace.getMmatchPlaceRooms().size()&gt;0){ //遍历赛区下的考场，考场id和座位号共同组成value，赛区为key,考场和座位为value中间以“，”隔开，存入 //redis。 for(MmatchPlaceRoom mmatchPlaceRoom : mmatchPlace.getMmatchPlaceRooms()){ for(int i=0;i&lt;mmatchPlaceRoom.getCounts();i++){ String placeValue = mmatchPlaceRoom.get_id()+&quot;,&quot;+(i+1); lo.leftPush(mmatchPlaceIdKey, placeValue);//存入redis } } } } checkStatus=1;//准备考场已经结束 //开始分考场 for(MenrollPhase menrollPhase : menrollPhaseList){ if(!StringUtils.isEmpty(menrollPhase.getMatchPlaceId())&amp;&amp;StringUtils.isEmpty(menrollPhase.getMatchPlaceRoomId())){ for(MmatchPlace mmatchPlace : mmatchPlaceList){ if(mmatchPlace.get_id().equals(menrollPhase.getMatchPlaceId())){ //取出分配好的座位 quchu = (String) lo.rightPop(&quot;matchPlace_&quot; +mphase.get_id()+mmatchPlace.get_id()); //redis里面没有说明已经取出了。 if(StringUtils.isEmpty(quchu)){ continue; } String[] tempNum = quchu.split(&quot;,&quot;); String roomId = tempNum[0];//考场Id String numBer = tempNum[1];//座位号 for(MmatchPlaceRoom mmatchPlaceRoom : mmatchPlace.getMmatchPlaceRooms()){ if(mmatchPlaceRoom.get_id().equals(roomId)){ //将取出的考场和座位号存入对象写入数据库 menrollPhase.setMatchPlaceRoomId(mmatchPlaceRoom.get_id()); menrollPhase.setMatchPlaceRoomNum(Integer.valueOf(numBer)); mongoTemplate.save(menrollPhase); menrollPhase.setMatchPlace(mmatchPlace); menrollPhase.setMatchPlaceRoom(mmatchPlaceRoom); } } } } } } } //删除锁 redisTemplate.delete(&quot;placeRoom_&quot; + mphase.get_id()); //开始生成参赛证 try{ caseCount=0; this.getDetails(menrollPhaseList); //方法一：使用Windows系统字体(TrueType) BaseFont baseFont = BaseFont.createFont(path+&quot;WEB-INF/template/SIMSUN.TTC,1&quot;,BaseFont.IDENTITY_H,BaseFont.NOT_EMBEDDED); for(MenrollPhase menrollPhase : menrollPhaseList){ if(!StringUtils.isEmpty(menrollPhase.getMatchPlaceId()) &amp;&amp;!StringUtils.isEmpty(menrollPhase.getMatchPlaceRoomId()) &amp;&amp;menrollPhase.getMatchPlaceRoomNum()!=0){ boolean isOk = checkedCarState(menrollPhase); if(!isOk){ continue; } PdfReader reader = new PdfReader(fileName); ByteArrayOutputStream bos = new ByteArrayOutputStream(); PdfStamper ps = new PdfStamper(reader, bos); AcroFields fields = ps.getAcroFields(); fields.addSubstitutionFont(baseFont); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); fillMap(map,menrollPhase); fillData(fields, map); ps.setFormFlattening(true); ps.close(); byte[] bytes = bos.toByteArray(); String base = Base64Util.encode(bytes).trim(); redisTemplate.opsForHash().put(&quot;cansai_&quot;+phaseId,menrollPhase.get_id(), base); caseCount++; } } contectStatus=1;//参赛证生成结束 }catch (IOException|DocumentException e) { e.printStackTrace(); } } } Redis分布式锁解决抢购问题先新建一个RedisLock类： public class RedisService { @Autowired private RedisTemplate stringRedisTemplate; /*** * 加锁 * @param key * @param value 当前时间+超时时间 * @return 锁住返回true */ public boolean lock(String key,String value){ if(stringRedisTemplate.opsForValue().setIfAbsent(key,value)){//setNX 返回boolean return true; } //如果锁超时 *** String currentValue = stringRedisTemplate.opsForValue().get(key); if(!StringUtils.isEmpty(currentValue) &amp;&amp; Long.parseLong(currentValue)&lt;System.currentTimeMillis()){ //获取上一个锁的时间 String oldvalue = stringRedisTemplate.opsForValue().getAndSet(key,value); if(!StringUtils.isEmpty(oldvalue)&amp;&amp;oldvalue.equals(currentValue)){ return true; } } return false; } /*** * 解锁 * @param key * @param value * @return */ public void unlock(String key,String value){ try { String currentValue = stringRedisTemplate.opsForValue().get(key); if(!StringUtils.isEmpty(currentValue)&amp;&amp;currentValue.equals(value)){ stringRedisTemplate.opsForValue().getOperations().delete(key); } } catch (Exception e) { log.error(&quot;解锁异常&quot;); } } } 首先，锁的value值是当前时间加上过期时间的时间戳，Long类型。首先看到用setiFAbsent方法也就是对应的SETNX，在没有线程获得锁的情况下可以直接拿到锁，并返回true也就是加锁，最后没有获得锁的线程会返回false。 最重要的是中间对于锁超时的处理，如果没有这段代码，当秒杀方法发生异常的时候，后续的线程都无法得到锁，也就陷入了一个死锁的情况。我们可以假设CurrentValue为A，并且在执行过程中抛出了异常，这时进入了两个value为B的线程来争夺这个锁，也就是走到了注释*的地方。currentValue==A，这时某一个线程执行到了getAndSet(key,value)函数(某一时刻一定只有一个线程执行这个方法，其他要等待)。这时oldvalue也就是之前的value等于A，在方法执行过后，oldvalue会被设置为当前的value也就是B。这时继续执行，由于oldValue==currentValue所以该线程获取到锁。而另一个线程获取的oldvalue是B，而currentValue是A，所以他就获取不到锁啦。 业务代码： private static final int TIMEOUT= 10*1000; @Transactional public void orderProductMockDiffUser(String productId){ long time = System.currentTimeMillions()+TIMEOUT; if(!redislock.lock(productId,String.valueOf(time)){ throw new SellException(101,&quot;换个姿势再试试&quot;) } //1.查库存 int stockNum = stock.get(productId); if(stocknum == 0){ throw new SellException(ProductStatusEnum.STOCK_EMPTY); //这里抛出的异常要是运行时异常，否则无法进行数据回滚，这也是spring中比较基础的 }else{ //2.下单 orders.put(KeyUtil.genUniqueKey(),productId);//生成随机用户id模拟高并发 sotckNum = stockNum-1; try{ Thread.sleep(100); } catch (InterruptedExcption e){ e.printStackTrace(); } stock.put(productId,stockNum); } redisLock.unlock(productId,String.valueOf(time)); }]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP概述和URL]]></title>
    <url>%2F2018%2F12%2F10%2Fhttps%2F</url>
    <content type="text"><![CDATA[引言HTTP协议，一个熟悉又陌生的应用协议。熟悉的是它在各种计算机网络教材中必然会被提及的应用层协议，稍微有点计算机知识的人基本上都会听过这个协议。它是互联网的基础，可以这么说，没有HTTP协议，就没有当前互联网的蓬勃发展。然而，笔者对它又是陌生的。因为虽然参与开发了不少Web应用，但很少直接与HTTP协议直接打交道，因为Web容器隐藏了很多HTTP协议的细节（譬如：请求协议头的解析，响应报文的生成），使得上层开发不用关心HTTP即可以开发出可用的Web应用。不应该仅仅满足可用，还应该让应用更加高效，这促使我不得不去研究HTTP协议。私以为，如果想进一步提升自己的技术能力，必须要深入到协议层级别，一些平时感觉到莫名其妙的问题就可以迎刃而解。 最近阅读了《HTTP权威指南》一书，本文包含书中的核心要点、个人延伸以及个人操作实践。由于本书是2009年出版，距现在已经有6年之久，期间，HTTP协议本身也不断地发展。所以，一些老旧的知识点将不会出现在本文中。希望通过不断阅读和实践，并且记录下来，能够加深对HTTP协议本身的理解！ HTTP协议概述本节介绍一些HTTP的基础知识，先对HTTP有一个宏观上的了解。 HTTP协议是什么平常老看到TCP/IP协议、FTP协议，XX协议……不禁要问，到底什么是协议？查阅了百度百科，上面是这么定义的： 基本解释：共同计议；协商法律范畴：协议是指两个或两个以上实体为了开展某项活动，经过协商后双方达成的一致意见。 两个要点： 1. 两个及两个以上参与者。也就是说，如果只有一方参与，根本就不会涉及到协议。 2. 协商一致。也就是说，所有参与方都必须同意并且遵守，才能使得活动能正常运行下去。 上面讲的一般意义上的协议，在计算机领域中，我们讲的协议一般是指通信协议，它仍然遵循上面的要点。首先，通信必然涉及到多方参与；其次，如果有一方不遵守协议，则根本没法进行有效通信。 下面来看看啥是HTTP协议，百度百科：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。 HTTP协议的特点下面从这篇博客中转过来的HTTP协议的特点，这篇文章对HTTP做了很全面的介绍，值得一读。 支持客户/服务器模式。支持基本认证和安全认证。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 HTTP 0.9和1.0使用非持续连接（无连接性）：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大 特别直接说明的是HTTP的连接性。在我以前的认识里，HTTP最重要的特性是无连接性和无状态性。所谓无连接性，是指每一次请求都使用新的连接，请求完毕后连接关闭。这样做最大的好处时，最大程度上减少空闲连接占用服务端资源，这在系统资源比较昂贵、页面比较简单、仅传输静态页面的年代确实是非常合理的。但是，随着电商、视频等富媒体Web应用的兴起，HTTP的无连接性制约了系统的性能。一个Web应用动辄上百张图片，每一张图片都要占用一个网络连接。要知道，每新建一个连接都需要在TCP协议层进行“三次握手”，效率非常低下。随着在HTTP v1.1版本中默认采用Keep-Alive，多个请求可以使用同一个连接，HTTP的无连接性描述已经变得不准确了。 版本变化 HTTP/0.9 已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。 HTTP/1.0 这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。 HTTP/1.1 当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。 URL与资源什么是URLURL（Uniform Resource Location, 统一资源定位符）是Internet上的所有资源的标准化名称。可以把Internet看做一个巨大的正在扩张的城市，里面充满了各种可看的东西，可做的事情。我们需要为这个城市里面的所有景点和服务起一个名字，所有的名字必须在符合统一的标准，这样才能使得我们方便地使用这座城市的宝藏。URL就是其中一类重要的资源命名方式。URL指向每一条电子信息，告诉你它位于何处，如何与之进行交互。URL必须是唯一的，也就是说，一个URL只能对应唯一的资源。 URI、URL和URN说起URL，就必然要提URI和URN。那么它们之间到底有什么联系和区别呢？首先来看看URI和URN是什么。 URI：即Uniform Resource Identifier，统一资源标识符。它是一个通用的概念，理论上，能保证资源全局唯一性的标识符都可以叫做URI； URN：即Uniform Resource Name,统一资源名称。这样的资源名是与资源具体的位置无关的。 URI、URL、URN是相互关联的。URL和URN都是URI的子集，按照集合论的观点，它们之间的关系见下图。 也就说，任何的URL都可以是URI，反之不然。URL是与资源所处的位置密切相关的，如果资源挪动位置，则必然导致URL跟着一起变化。想象一下，如果资源换了位置（虽然这极少发生），则原来开发的软件就会失效。URN主要就是为了解决这个问题而提出来的。它通过给资源命名而不是定位来唯一地确定资源。 假定现在要给我起个独一无二的名称，我可以自己命名为此时我所处的地理位置,假设是(东经36度，北纬36度)。好了，现在请叫我(东经36度，北纬36度)，通过地图肯定可以找到我。然而，我并不是时时刻刻都呆着这里的，因为我是个活人。当我移动位置之后，通过原来的位置定位到的已然不是我了，这就很麻烦了。如果用我的姓名来找我（假设是独一无二的），则无论何时何地找到的都是我了。 目前来说，URN貌似还没能到实用阶段，看上去用处也不大。一则资源位置一般不会发生变动；二则URL已经完全普及，为啥要抛弃已经用得溜溜的东西呢？！至少目前还没有理由这么干。所以，在《HTTP权威指南》一书中，并没有将URI和URL区分开来，所有的URI都可以看做是URL。 URL的完整语法在Web应用中，URL通常是由3各部分构成，以URL地址http://www.joes.com/seanonal/index.html为例来进行说明。 第一部分(http)是方案（schema），可以告知客户端怎样访问资源。 第二部分(www.joes.com)是服务器的位置，告知客户端资源位于何处。 第三部分（/seanonal/index.html）是资源路径。 上面的URL地址只是众多格式的URL地址中的一种，实际上，URL还可以通过HTTP以外的其他协议来进行访问。比如个人E-mail账户： ikangbow@outlook.com 或者是通过FTP协议获取文件： ftp://ftp.xxx.com/file.xls 咋一看，这些URL的格式都不太一样，这是不是意味着每种不同的URL方案会有完全不同的语法呢？其实不然。大多数URL语法都建立在9个部分构成的通用格式上： schema://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;&lt;/pre&gt; 每一部分的的意义如下： schema：获取资源时使用何种协议 user：访问资源时需要的用户名 password：访问资源时与用户名配套的密码 host：资源所在的服务器地址 port：服务器所监听的端口 path：服务器上的本地资源路径，用/分隔 params：指定输入参数，用key/value表示 query：资源查询参数 frag：资源内部的片段名字 URL通常会由其中的某些部分组合而成，下面是一些URL典型示例： http://www.joes.com/seanonal/index.html file:///D:/relativeUrl.html ftp://username:password@ftp.xxx.com/file.xls http://www.joes.com/seanonal/index.html;type=d http://www.joes.com/seanonal/goods.html?item=45454 http://www.joes.com/seanonal/goods.html?item=45454#name 相对URL 绝对URL和相对URL是URL的两种不同的表现形式，前面所有的URL示例都是绝对URL，绝对URL包含访问资源所需的全部资源。下面是一个简单的HTML页面代码，其中的page1就是一个包含相对URL的链接。 相对URL是不完整的，要获取资源的全部信息，还要依赖称为基础（base）的URL。基础URL通常来自以下地方： 第一，在资源中显示提供。在HTML文档中，可以由标签定义一个基础URL。下面的代码定义了&lt;base href=”http://www.demo.com/base/“ &gt; ，于是，page2实际的绝对地址就是：http://www.demo.com/base/page2.html。 第二，所属资源的URL作为基础URL。还是以上面的代码为例。假定page1.html的绝对URL是http://www.demo.com/page1.html，那么page1.html属于http://www.demo.com/资源下的。直接用这个地址作为基础URL，则page2的绝对URL是：http://www.demo.com/page2.html。 第三，没有基础URL。注：这里没有看懂，先列在这里…… #URL编码 合格的URL应该满足下面的要求： 可移植性：作为统一的命名，应该要能够通过不同的协议来传送资源。不同的协议可能会有特定的保留字符，在不同的协议中传输时，不应该因为这些特殊字符而丢失信息。 可读性：不可见的、不可打印的（比如空格）字符不应该出现在URL中。 完整性：可能需要通用字符外的二进制数据或字符，因此需要一种转义机制，将不安全的字符编码为安全字符。 从历史来看，计算机应用程序都是用US-ASCII字符集^footnote。由于其历史悠久，所以可移植性很好。但是它不支持数百种非罗马语言中的字符。这就需要一套转义编码机制，用US-ASCII字符集来对任意字符进行编码。目前设计的转义表示法是用一个“%”，后面跟着两个表示ASCII码的十六进制数。下面是一些编码示例： 从历史来看，计算机应用程序都是用US-ASCII字符集^footnote。由于其历史悠久，所以可移植性很好。但是它不支持数百种非罗马语言中的字符。这就需要一套转义编码机制，用US-ASCII字符集来对任意字符进行编码。目前设计的转义表示法是用一个“%”，后面跟着两个表示ASCII码的十六进制数。下面是一些编码示例： #总结本文是《HTTP权威指南》学习笔记的第一篇，介绍一些HTTP中的基本概念和概述。重点介绍了URL（统一资源定位符）这一种最重要的Web资源命名方式，将其与URI、URN这类经常混淆的概念进行的比较。概要说明了URL的语法格式、相对URL和URL编码。首先对HTTP有一个整体上的认识，接下来要写的是HTTP中的重要细节内容，与日常的开发密切相关。]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
</search>
