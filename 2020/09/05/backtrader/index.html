<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="投资,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Backtrader引言前基于Python的量化回测框架有很多，开源框架有zipline、vnpy、pyalgotrader和backtrader等，而量化平台有Quantopian（国外）、聚宽、万矿、优矿、米筐、掘金等，这些量化框架或平台各有优劣。就个人而言，比较偏好用backtrader，因为它功能十分完善，有完整的使用文档，安装相对简单（直接pip安装即可）。优点是运行速度快，支持pand">
<meta name="keywords" content="投资">
<meta property="og:type" content="article">
<meta property="og:title" content="backtrader">
<meta property="og:url" content="http://yoursite.com/2020/09/05/backtrader/index.html">
<meta property="og:site_name" content="Airthink">
<meta property="og:description" content="Backtrader引言前基于Python的量化回测框架有很多，开源框架有zipline、vnpy、pyalgotrader和backtrader等，而量化平台有Quantopian（国外）、聚宽、万矿、优矿、米筐、掘金等，这些量化框架或平台各有优劣。就个人而言，比较偏好用backtrader，因为它功能十分完善，有完整的使用文档，安装相对简单（直接pip安装即可）。优点是运行速度快，支持pand">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/09/05/backtrader/批注%202020-09-06%20181654.png">
<meta property="og:image" content="http://yoursite.com/2020/09/05/backtrader/批注%202020-09-06%20183530.png">
<meta property="og:image" content="http://yoursite.com/2020/09/05/backtrader/批注%202020-09-06%20183419.png">
<meta property="og:image" content="http://yoursite.com/2020/09/05/backtrader/批注%202020-09-06%20183823.png">
<meta property="og:image" content="http://yoursite.com/2020/09/05/backtrader/批注%202020-09-06%20184322.png">
<meta property="og:updated_time" content="2021-03-15T12:51:08.425Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="backtrader">
<meta name="twitter:description" content="Backtrader引言前基于Python的量化回测框架有很多，开源框架有zipline、vnpy、pyalgotrader和backtrader等，而量化平台有Quantopian（国外）、聚宽、万矿、优矿、米筐、掘金等，这些量化框架或平台各有优劣。就个人而言，比较偏好用backtrader，因为它功能十分完善，有完整的使用文档，安装相对简单（直接pip安装即可）。优点是运行速度快，支持pand">
<meta name="twitter:image" content="http://yoursite.com/2020/09/05/backtrader/批注%202020-09-06%20181654.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/05/backtrader/">





  <title>backtrader | Airthink</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Airthink</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/backtrader/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">backtrader</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T20:31:54+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/投资/" itemprop="url" rel="index">
                    <span itemprop="name">投资</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Backtrader"><a href="#Backtrader" class="headerlink" title="Backtrader"></a>Backtrader</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前基于Python的量化回测框架有很多，开源框架有zipline、vnpy、pyalgotrader和backtrader等，而量化平台有Quantopian（国外）、聚宽、万矿、优矿、米筐、掘金等，这些量化框架或平台各有优劣。就个人而言，比较偏好用backtrader，因为它功能十分完善，有完整的使用文档，安装相对简单（直接pip安装即可）。优点是运行速度快，支持pandas的矢量运算；支持参数自动寻优运算，内置了talib股票分析技术指标库；支持多品种、多策略、多周期的回测和交易；支持pyflio、empyrica分析模块库、alphalens多因子分析模块库等；扩展灵活，可以集成TensorFlow、PyTorch和Keras等机器学习、神经网络分析模块。而不足之处在于，backtrader学习起来相对复杂，编程过程中使用了大量的元编程（类class），如果Python编程基础不扎实（尤其是类的操作），学起来会感到吃力。本文作为backtrader的入门系列之一，对其运行框架进行简要介绍，并以实际案例展示量化回测的过程。</p>
<h2 id="Backtrader介绍"><a href="#Backtrader介绍" class="headerlink" title="Backtrader介绍"></a>Backtrader介绍</h2><p>如果将backtrader包分解为核心组件，主要包括以下组成部分：</p>
<ol>
<li>数据加载（Data Feed）：将交易策略的数据加载到回测框架中。</li>
<li>交易策略（Strategy）：该模块是编程过程中最复杂的部分，需要设计交易决策，得出买入/卖出信号。</li>
<li>回测框架设置（ Cerebro）：需要设置（i）初始资金（ii）佣金（iii）数据馈送（iv）交易策略交易头寸大小。</li>
<li>运行回测：运行Cerebro回测并打印出所有已执行的交易。</li>
<li>评估性能（Analyzers）:以图形和风险收益等指标对交易策略的回测结果进行评价。</li>
</ol>
<p>“Lines”是backtrader回测的数据，由一系列的点组成，通常包括以下类别的数据：Open（开盘价）, High（最高价）, Low（最低价）, Close（收盘价）, Volume（成交量）, OpenInterest（无的话设置为0）。Data Feeds（数据加载）、Indicators（技术指标）和Strategies（策略）都会生成 Lines。价格数据中的所有”Open” (开盘价)按时间组成一条 Line。所以，一组含有以上6个类别的价格数据，共有6条 Lines。如果算上“DateTime”（时间，可以看作是一组数据的主键），一共有7条 Lines。当访问一条 Line 的数据时，会默认指向下标为 0 的数据。最后一个数据通过下标 -1 来访问，在-1之后是索引0，用于访问当前时刻。因此，在回测过程中，无需知道已经处理了多少条/分钟/天/月，”0”一直指向当前值，下标 -1 来访问最后一个值。</p>
<p><img src="/2020/09/05/backtrader/批注 2020-09-06 181654.png" alt=""></p>
<h2 id="Backtrader环境搭建"><a href="#Backtrader环境搭建" class="headerlink" title="Backtrader环境搭建"></a>Backtrader环境搭建</h2><ul>
<li>安装python环境 (anaconda)</li>
<li>pip install backtrader[plotting]</li>
<li>新建jupyterProject文件夹，在其路径栏输入 jupyter lab,按enter键,等待启用jupyter</li>
</ul>
<h2 id="回测应用实例"><a href="#回测应用实例" class="headerlink" title="回测应用实例"></a>回测应用实例</h2><p>量化回测说白了是使用历史数据去验证交易策略的性能，因此回测的第一步是搭建交易策略，这也是backtrader要设置的最重要和复杂的部分，策略设定好后，其余部分的代码编写是手到擒来。</p>
<h3 id="构建策略（Strategy）"><a href="#构建策略（Strategy）" class="headerlink" title="构建策略（Strategy）"></a>构建策略（Strategy）</h3><p>交易策略类代码包含重要的参数和用于执行策略的功能，要定义的参数或函数名如下：</p>
<p>（1）params-全局参数，可选：更改交易策略中变量/参数的值，可用于参数调优。</p>
<p>（2）log：日志，可选：记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。</p>
<p>（3） <strong>init</strong>：用于初始化交易策略的类实例的代码。</p>
<p>（4）notify_order，可选：跟踪交易指令（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。</p>
<p>（5）notify_trade，可选：跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。</p>
<p>（6）next，必选：制定交易策略的函数，策略模块最核心的部分。</p>
<p>下面以一个简单的单均线策略为例，展示backtrader的使用过程，即当收盘价上涨突破20日均线买入（做多），当收盘价下跌跌穿20日均线卖出（做空）。为简单起见，不报告交易回测的日志，因此log、notify_order和notify_trade函数省略不写。</p>
<pre><code>class my_strategy1(bt.Strategy):
    #全局设定交易策略的参数
    params=(
        (&apos;maperiod&apos;,20),
           )

    def __init__(self):
        #指定价格序列
        self.dataclose=self.datas[0].close
        # 初始化交易指令、买卖价格和手续费
        self.order = None
        self.buyprice = None
        self.buycomm = None

        #添加移动均线指标，内置了talib模块
        self.sma = bt.indicators.SimpleMovingAverage(
                      self.datas[0], period=self.params.maperiod)
    def next(self):
        if self.order: # 检查是否有指令等待执行, 
            return
        # 检查是否持仓   
        if not self.position: # 没有持仓
            #执行买入条件判断：收盘价格上涨突破20日均线
            if self.dataclose[0] &gt; self.sma[0]:
                #执行买入
                self.order = self.buy(size=500)         
        else:
            #执行卖出条件判断：收盘价格跌破20日均线
            if self.dataclose[0] &lt; self.sma[0]:
                #执行卖出
                self.order = self.sell(size=500)
</code></pre><h3 id="数据加载（Data-Feeds）"><a href="#数据加载（Data-Feeds）" class="headerlink" title="数据加载（Data Feeds）"></a>数据加载（Data Feeds）</h3><p>策略设计好后，第二步是数据加载，backtrader提供了很多数据接口，包括quandl（美股）、yahoo、pandas格式数据等，我们主要分析A股数据。</p>
<pre><code>#先引入后面可能用到的包（package）
import pandas as pd  
from datetime import datetime
import backtrader as bt
import matplotlib.pyplot as plt
%matplotlib inline   

#正常显示画图时出现的中文和负号
from pylab import mpl
mpl.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;]使用tushare获取浦发银行（代码：600000）数据。
#使用tushare旧版接口获取数据
import tushare as ts 
def get_data(code,start=&apos;2010-01-01&apos;,end=&apos;2020-03-31&apos;):
    df=ts.get_k_data(code,autype=&apos;qfq&apos;,start=start,end=end)
    df.index=pd.to_datetime(df.date)
    df[&apos;openinterest&apos;]=0
    df=df[[&apos;open&apos;,&apos;high&apos;,&apos;low&apos;,&apos;close&apos;,&apos;volume&apos;,&apos;openinterest&apos;]]
    return df
dataframe=get_data(&apos;600000&apos;)

#回测期间
start=datetime(2010, 3, 31)
end=datetime(2020, 3, 31)
# 加载数据
data = bt.feeds.PandasData(dataname=dataframe,fromdate=start,todate=end)
</code></pre><h3 id="回测设置（Cerebro）"><a href="#回测设置（Cerebro）" class="headerlink" title="回测设置（Cerebro）"></a>回测设置（Cerebro）</h3><p>回测设置主要包括几项：回测系统初始化，数据加载到回测系统，添加交易策略， broker设置（如交易资金和交易佣金），头寸规模设置作为策略一部分的交易规模等，最后显示执行交易策略时积累的总资金和净收益。</p>
<h1 id="初始化cerebro回测系统设置"><a href="#初始化cerebro回测系统设置" class="headerlink" title="初始化cerebro回测系统设置"></a>初始化cerebro回测系统设置</h1><p>cerebro = bt.Cerebro()  </p>
<p>#将数据传入回测系统<br>cerebro.adddata(data) </p>
<h1 id="将交易策略加载到回测系统中"><a href="#将交易策略加载到回测系统中" class="headerlink" title="将交易策略加载到回测系统中"></a>将交易策略加载到回测系统中</h1><p>cerebro.addstrategy(my_strategy1) </p>
<h1 id="设置初始资本为10-000"><a href="#设置初始资本为10-000" class="headerlink" title="设置初始资本为10,000"></a>设置初始资本为10,000</h1><p>startcash = 10000<br>cerebro.broker.setcash(startcash) </p>
<h1 id="设置交易手续费为-0-2"><a href="#设置交易手续费为-0-2" class="headerlink" title="设置交易手续费为 0.2%"></a>设置交易手续费为 0.2%</h1><p>cerebro.broker.setcommission(commission=0.002) </p>
<h3 id="执行回测"><a href="#执行回测" class="headerlink" title="执行回测"></a>执行回测</h3><p>输出回测结果。</p>
<pre><code>print(f&apos;净收益: {round(pnl,2)}&apos;)

d1=start.strftime(&apos;%Y%m%d&apos;)
d2=end.strftime(&apos;%Y%m%d&apos;)
print(f&apos;初始资金: {startcash}\n回测期间：{d1}:{d2}&apos;)
#运行回测系统
cerebro.run()
#获取回测结束后的总资金
portvalue = cerebro.broker.getvalue()
pnl = portvalue - startcash
#打印结果
print(f&apos;总资金: {round(portvalue,2)}&apos;)结果如下：
初始资金: 10000
回测期间：20100331:20200331
总资金: 12065.36
净收益: 2065.36
</code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>对上述结果进行可视化，使用内置的matplotlib画图。至此，简单的单均线回测就完成了。下面图形展示了浦发银行在回测期间的价格走势、买卖点和交易总资金的变化等。</p>
<pre><code># 画图
cerebro.plot()
</code></pre><h2 id="回测实例"><a href="#回测实例" class="headerlink" title="回测实例"></a>回测实例</h2><pre><code>from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey

class TestStrategy(bt.Strategy):

    params = (
        (&apos;exitbars&apos;, 5),
        (&apos;maperiod&apos;, 24),
        (&apos;printlog&apos;, False),
    )

    def log(self, txt, dt=None, doprint=False):
        &apos;&apos;&apos; Logging function for this strategy&apos;&apos;&apos;
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print(&apos;[%s] %s&apos; % (dt.isoformat(), txt))

    def __init__(self):
       # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close
        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None
        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)

        # Indicators for the plotting show
        bt.indicators.ExponentialMovingAverage(self.datas[0], period=25)
        bt.indicators.WeightedMovingAverage(
            self.datas[0], period=25).subplot = True
        bt.indicators.StochasticSlow(self.datas[0])
        bt.indicators.MACDHisto(self.datas[0])
        rsi = bt.indicators.RSI(self.datas[0])
        bt.indicators.SmoothedMovingAverage(rsi, period=10)
        bt.indicators.ATR(self.datas[0]).plot = False

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &apos;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log(&apos;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&apos;Order Canceled/Margin/Rejected&apos;)

        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log(&apos;OPERATION PROFIT： GROSS %.2f, NET %.2f&apos; %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log(&apos;Close: %.2f&apos; % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

       # Check if we are in the market
        if not self.position:
            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] &gt; self.sma[0]:
                # current close less than previous close
                if self.dataclose[-1] &lt; self.dataclose[-2]:
                    # previous close less than the previous close

                    # BUY, BUY, BUY!!! (with default parameters)
                    self.log(&apos;BUY CREATE: %.2f&apos; % self.dataclose[0])

                    # Keep track of the created order to avoid a 2nd order
                    self.order = self.buy()
        else:
            # Already in the market ... we might sell
            if self.dataclose[0] &lt; self.sma[0]:
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log(&apos;SELL CREATE: %.2f&apos; % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

    def stop(self):
        self.log(&apos;(MA Period %2d) Ending Value %.2f&apos; %
                 (self.params.maperiod, self.broker.getvalue()), doprint=True)


if __name__ == &apos;__main__&apos;:
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)
    # cerebro.optstrategy(TestStrategy, maperiod=range(10, 31))

    # 初始化数据的路径
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, &apos;.\\/datas\\/orcl-1995-2014.txt&apos;)
    # Create a Data Feed,reverse 代表是否反转数据
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values after this date
        todate=datetime.datetime(2000, 12, 31),
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)
    # 改变账户初始金额
    cerebro.broker.set_cash(100000.0)

    # Set the commission - 0.1% ... divide by 100 to remove the % 交易佣金设置
    cerebro.broker.setcommission(commission=0.001)
    # 设置每笔交易交易的股票数量
    cerebro.addsizer(bt.sizers.FixedSize, stake=10)

    print(&apos;Starting Portfolio Value: %.2f&apos; % cerebro.broker.getvalue())

    cerebro.run()

    print(&apos;Final Portfolio Value: %.2f&apos; % cerebro.broker.getvalue())
    # 画图
    cerebro.plot()
</code></pre><p>先来回顾一下交易策略模块（Strategy）的构成。交易策略类代码包含参数或函数名如下：</p>
<p>（1）params-全局参数，可选：更改交易策略中变量/参数的值，可用于参数调优。</p>
<p>（2）log：日志，可选：记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。</p>
<p>（3） init：用于初始化交易策略的类实例的代码。</p>
<p>（4）notify_order，可选：跟踪交易指令（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。</p>
<p>（5）notify_trade，可选：跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。</p>
<p>（6）next，必选：制定交易策略的函数，策略模块最核心的部分。</p>
<p>下面仍然以简单均线策略为例，重点介绍参数寻优和交易日志报告。</p>
<p>实现代码如下：</p>
<pre><code>#先引入后面可能用到的包（package）
import pandas as pd  
import numpy as np
import tushare as ts 
import matplotlib.pyplot as plt
%matplotlib inline   
#正常显示画图时出现的中文和负号
from pylab import mpl
mpl.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;]
mpl.rcParams[&apos;axes.unicode_minus&apos;]=False
</code></pre><p>params是全局参数，maperiod是MA均值的长度，默认15天，printlog为打印交易日志，默认不输出结果，策略模块的核心在next（）函数。</p>
<pre><code>from datetime import datetime
import backtrader as bt
class MyStrategy(bt.Strategy):
    params=((&apos;maperiod&apos;,15),
            (&apos;printlog&apos;,False),)
    def __init__(self):
        #指定价格序列
        self.dataclose=self.datas[0].close
        # 初始化交易指令、买卖价格和手续费
        self.order = None
        self.buyprice = None
        self.buycomm = None
        #添加移动均线指标
        self.sma = bt.indicators.SimpleMovingAverage(
                      self.datas[0], period=self.params.maperiod)
    #策略核心，根据条件执行买卖交易指令（必选）
    def next(self):
        # 记录收盘价
        #self.log(f&apos;收盘价, {dataclose[0]}&apos;)
        if self.order: # 检查是否有指令等待执行, 
            return
        # 检查是否持仓   
        if not self.position: # 没有持仓
            #执行买入条件判断：收盘价格上涨突破15日均线
            if self.dataclose[0] &gt; self.sma[0]:
                self.log(&apos;BUY CREATE, %.2f&apos; % self.dataclose[0])
                #执行买入
                self.order = self.buy()         
        else:
            #执行卖出条件判断：收盘价格跌破15日均线
            if self.dataclose[0] &lt; self.sma[0]:
                self.log(&apos;SELL CREATE, %.2f&apos; % self.dataclose[0])
                #执行卖出
                self.order = self.sell()
    #交易记录日志（可省略，默认不输出结果）
    def log(self, txt, dt=None,doprint=False):
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print(f&apos;{dt.isoformat()},{txt}&apos;)
    #记录交易执行情况（可省略，默认不输出结果）
    def notify_order(self, order):
        # 如果order为submitted/accepted,返回空
        if order.status in [order.Submitted, order.Accepted]:
            return
        # 如果order为buy/sell executed,报告价格结果
        if order.status in [order.Completed]: 
            if order.isbuy():
                self.log(f&apos;买入:\n价格:{order.executed.price},\
                成本:{order.executed.value},\
                手续费:{order.executed.comm}&apos;)
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:
                self.log(f&apos;卖出:\n价格：{order.executed.price},\
                成本: {order.executed.value},\
                手续费{order.executed.comm}&apos;)
            self.bar_executed = len(self) 
        # 如果指令取消/交易失败, 报告结果
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&apos;交易失败&apos;)
        self.order = None
    #记录交易收益情况（可省略，默认不输出结果）
    def notify_trade(self,trade):
        if not trade.isclosed:
            return
        self.log(f&apos;策略收益：\n毛收益 {trade.pnl:.2f}, 净收益 {trade.pnlcomm:.2f}&apos;)
    #回测结束后输出结果（可省略，默认输出结果）
    def stop(self):
        self.log(&apos;(MA均线： %2d日) 期末总资金 %.2f&apos; %
                 (self.params.maperiod, self.broker.getvalue()), doprint=True)
</code></pre><p>下面定义一个主函数，用于对某股票指数（个股）在指定期间进行回测，使用tushare的旧接口获取数据，包含开盘价、最高价、最低价、收盘价和成交量。这里主要以3到30日均线为例进行参数寻优，考察以多少日均线与价格的交叉作为买卖信号能获得最大的收益。</p>
<pre><code>def main(code,start,end=&apos;&apos;,startcash=10000,qts=500,com=0.001):
    #创建主控制器
    cerebro = bt.Cerebro()      
    #导入策略参数寻优
    cerebro.optstrategy(MyStrategy,maperiod=range(3, 31))    
    #获取数据
    df=ts.get_k_data(code,autype=&apos;qfq&apos;,start=start,end=end)
    df.index=pd.to_datetime(df.date)
    df=df[[&apos;open&apos;,&apos;high&apos;,&apos;low&apos;,&apos;close&apos;,&apos;volume&apos;]]
    #将数据加载至回测系统
    data = bt.feeds.PandasData(dataname=df)    
    cerebro.adddata(data)
    #broker设置资金、手续费
    cerebro.broker.setcash(startcash)           
    cerebro.broker.setcommission(commission=com)    
    #设置买入设置，策略，数量
    cerebro.addsizer(bt.sizers.FixedSize, stake=qts)   
    print(&apos;期初总资金: %.2f&apos; %                    
    cerebro.broker.getvalue())    
    cerebro.run(maxcpus=1)    
    print(&apos;期末总资金: %.2f&apos; % cerebro.broker.getvalue())
</code></pre><p>再定义一个画图函数，对相应股票（指数）在某期间的价格走势和累计收益进行可视化。</p>
<pre><code>def plot_stock(code,title,start,end):
    dd=ts.get_k_data(code,autype=&apos;qfq&apos;,start=start,end=end)
    dd.index=pd.to_datetime(dd.date)
    dd.close.plot(figsize=(14,6),color=&apos;r&apos;)
    plt.title(title+&apos;价格走势\n&apos;+start+&apos;:&apos;+end,size=15)
    plt.annotate(f&apos;期间累计涨幅:{(dd.close[-1]/dd.close[0]-1)*100:.2f}%&apos;, xy=(dd.index[-150],dd.close.mean()), 
             xytext=(dd.index[-500],dd.close.min()), bbox = dict(boxstyle = &apos;round,pad=0.5&apos;,
            fc = &apos;yellow&apos;, alpha = 0.5),
             arrowprops=dict(facecolor=&apos;green&apos;, shrink=0.05),fontsize=12)
    plt.show()
</code></pre><p>以上证综指为例，回测期间为2010-01-01至2020-03-30，期间累计收益率为-15.31%，惨不忍睹。</p>
<pre><code>面分别对3-30日均线进行回测，这里假设指数可以交易，初始资金为100万元，每次交易100股，注意如果指数收盘价乘以100超过可用资金，会出现交易失败的情况，换句话说在整个交易过程中，是交易固定数量的标的，因此仓位的大小跟股价有直接关系。

main(&apos;sh&apos;,&apos;2010-01-01&apos;,&apos;&apos;,1000000,100)
</code></pre><p><img src="/2020/09/05/backtrader/批注 2020-09-06 183530.png" alt=""></p>
<pre><code>plot_stock(&apos;sh&apos;,&apos;上证综指&apos;,&apos;2010-01-01&apos;,&apos;2020-03-30&apos;)
</code></pre><p><img src="/2020/09/05/backtrader/批注 2020-09-06 183419.png" alt=""></p>
<h2 id="Analyzers模块"><a href="#Analyzers模块" class="headerlink" title="Analyzers模块"></a>Analyzers模块</h2><p>Analyzers模块涵盖了评价一个量化策略的完整指标，如常见的夏普比率、年化收益率、最大回撤、Calmar比率等等。Analyzers模块原生代码能获取的评价指标如下图所示，其中TradeAnalyzer和PeriodStats又包含了不少指标。由于采用元编程，Analyzers的扩展性较强，可以根据需要添加自己的分析指标，如获取回测期间每一时刻对应的总资金。</p>
<p><img src="/2020/09/05/backtrader/批注 2020-09-06 183823.png" alt=""></p>
<h3 id="策略模块编写"><a href="#策略模块编写" class="headerlink" title="策略模块编写"></a>策略模块编写</h3><p>（1）params-全局参数，可选：更改交易策略中变量/参数的值，可用于参数调优。</p>
<p>（2）log：日志，可选：记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。</p>
<p>（3） init：用于初始化交易策略的类实例的代码。</p>
<p>（4）notify_order，可选：跟踪交易指令（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。</p>
<p>（5）notify_trade，可选：跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。</p>
<p>（6）next，必选：制定交易策略的函数，策略模块最核心的部分。</p>
<p>（7）其他，包括start()、nextsstart()、stop()、prenext()、notify_fund()、notify_store()和notify_cashvalue。</p>
<p>面以技术分析指标RSI（不了解的请自行百度）的择时策略为例，当RSI&lt;30时买入，RSI&gt;70时卖出。为了简便起见，策略模块中只包含最核心的交易信号。</p>
<pre><code>import pandas as pd
import backtrader as bt
from datetime import datetime
class MyStrategy(bt.Strategy):
    params=((&apos;short&apos;,30),
            (&apos;long&apos;,70),)
    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(
                   self.data.close, period=21)
    def next(self):
        if not self.position:
            if self.rsi &lt; self.params.short:
                self.buy()
        else:
            if self.rsi &gt; self.params.long:
                self.sell()
</code></pre><h3 id="回测设置"><a href="#回测设置" class="headerlink" title="回测设置"></a>回测设置</h3><p>回测系统设置与之前一样，主要是数据加载、交易本金、手续费、交易数量的设置，此处以tushare的旧接口获取股票002537的交易数据进行量化回测。</p>
<pre><code>from __future__ import (absolute_import, division, print_function,  
                        unicode_literals) 
import tushare as ts
#以股票002537为例
df=ts.get_k_data(&apos;002537&apos;,start=&apos;2010-01-01&apos;)
df.index=pd.to_datetime(df.date)
#df[&apos;openinterest&apos;] = 0
df=df[[&apos;open&apos;,&apos;high&apos;,&apos;low&apos;,&apos;close&apos;,&apos;volume&apos;]]
data = bt.feeds.PandasData(dataname=df,                               
                            fromdate=datetime(2013, 1, 1),                               
                            todate=datetime(2020, 4, 17) )
# 初始化cerebro回测系统设置                           
cerebro = bt.Cerebro()  
# 加载数据
cerebro.adddata(data) 
# 将交易策略加载到回测系统中
cerebro.addstrategy(MyStrategy) 
# 设置初始资本为100,000
cerebro.broker.setcash(100000.0) 
#每次固定交易数量
cerebro.addsizer(bt.sizers.FixedSize, stake=1000) 
#手续费
cerebro.broker.setcommission(commission=0.001) 
</code></pre><h3 id="运行回测"><a href="#运行回测" class="headerlink" title="运行回测"></a>运行回测</h3><p>这里重点是Analyzers模块的调用与结果输出，调用模块是cerebro.addanalyzer()，再从模块中获取分析指标，如夏普比率是bt.analyzers.SharpeRatio，然后是给该指标重命名方便之后调用，即 _name=’SharpeRatio’。要获取分析指标，需要先执行回测系统，cerebro.run()，并将回测结果赋值给变量results，分析指标存储在results[0]里 (strat变量代替)，通过strat.analyzers.SharpeRatio.get_analysis()即可获取相应数据，其他指标操作方法类似。</p>
<pre><code>print(&apos;初始资金: %.2f&apos; % cerebro.broker.getvalue())
cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name = &apos;SharpeRatio&apos;)
cerebro.addanalyzer(bt.analyzers.DrawDown, _name=&apos;DW&apos;)
results = cerebro.run()
strat = results[0]
print(&apos;最终资金: %.2f&apos; % cerebro.broker.getvalue())
print(&apos;夏普比率:&apos;, strat.analyzers.SharpeRatio.get_analysis())
print(&apos;回撤指标:&apos;, strat.analyzers.DW.get_analysis())

输出结果：
初始资金: 100000.00
最终资金: 110215.33
夏普比率: OrderedDict([(&apos;sharperatio&apos;, 0.094)])
回撤指标: AutoOrderedDict([(&apos;len&apos;, 280), (&apos;drawdown&apos;, 1.01), (&apos;moneydown&apos;, 1126.60), (&apos;max&apos;, AutoOrderedDict([(&apos;len&apos;, 280), (&apos;drawdown&apos;, 3.61), (&apos;moneydown&apos;, 4016.60)]))])
</code></pre><h3 id="回测结果可视化"><a href="#回测结果可视化" class="headerlink" title="回测结果可视化"></a>回测结果可视化</h3><p>下面输出回测图表，一张大图上包含了三张图：</p>
<p>（1）资金变动图：可以看到在实施交易策略的数据期内，资金的盈利/损失。</p>
<p>（2）交易收益/亏损。蓝色（红色）点表示获利（亏损）交易以及获利（亏损）多少。</p>
<p>（3）价格图表。绿色和红色箭头分别表示交易策略的进入点和退出点。黑线是交易标的随时间变化的价格， 条形图表示每个条形图期间资金的交易量。</p>
<p><img src="/2020/09/05/backtrader/批注 2020-09-06 184322.png" alt=""></p>
<h3 id="Analyzers模块指标可视化"><a href="#Analyzers模块指标可视化" class="headerlink" title="Analyzers模块指标可视化"></a>Analyzers模块指标可视化</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>init</strong></p>
<p>任何类在生成的时候都是先调用这一初始化构造函数。也就是说，在实例生成的时候，这个函数将被调用。</p>
<ol>
<li><p>Birth: start</p>
<p> start方法在cerebro告诉strategy，是时候开始行动了，也就是说，通知策略激活的时候被调用。</p>
</li>
<li><p>Childhood: prenext</p>
<p> 有些技术指标，比如我们提到的MA，存在一个窗口，也就是说，需要n天的数据才能产生指标，那么在没有产生之前呢？这个prenext方法就会被自动调用。</p>
</li>
<li><p>Adulthood: next<br>这个方法是最核心的，就是每次移动到下一的时间点，策略将会调用这个方法，所以，策略的核心往往都是写在这个方法里的。</p>
</li>
<li><p>Death: stop</p>
<p> 策略的生命周期结束，cerebro把这一策略退出。</p>
</li>
</ol>
<h2 id="策略当中的回调函数"><a href="#策略当中的回调函数" class="headerlink" title="策略当中的回调函数"></a>策略当中的回调函数</h2><p>Strategy 类就像真实世界的交易员一样，当交易执行的时候，他会得到一些消息，譬如order是否执行，一笔trader赚了多少钱，等等。这些消息都将在Strategy类中通过回调函数被得以知晓。这些回调函数如下：</p>
<p>notify_order(order)：下的单子，order的任何状态变化都将引起这一方法的调用</p>
<p>notify_trade(trade)：任何一笔交易头寸的改变都将调用这一方法</p>
<p>notify_cashvalue(cash, value)：任何现金和资产组合的变化都将调用这一方法<br>notify_store(msg, *args, **kwargs)：可以结合cerebro类进行自定义方法的调用</p>
<p>那么问题接踵而至，这里我们只关注前2种方法中监测对象的可变化方式。</p>
<p>trade指的是一笔头寸，trade是open的状态指当前时刻，这一标的的头寸从0变到某一非零值。trade是closed则刚好相反。</p>
<pre><code>trade大概有如下常用属性
ref: 唯一id
size (int): trade的当前头寸
price (float): trade资产的当前价格
value (float): trade的当前价值
commission (float): trade的累计手续费
pnl (float): trade的当前pnl
pnlcomm (float): trade的当前pnl减去手续费
isclosed (bool): 当前时刻trade头寸是否归零
isopen (bool): 新的交易更新了trade
justopened (bool): 新开头寸
dtopen (float): trade open的datetime
dtclose (float): trade close的datetime

Orders

order是strategy发出的指令，让cerebro去执行。
strategy自身有buy, sell and close方法来生成order，cancel方法来取消一笔order。下单的方式有很多，后续会介绍，这里主要讲回调函数中，咱们可以获得哪些信息。
order.status可以返回order的当前状态

order.isbuy可以获得这笔order是否是buy

order.executed.price
order.executed.value
order.executed.comm
</code></pre><p>分别可以获得执行order的价格，总价，和手续费</p>
<pre><code>class TestStrategy(bt.Strategy):
    params = (
        (&apos;maperiod&apos;, 15),
    )

    def log(self, txt, dt=None):
        &apos;&apos;&apos; Logging function fot this strategy&apos;&apos;&apos;
        dt = dt or self.datas[0].datetime.date(0)
        print(&apos;%s, %s&apos; % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)
    def start(self):
        print(&quot;the world call me!&quot;)

    def prenext(self):
        print(&quot;not mature&quot;)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enougth cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &apos;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log(&apos;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&apos;Order Canceled/Margin/Rejected&apos;)

        self.order = None
</code></pre><p>可以看到打印出来的结果中，有start和prenext，最后当然也有death</p>
<h2 id="Backtrader的indicator"><a href="#Backtrader的indicator" class="headerlink" title="Backtrader的indicator"></a>Backtrader的indicator</h2><pre><code>def __init__(self):
    # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
    self.dataclose = self.datas[0].close

    # To keep track of pending orders and buy price/commission
    self.order = None
    self.buyprice = None
    self.buycomm = None

    # Add a MovingAverageSimple indicator
    self.sma = bt.indicators.SimpleMovingAverage(
        self.datas[0], period=self.params.maperiod)
</code></pre><p> 这里的最后，我们使用了一个backtrader内置的indicator，后续我们将尝试自己编写一个indicator。</p>
<h2 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h2><p>datafeed，也就是cerebro的本源，数据</p>
<pre><code>dataframe = pd.read_csv(&apos;dfqc.csv&apos;, index_col=0, parse_dates=True)
dataframe[&apos;openinterest&apos;] = 0
data = bt.feeds.PandasData(dataname=dataframe,
                        fromdate = datetime.datetime(2015, 1, 1),
                        todate = datetime.datetime(2016, 12, 31)
                        )
# Add the Data Feed to Cerebro
cerebro.adddata(data)

2014-03-13 00:00:00.005,1.425,1.434,1.449,1.418,457767208.0
2014-03-14 00:00:00.005,1.429,1.422,1.436,1.416,196209439.0
2014-03-17 00:00:00.005,1.433,1.434,1.437,1.422,250946201.0
2014-03-18 00:00:00.005,1.434,1.425,1.437,1.424,245516577.0
2014-03-19 00:00:00.005,1.423,1.419,1.423,1.406,331866195.0
2014-03-20 00:00:00.005,1.412,1.408,1.434,1.407,379443759.0
2014-03-21 00:00:00.005,1.406,1.463,1.468,1.403,825467935.0

dataframe = pd.read_csv(&apos;dfqc.csv&apos;, index_col=0, parse_dates=True)
</code></pre><p>把csv读入pandas的参数，index_col=0表示第一列时间数据是作为pandas 的index的，parse_dates=Ture是自动把数据中的符合日期的格式变成datetime类型。为什么要这样呢？其实读入后的pandas长怎么样都是由backtrader规定的</p>
<p>pandas的要求的结构，我们就知道，不仅仅有self.datas[0].close,还会有self.datas[0].open。也确实如此。只是我们通常拿close作为一个价格基准</p>
<pre><code>self.datas[0].close
</code></pre><p>返回的是一个lines。lines是backtrader一个很重要的概念，可以理解为时间序列流，这类数据，后面可以跟index，也就是说，可以有</p>
<pre><code>self.datas[0].close[0]
self.datas[0].close[-1]
</code></pre><p>这里的index是有意义的，0代表当前时刻，-1代表前一时刻，1代表后一时刻，以此类推</p>
<p>所以在next中使用self.dataclose[0],self.dataclose[-1]</p>
<h2 id="安装TA-lib"><a href="#安装TA-lib" class="headerlink" title="安装TA-lib"></a>安装TA-lib</h2><p>下载TA_Lib-0.4.19-cp37-cp37m-win_amd64</p>
<pre><code>pip install TA_Lib-0.4.19-cp37-cp37m-win_amd64.whl
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/投资/" rel="tag"># 投资</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/29/qa函数/" rel="next" title="qa函数">
                <i class="fa fa-chevron-left"></i> qa函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/29/PRINCIPLES/" rel="prev" title="PRINCIPLES">
                PRINCIPLES <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Airthink">
          <p class="site-author-name" itemprop="name">Airthink</p>
           
              <p class="site-description motion-element" itemprop="description">The Pursuit of Happyness</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ikangbow" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Backtrader"><span class="nav-number">1.</span> <span class="nav-text">Backtrader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Backtrader介绍"><span class="nav-number">1.2.</span> <span class="nav-text">Backtrader介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Backtrader环境搭建"><span class="nav-number">1.3.</span> <span class="nav-text">Backtrader环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回测应用实例"><span class="nav-number">1.4.</span> <span class="nav-text">回测应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构建策略（Strategy）"><span class="nav-number">1.4.1.</span> <span class="nav-text">构建策略（Strategy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据加载（Data-Feeds）"><span class="nav-number">1.4.2.</span> <span class="nav-text">数据加载（Data Feeds）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回测设置（Cerebro）"><span class="nav-number">1.4.3.</span> <span class="nav-text">回测设置（Cerebro）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化cerebro回测系统设置"><span class="nav-number">2.</span> <span class="nav-text">初始化cerebro回测系统设置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将交易策略加载到回测系统中"><span class="nav-number">3.</span> <span class="nav-text">将交易策略加载到回测系统中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设置初始资本为10-000"><span class="nav-number">4.</span> <span class="nav-text">设置初始资本为10,000</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设置交易手续费为-0-2"><span class="nav-number">5.</span> <span class="nav-text">设置交易手续费为 0.2%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行回测"><span class="nav-number">5.0.1.</span> <span class="nav-text">执行回测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可视化"><span class="nav-number">5.0.2.</span> <span class="nav-text">可视化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回测实例"><span class="nav-number">5.1.</span> <span class="nav-text">回测实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analyzers模块"><span class="nav-number">5.2.</span> <span class="nav-text">Analyzers模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#策略模块编写"><span class="nav-number">5.2.1.</span> <span class="nav-text">策略模块编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回测设置"><span class="nav-number">5.2.2.</span> <span class="nav-text">回测设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行回测"><span class="nav-number">5.2.3.</span> <span class="nav-text">运行回测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回测结果可视化"><span class="nav-number">5.2.4.</span> <span class="nav-text">回测结果可视化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Analyzers模块指标可视化"><span class="nav-number">5.2.5.</span> <span class="nav-text">Analyzers模块指标可视化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">5.3.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略当中的回调函数"><span class="nav-number">5.4.</span> <span class="nav-text">策略当中的回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Backtrader的indicator"><span class="nav-number">5.5.</span> <span class="nav-text">Backtrader的indicator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据的获取"><span class="nav-number">5.6.</span> <span class="nav-text">数据的获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装TA-lib"><span class="nav-number">5.7.</span> <span class="nav-text">安装TA-lib</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Airthink</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
