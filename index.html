<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="The Pursuit of Happyness">
<meta property="og:type" content="website">
<meta property="og:title" content="Airthink">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Airthink">
<meta property="og:description" content="The Pursuit of Happyness">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Airthink">
<meta name="twitter:description" content="The Pursuit of Happyness">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Airthink</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Airthink</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/12/本杰明巴顿奇事/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/12/本杰明巴顿奇事/" itemprop="url">本杰明巴顿奇事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-12T13:06:43+08:00">
                2021-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/电影台词/" itemprop="url" rel="index">
                    <span itemprop="name">电影台词</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>一直很好奇，街上是什么样子的？
下个街角又是怎么样？

Always had a healthy curiouly , what was up the street ? Or around the next corner ?

有时候，我感觉一切和前一天大不一样了。

Some days I feel different than the day before.

每个人在某种程度上都对自己有不同的认识，但是我们最后都会去往同一个地方，只是走的路不同罢了。

Everybody feels different about themselves , one way or another . Butwe’re all going the same way . Just taking different roads to get there ,that’s all . You’re on your own road .

有时候我觉得很可笑，那些在我们记忆里占据着很小一部分的人们，却往往给我们留下了最深刻的印象。
It’s funny how sometimes the people we remember the least , make the greatest impression on us .

我们注定要失去我们所爱的人，要不然我们怎么会知道，他们对我们有多么的重要。
We’re meant to lose the people we love . How else would we know how importantthey are to us ?

长大是件很有意思的事，不经意间就发生了，本来是这样一个人，然后突然间变成了另一个人，不再是原来那样子。

Growing up’s a funny thing , Sneak up on you . One person is there , than suddenly somebodyelse has taken here place . She wasn`t all albows and knees anymore.

你可以像疯狗那样对周围的一切愤愤不平，你可以诅咒命运，但是等到最后一刻，你还是得平静的放手而去。

You can be as mad as a mad dog at the way things went . You could swear, curse the fates . But when it comes to the end , you have to let go .

我们的生命因为各种各样的机遇而变得更有意义。

Our lives are defined by opportunities。

有些时候我们就活在即将发生冲撞的轨道上，浑然不知无论它是意外发生还是蓄谋已久，对此我们都无能为力。

Sometimes we’re on a collision course and we just don’t know it . Whether it’s by accident or by design , there’s not a thing we can do about it .

一件事无论太晚或者对于我来说太早，
都不会阻拦你成为你想成为的那个人，
这个过程没有时间的期限，只要你想，随时都可以开始，
要改变或者保留原状都无所谓，
做事本不应该有所束缚，
我们可以办好这件事却也可以把它搞砸，
但我希望最终你能成为你想成为的人。

For what it’s worth, it’s never too late,
Or in my case, too early,
To be whoever you want to be.
There’s no time limit, stop whenever you want.
You can change or stay the same.
There’s no rules to this thing.
We can make the best or the worst of it.
I hope you make the best of it.

我希望你有时能驻足于这个令你感到惊叹的世界，
体会你从未有过的感觉；
我希望你能见到其他与你观点不同的人们；
我希望你能有一个值得自豪的人生，
如果你想象的生活不一样；
我希望你能有勇气重新再来。

I hope you see things that startle you.
I hope you feel things you never felt before.
I hope you meet people with a different point of view.
I hope you live a life you’re proud of.
If you find that you are not,
I hope you have the strength to start all over again.
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/10/树莓派初始化设置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/10/树莓派初始化设置/" itemprop="url">树莓派初始化设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-10T20:15:54+08:00">
                2021-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先执行<br>sudo apt-get install vim</p>
<p>WIFI设置<br>每当重新安装树莓派的系统或者初始化一块全新的树莓派都会遇到这样的问题：连接WIFI。</p>
<p>那当我们没有显示器和键盘的情况下怎末可以将树莓连接到当前的WIFI网络呢？</p>
<p>方法非常简单，首先在SD卡的根目录下添加一个名为 wpa_supplicant.conf的文件，然后在该文件内添加以下的内容：</p>
<pre><code>country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid=&quot;AlexVB&quot;
    key_mgmt=WPA-PSK
    psk=&quot;*********&quot;
    priority=1
}
</code></pre><p>密码设置<br>树莓派很多功能都需要解锁root权限后才能完成，比如下载安装，更改文件等等。</p>
<p>在命令行界面执行以下命令，再输入两次想设置的root密码，执行后设置成功。</p>
<pre><code>sudo passwd root
</code></pre><p>输入以下命令开启root权限：</p>
<pre><code>sudo passwd --unlock root
</code></pre><p>更改pi用户密码：</p>
<pre><code>sudo passwd pi
</code></pre><p>python设置<br>树莓派的python默认版本是python2.7，如果想用python3.x的话，树莓派有自带的python3.5，此乃大坑，不需要再下载python3，直接把python和自带的python3建立软链接就OK。</p>
<pre><code>which python

/usr/bin/python

which python3

/usr/bin/python3
</code></pre><p>注意：不能直接就把python链接到python3上，会报错，先把原来的python2备份一下。<br>ln: 无法创建符号链接’/usr/bin/python’: 文件已存在</p>
<pre><code>sudo mv /usr/bin/python  /usr/bin/python2

sudo ln -s /usr/bin/python3 /usr/bin/python
</code></pre><p>之后在终端输入python就可以看到python的默认版本改为python3.5了。<br>在这里插入图片描述</p>
<p>更改软件源<br>树莓派系统安装后默认使用国外的镜像源来更新软件，由于不可描述原因，国内访问速度非常慢，因此需要换成国内源。</p>
<p>树莓派官方提供了一个更新源列表，在这里我们使用中科大的软件源和系统源。</p>
<p>首先还是要备份原来的源文件：</p>
<pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak

sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak
</code></pre><p>修改软件更新源，执行如下命令：</p>
<pre><code>sudo vim /etc/apt/sources.list
</code></pre><p>将原来的内容注释掉，改为中科大的源：</p>
<pre><code>deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi
</code></pre><p>在这里插入图片描述<br>修改系统更新源，执行如下命令：</p>
<pre><code>sudo vim /etc/apt/sources.list.d/raspi.list
</code></pre><p>将原来的内容注释掉，改为中科大的源：</p>
<pre><code>deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui
</code></pre><p>在这里插入图片描述<br>之后就可以快速更新和安装了。</p>
<pre><code>sudo apt-get update

sudo apt-get upgrade -y
</code></pre><p>这时候可能会有提示“有些没有软件包是自动安装的但是当前已经不需要了，可以使用如下命令卸载：    </p>
<pre><code>sudo apt autoremove
</code></pre><p>！！千万别用！！<br>更改pip源<br>pip更换为国内源，可以大大的提高安装成功率和速度。</p>
<p>不管你用的是pip3还是pip，方法都是一样的，如下：</p>
<pre><code>sudo vim /etc/pip.conf
</code></pre><p>更改文件内容：</p>
<pre><code>index-url = https://mirrors.aliyun.com/pypi/simple
</code></pre><p>输入法</p>
<p>sudo apt-get install scim-pinyin</p>
<p>一、安装</p>
<pre><code>1.安装mongodb

        sudo apt-get install mongodb

2. 启动服务

        /usr/bin/mongod -f /etc/mongodb.conf

3.启动命令行

        /usr/bin/mongo 

        此时可以看到版本是MongoDB shell version: 2.4.14

4.关闭mongo
      /usr/bin/mongod -shutdown -dbpath=/home/data/mongodb
</code></pre><p>二、配置</p>
<pre><code>1.配置主机ip：

          sudo vim /etc/mongodb.conf

          加入如下：127.0.0.1，自己的ip

2.配置防火墙，让局域网环境可以访问数据库

          2.1  安装：sudo apt-get install ufw

          2.2  启用：sudo ufw enable

          2.3  禁止外部访问 sudo ufw default deny

          2.4  启用局域网mongodb端口访问：       sudo ufw allow from 192.168.0.0/8 
</code></pre><p>三、使用</p>
<pre><code>1.pymongo下载

            这里注意，最新版本pymongo是不兼容MongoDB2.4的，所以下载的时候记得下载老版本

                  pip install pymongo==3.1.1

 2.使用

                  使用起来非常方便：连接、关闭、增删改查。具体操作见官网文档：

                  http://api.mongodb.com/python/current/index.html
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/compose/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/07/compose/" itemprop="url">compose</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-07T21:19:37+08:00">
                2020-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/compose/" itemprop="url" rel="index">
                    <span itemprop="name">compose</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何写docker-compose-yml，Docker-compose-file-参考文档"><a href="#如何写docker-compose-yml，Docker-compose-file-参考文档" class="headerlink" title="如何写docker-compose.yml，Docker compose file 参考文档"></a>如何写docker-compose.yml，Docker compose file 参考文档</h1><h2 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h2><p>Compose 文件是一个YAML文件，用于定义services、netword和volumes。 Compose 文件的默认路径为./docker-compose.yaml(后缀为.yml和.yaml都可以)。</p>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<p>使用 Dockerfile 定义应用程序的环境。</p>
<p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</p>
<p>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</p>
<h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h2><pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

docker-compose -v
</code></pre><h2 id="工程、服务、容器"><a href="#工程、服务、容器" class="headerlink" title="工程、服务、容器"></a>工程、服务、容器</h2><p>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）</p>
<p>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p>
<p>Docker Compose默认的模板文件是docker-compose.yml，其中定义的每个服务都必须通过image指令指定镜像或使用Dockerfile的build指令进行自动构建，其它大部分指令跟docker run中选项类似。</p>
<p>如果使用Dockerfile的build指令，则在Dockerfile中设置的选项如CMD、EXPOSE、VOLUME、ENV等将会自动被获取，无需在docker-comopse.yml文件中再次设置。</p>
<p>如果使用image指定为镜像名称或镜像ID时镜像在本地不存在，Compose将会尝试去拉取这个镜像。</p>
<p>典型的docker-comopse.yml文件格式</p>
<pre><code>version: &apos;2&apos;
services:
  web:
    image: dockercloud/hello-world
    ports:
      - 8080
    networks:
      - front-tier
      - back-tier

  redis:
    image: redis
    links:
      - web
    networks:
      - back-tier

  lb:
    image: dockercloud/haproxy
    ports:
      - 80:80
    links:
      - web
    networks:
      - front-tier
      - back-tier
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock 

networks:
  front-tier:
    driver: bridge
  back-tier:
driver: bridge
</code></pre><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p>version：指定 docker-compose.yml 文件的写法格式<br>services：多个容器集合<br>build：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</p>
<p>Compose文件是一个定义服务services、网络networks和卷volumes的YAML文件，默认路径是./docker-compose.yml，可使用.yml或.yaml作为文件扩展名。</p>
<p>服务services定义包含应用于为该服务启动的每个容器的配置，类似传递命令行参数一样docker container create。同样，网络networks和卷volumes的定义类似于docker network create和docker volume create。正如docker container create在Dockerfile指定选项，如CMD、EXPOSE、VOLUME、ENV，在默认情况下，不需要在docker-compose.yml配置中再次指定。可以使用Bash类${VARIABLE}语法在配置值中使用环境变量。</p>
<p>标准配置文件应该包含version、services、networks三部分，其中最关键的是services和networks两个部分。</p>
<h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>images用来指定服务的镜像名称或镜像ID，如果镜像在本地不存在，compose将会尝试去拉取这个镜像。</p>
<pre><code>services:
  web:
    image:redis
</code></pre><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>volumes指令用于设置数据卷挂载路径，数据卷挂载路径可以是一个目录或一个已经存在的数据卷容器，可以设置宿主机路径HOST:CONTAINER或加上访问模式HOST:CONTAINER:ro。使用ro表示对于容器来说数据卷是只读的，这样可以有效地保护宿主机的文件系统。</p>
<pre><code>volumes:
  # 指定一个容器内的路径，Docker会自动创建一个数据卷。
  - /var/lib/mysql
  # 使用绝对路径挂载数据卷
  - /opt/data:/var/lib/mysql
  # 以compose配置文件所在目录为根的相对路径作为数据卷挂载到容器
  - ./cache:/tmp/cache
  # 使用用户的相对路径
  - ~/configs:/etc/configs:ro
</code></pre><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>networks指令用于设置指定网络</p>
<pre><code>services:
  some-service:
    networks:
      - some-network
</code></pre><h2 id="多服务"><a href="#多服务" class="headerlink" title="多服务"></a>多服务</h2><pre><code>version: &apos;2&apos;

services:

 service-eureka: 
   image: java
   volumes:
     - /Users/objcat/jar/service-eureka.jar:/usr/local/service-eureka.jar
   ports:
     - 8081:8081
   command:
     - /bin/sh
     - -c
     - |
       echo 192.168.1.126 servicehost &gt;&gt; /etc/hosts
       java -jar /usr/local/service-eureka.jar

 service-a: 
   image: java
   volumes:
     - /Users/objcat/jar/service-a.jar:/usr/local/service-a.jar
   ports:
     - 8082:8082
   command:
     - /bin/sh
     - -c
     - |
       echo 192.168.1.126 servicehost &gt;&gt; /etc/hosts
       java -jar /usr/local/service-a.jar

 service-b: 
   image: java
   volumes:
     - /Users/objcat/jar/service-b.jar:/usr/local/service-b.jar
   ports:
     - 8083:8083
   command:
     - /bin/sh
     - -c
     - |
       echo 192.168.1.126 servicehost &gt;&gt; /etc/hosts
       java -jar /usr/local/service-b.jar
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/arctic/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/07/arctic/" itemprop="url">arctic</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-07T21:16:24+08:00">
                2020-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/arctic/" itemprop="url" rel="index">
                    <span itemprop="name">arctic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="北极介绍"><a href="#北极介绍" class="headerlink" title="北极介绍"></a>北极介绍</h1><p>北极是位于MongoDB之上的时间序列/数据框架数据库。Arctic支持将许多数据类型序列号以存储在mongo文档模型中。</p>
<h2 id="为什么使用北极"><a href="#为什么使用北极" class="headerlink" title="为什么使用北极"></a>为什么使用北极</h2><ul>
<li>序列化许多数据类型，例如Pandas DataFrames,Numpy数组,Python对象等,SO不必手动处理不同的数据类型。</li>
<li>默认情况下客户端使用LZ4压缩，以节省大量网络/磁盘空间。</li>
<li>允许对队形的不同阶段进行版本控制并快照状态（某种程度上类似于git）,并允许自由的试验,然后紧还原快照。【仅限VersionStore】</li>
<li>是否为您进行分块（将数据拆分为较小的部分）</li>
<li>添加了可以在Mongo的auth上构建的Users and Per User Libraries的概念。</li>
<li>拥有不同类型的商店，每种都有其自身的优势。Versionstore允许您对版本和快照内容进行版本控制，TickStore用于存储和高效检索流数据，ChunkStore允许您对数据块进行分块并有效地检索范围。</li>
<li>限制对Mongo的数据访问，从而防止对未索引/未分片的集合进行临时查询</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>Arctic提供了一个包装器,用于处理与Mongo的连接。该Arctic实际连接到北极。</p>
<pre><code>conn = Arctic(&apos;127.0.0.1&apos;)
</code></pre><p>仅此连接句柄可以执行许多操作。最基本的是list_libraries和initiailize_library。</p>
<p>北极将数据分为不同的库。它们可能是不同的用户，不同的市场，不同的地理区域等。库名称是字符串，完全由用户定义。</p>
<pre><code>conn.list_libraries()
[]
</code></pre><p>在这种情况下，系统上没有库，因此可以对其进行初始化。</p>
<pre><code>&gt;&gt;&gt; conn.initialize_library(&apos;library_name&apos;)
&gt;&gt;&gt; conn.list_libraries()
[u&apos;library_name&apos;]
</code></pre><p>initialize_library有一个名为arg的可选参数，lib_type默认为VersionStore（稍后会在Arctic存储引擎类型中提供更多信息）。</p>
<p>库初始化后，可以像这样访问它：</p>
<pre><code>&gt;&gt;&gt; lib = conn[&apos;library_name&apos;]
</code></pre><p>使用此库的句柄，我们可以开始从Arctic存储和检索数据。</p>
<p>（注意，大多数存储引擎的支持相同的基本方法（read，write，等），但每个人都有自己一套独特的方法为好）</p>
<p>write最基本的形式是北极symbol和数据。的symbol是，用于存储/检索数据的用户定义键。在data多数情况下是一个熊猫数据帧，虽然有些存储引擎支持其他类型的（所有支持dataframes，和一些支持类型的字典，并与pickle对象）。</p>
<p>read如您所料，会symbol读取数据。不同的存储引擎具有不同的参数，这些参数使您可以对数据进行子集设置（稍后会详细介绍）。</p>
<pre><code>&gt;&gt;&gt; data = pd.DataFrame(.....)
&gt;&gt;&gt; lib.write(&apos;symbolname&apos;, data)
&gt;&gt;&gt; df = lib.read(&apos;symbolname&apos;)
&gt;&gt;&gt; df
                data
date
2016-01-01       1
2016-01-02       2
2016-01-03       3
</code></pre><p>其他基本方法：</p>
<ul>
<li>library.list_symbols()<br> 符合您的期望-列出给定库中的所有符号 [‘US_EQUITIES’, ‘EUR_EQUITIES’, …]</li>
<li>arctic.get_quota(library_name)， arctic.set_quota(library_name, quota_in_bytes)</li>
<li>北极内部设置库的配额，这样它们就不会占用太多空间。您可以使用这两种方法检查和设置配额。请注意，这些操作针对 Arctic对象，而非库。</li>
</ul>
<h2 id="北极存储引擎"><a href="#北极存储引擎" class="headerlink" title="北极存储引擎"></a>北极存储引擎</h2><p>Arctic的设计具有很高的可扩展性，目前支持多种不同的用例。要了解Arctic的功能，必须了解其使用的存储模型。北极目前支持三个存储引擎</p>
<ul>
<li>TickStore</li>
<li>版本库</li>
<li>块存储</li>
</ul>
<p>每一个都有各种功能，旨在支持特定和通用的用例。</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="安装北极"><a href="#安装北极" class="headerlink" title="安装北极"></a>安装北极</h2><pre><code>pip install git+https://github.com/manahl/arctic.git
</code></pre><h2 id="运行一个mongo"><a href="#运行一个mongo" class="headerlink" title="运行一个mongo"></a>运行一个mongo</h2><pre><code>mongod --dbpath &lt;path/to/db_directory&gt;
</code></pre><h2 id="使用VersionStore"><a href="#使用VersionStore" class="headerlink" title="使用VersionStore"></a>使用VersionStore</h2><pre><code>from arctic import Arctic
import quandl

# Connect to Local MONGODB
store = Arctic(&apos;localhost&apos;)

# Create the library - defaults to VersionStore
store.initialize_library(&apos;NASDAQ&apos;)

# Access the library
library = store[&apos;NASDAQ&apos;]

# Load some data - maybe from Quandl
aapl = quandl.get(&quot;WIKI/AAPL&quot;, authtoken=&quot;your token here&quot;)

# Store the data in the library
library.write(&apos;AAPL&apos;, aapl, metadata={&apos;source&apos;: &apos;Quandl&apos;})

# Reading the data
item = library.read(&apos;AAPL&apos;)
aapl = item.data
metadata = item.metadata
</code></pre><h1 id="存储引擎版本库"><a href="#存储引擎版本库" class="headerlink" title="存储引擎版本库"></a>存储引擎版本库</h1><p>VersionStore在MongoDB中序列化并存储Pandas对象，numpy数组以及其他python类型。修改versioneda时，对象是并且创建了新版本symbol。</p>
<h2 id="使用VersionStore读写数据"><a href="#使用VersionStore读写数据" class="headerlink" title="使用VersionStore读写数据"></a>使用VersionStore读写数据</h2><pre><code>from arctic import Arctic

a = Arctic(‘localhost’)
a.initialize_library(&apos;vstore&apos;)
lib = a[‘vstore’]
</code></pre><p>此时，您有一个空的VersionStore库。您不需要指定存储类型，因为VersionStore是Arctic中的默认库类型。您可以通过几种方式向其中写入数据。最基本的就是使用该write方法。写采用以下参数：</p>
<pre><code>symbol, data, metadata=None, prune_previous_version=True, **kwargs
</code></pre><p>symbol是用于在北极存储/检索数据的名称。data是要存储在MongoDB中的数据。metadata是可选的用户定义元数据。它一定是一个dict。prune_previous_versions将删除/删除数据的先前版本（前提是快照中未包含它们）。kwargs被传递给各个写处理程序。有针对不同数据类型的写处理程序。</p>
<p>write用于写入和替换数据。如果test使用一个数据集写入符号，然后使用另一个数据集再次写入符号，则原始数据将被替换为新版本的数据。</p>
<pre><code>&gt;&gt;&gt; from pandas import DataFrame, MultiIndex
&gt;&gt;&gt; from datetime import datetime as dt


&gt;&gt;&gt; df = DataFrame(data={&apos;data&apos;: [1, 2, 3]},
                   index=MultiIndex.from_tuples([(dt(2016, 1, 1), 1),
                                                 (dt(2016, 1, 2), 1),
                                                 (dt(2016, 1, 3), 1)],
                                                names=[&apos;date&apos;, &apos;id&apos;]))
&gt;&gt;&gt; lib.write(&apos;test&apos;, df)
VersionedItem(symbol=test,library=arctic.vstore,data=&lt;class &apos;NoneType&apos;&gt;,version=1,metadata=None,host=127.0.0.1)

&gt;&gt;&gt; lib.read(&apos;test&apos;).data
               data
date       id      
2016-01-01 1      1
2016-01-02 1      2
2016-01-03 1      3


&gt;&gt;&gt; df = DataFrame(data={&apos;data&apos;: [100, 200, 300]},
                   index=MultiIndex.from_tuples([(dt(2016, 1, 1), 1),
                                                 (dt(2016, 1, 2), 1),
                                                 (dt(2016, 1, 3), 1)],
                                               names=[&apos;date&apos;, &apos;id&apos;]))

&gt;&gt;&gt; lib.write(&apos;test&apos;, df)
VersionedItem(symbol=test,library=arctic.vstore,data=&lt;class &apos;NoneType&apos;&gt;,version=2,metadata=None,host=127.0.0.1)

&gt;&gt;&gt; lib.read(&apos;test&apos;).data
               data
date       id      
2016-01-01 1    100
2016-01-02 1    200
2016-01-03 1    300
</code></pre><p>write返回一个VersionedItem对象。VersionedItem包含以下成员：</p>
<p>符号<br>图书馆<br>版本-写入数据的版本号<br>元数据-元数据（如果存在），或无<br>数据（对于写入，它为None；对于读取，它包含从数据库读取的数据）。<br>主办<br>您还应注意，VersionStorewrite有效覆盖了已写入的数据。在上面的示例中，第二个示例用新数据帧write替换了符号test中的数据。原始数据（版本1）仍然可用，但必须以其版本号引用才能检索它。该read方法采用以下参数：</p>
<pre><code>symbol, as_of=None, date_range=None, from_version=None, allow_secondary=None, **kwargs
</code></pre><p>as_of允许您检索特定时间点的数据。您可以通过多种方式定义该时间点。</p>
<ul>
<li>快照的名称（字符串）</li>
<li>版本号（整数）</li>
<li>日期时间（datetime.datetime）</li>
</ul>
<p>date_range使您可以通过Arctic DateRange对象对数据进行子集化。DateRanges允许您指定日期范围（“ 2016-01-01”，“ 2016-09-30”），开始日期和结束日期以及开放式范围（无，“ 2016-09-30”）。范围可以在任一端打开。allow_secondary使您可以覆盖默认行为，以允许或禁止从mongo集群的辅助成员读取。</p>
<pre><code>&gt;&gt;&gt; lib.read(&apos;test&apos;).data
               data
date       id      
2016-01-01 1    100
2016-01-02 1    200
2016-01-03 1    300

&gt;&gt;&gt; lib.read(&apos;test&apos;, as_of=1).data

date       id  data    
2016-01-01 1      1
2016-01-02 1      2
2016-01-03 1      3


&gt;&gt;&gt; from arctic.date import DateRange
&gt;&gt;&gt; lib.read(&apos;test&apos;, date_range=DateRange(&apos;2016-01-01&apos;, &apos;2016-01-01&apos;)).data

date       id  data    
2016-01-01 1    100
</code></pre><p>DateRange仅适用于pandas DataFrame，并且该数据帧必须具有datetime索引。</p>
<p>写入数据的另一种方法是使用append方法。append接受以下参数：</p>
<pre><code>symbol, data, metadata=None, prune_previous_version=True, upsert=True, **kwargs
</code></pre><p>upsert是唯一的新论据。upsert表示如果该符号不存在，它将创建它。如果upsert出现False错误，因为将没有现有数据要追加。</p>
<pre><code>&gt;&gt;&gt; lib.append(&apos;new&apos;, df, upsert=False)
~/arctic/arctic/store/version_store.py in append(self, symbol, data, metadata, prune_previous_version, upsert, **kwargs)
    505             return self.write(symbol=symbol, data=data, prune_previous_version=prune_previous_version, metadata=metadata)
    506 
--&gt; 507         assert previous_version is not None
    508         dirty_append = False
    509 

AssertionError: 
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>lib.append(‘new’, df, upsert=True)<br>VersionedItem(symbol=new,library=arctic.vstore,data=<class 'nonetype'="">,version=1,metadata=None,host=127.0.0.1)</class></p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h2><ul>
<li>删除</li>
<li>has_symbol</li>
<li>list_versions</li>
<li>read_metadata</li>
<li>write_metadata</li>
<li>restore_version</li>
</ul>
<p>delete符合您的预期-从库中删除符号。它只有一个参数symbol。has_symbol并且list_symbols将返回有关库符号的当前状态信息。他们的签名是：</p>
<pre><code>list_symbols(self, all_symbols=False, snapshot=None, regex=None, **kwargs)

def has_symbol(self, symbol, as_of=None)
</code></pre><p>for list_symbols，all_symbols如果设置为，则将true从所有快照返回所有符号，即使该符号已在当前版本中删除（但已保存在快照中）也是如此。snapshot允许您在指定的下方列出符号snapshot。regex允许您提供正则表达式以进一步限制查询返回的符号列表。北极使用MongoDB的$regex功能。Mongo支持PERL语法正则表达式；更多信息在这里</p>
<p>has_symbol返回True或False基于符号是否存在。您可以version通过将此检查限制为特定检查as_of。</p>
<pre><code>&gt;&gt;&gt; lib.delete(&apos;new&apos;)

&gt;&gt;&gt; lib.list_symbols()
[&apos;test&apos;]

&gt;&gt;&gt; lib.has_symbol(&apos;new&apos;)
False

&gt;&gt;&gt; lib.write(&apos;test2&apos;, df)

&gt;&gt;&gt; lib.list_symbols(regex=&quot;.*2&quot;)
[&apos;test2&apos;]
</code></pre><p>read_metadata并write_metadata允许您直接为给定符号读取/设置用户定义的元数据。</p>
<pre><code>&gt;&gt;&gt; lib.read_metadata(&apos;test2&apos;)
VersionedItem(symbol=test2,library=arctic.vstore,data=&lt;class &apos;NoneType&apos;&gt;,version=1,metadata=None,host=127.0.0.1)

&gt;&gt;&gt; lib.read_metadata(&apos;test2&apos;).metadata

&gt;&gt;&gt; lib.write_metadata(&apos;test2&apos;, {&apos;meta&apos;: &apos;data&apos;})
VersionedItem(symbol=test2,library=arctic.vstore,data=&lt;class &apos;NoneType&apos;&gt;,version=2,metadata={&apos;meta&apos;: &apos;data&apos;},host=127.0.0.1)

&gt;&gt;&gt; lib.read_metadata(&apos;test2&apos;).metadata
{&apos;meta&apos;: &apos;data&apos;}
</code></pre><p>restore_version使您可以将最新版本设置为旧版本。您可以list_versions用来查看有关版本当前状态的信息。</p>
<pre><code>&gt;&gt;&gt; lib.list_versions(&apos;test&apos;) 
[{&apos;symbol&apos;: &apos;test&apos;,
  &apos;version&apos;: 3,
  &apos;deleted&apos;: False,
  &apos;date&apos;: datetime.datetime(2018, 8, 16, 17, 59, 47, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;)),
  &apos;snapshots&apos;: []},
 {&apos;symbol&apos;: &apos;test&apos;,
  &apos;version&apos;: 2,
  &apos;deleted&apos;: False,
  &apos;date&apos;: datetime.datetime(2018, 8, 15, 18, 0, 33, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;)),
  &apos;snapshots&apos;: []}]


&gt;&gt;&gt; lib.restore_version(&apos;test&apos;, 2)
VersionedItem(symbol=test,library=arctic.vstore,data=&lt;class &apos;NoneType&apos;&gt;,version=4,metadata=None,host=127.0.0.1)

&gt;&gt;&gt; lib.read(&apos;test&apos;).data
               data
date       id      
2016-01-01 1    100
2016-01-02 1    200
2016-01-03 1    300

&gt;&gt;&gt; lib.list_versions(&apos;test&apos;) 
[{&apos;symbol&apos;: &apos;test&apos;,
  &apos;version&apos;: 4,
  &apos;deleted&apos;: False,
  &apos;date&apos;: datetime.datetime(2018, 8, 16, 18, 54, 10, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;)),
  &apos;snapshots&apos;: []},
 {&apos;symbol&apos;: &apos;test&apos;,
  &apos;version&apos;: 3,
  &apos;deleted&apos;: False,
  &apos;date&apos;: datetime.datetime(2018, 8, 16, 17, 59, 47, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;)),
  &apos;snapshots&apos;: []},
 {&apos;symbol&apos;: &apos;test&apos;,
  &apos;version&apos;: 2,
  &apos;deleted&apos;: False,
  &apos;date&apos;: datetime.datetime(2018, 8, 15, 18, 0, 33, tzinfo=tzfile(&apos;/usr/share/zoneinfo/America/New_York&apos;)),
  &apos;snapshots&apos;: []}]
</code></pre><p>使用restore_version不会删除最新版本，它只是使用用户提供的版本引用的数据创建了一个新版本。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>VersionStore允许您创建数据快照并为其分配名称。快照中仍包含属于快照的一部分的数据。快照方法是：</p>
<ul>
<li>快照</li>
<li>delete_snapshot</li>
<li>list_snapshots</li>
</ul>
<p>snapshot允许您创建快照。它的签名很简单</p>
<pre><code>snap_name, metadata=None, skip_symbols=None, versions=None
</code></pre><p>snap_name是要创建的快照的名称。metadata允许您向快照提供用户定义的元数据。skip_symbols允许您从快照中排除符号。versions允许您指定要包含在快照中的特定版本。</p>
<p>delete_snapshot和list_snapshot功能分别类似于delete和list_versions。list_snapshots返回snapshot映射到metadata快照的名称的字典。</p>
<pre><code>&gt;&gt;&gt; lib.list_symbols()
[&apos;test&apos;, &apos;test2&apos;]

&gt;&gt;&gt; lib.snapshot(&apos;backup&apos;)

&gt;&gt;&gt; lib.list_snapshots()
{&apos;backup&apos;: None}

&gt;&gt;&gt; lib.list_symbols(snapshot=&apos;backup&apos;)
[&apos;test&apos;, &apos;test2&apos;]

&gt;&gt;&gt; lib.delete(&apos;test&apos;)

&gt;&gt;&gt; lib.delete(&apos;test2&apos;)

&gt;&gt;&gt; lib.list_symbols()
[]

&gt;&gt;&gt; lib.list_symbols(snapshot=&apos;backup&apos;)
[&apos;test&apos;, &apos;test2&apos;]

&gt;&gt;&gt; lib.read(&apos;test&apos;)
~/arctic/arctic/store/version_store.py in _read_metadata(self, symbol, as_of, read_preference)
    455         metadata = _version.get(&apos;metadata&apos;, None)
    456         if metadata is not None and metadata.get(&apos;deleted&apos;, False) is True:
--&gt; 457             raise NoDataFoundException(&quot;No data found for %s in library %s&quot; % (symbol, self._arctic_lib.get_name()))
    458 
    459         return _version

NoDataFoundException: No data found for test in library arctic.vstore


&gt;&gt;&gt; lib.read(&apos;test&apos;, as_of=&apos;backup&apos;)
VersionedItem(symbol=test,library=arctic.vstore,data=&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;,version=4,metadata=None,host=127.0.0.1)

&gt;&gt;&gt; lib.read(&apos;test&apos;, as_of=&apos;backup&apos;).data 
               data
date       id      
2016-01-01 1    100
2016-01-02 1    200
2016-01-03 1    300
</code></pre><h1 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h1><p>附加</p>
<pre><code>append(symbol, item)
    Appends data from item to symbol&apos;s data in the database.

    Is not idempotent

    Parameters
    ----------
    symbol: str
        the symbol for the given item in the DB
    item: DataFrame or Series
        the data to append
</code></pre><p>用法示例：</p>
<pre><code>&gt;&gt;&gt; df = DataFrame(data={&apos;data&apos;: [100, 200, 300]},
                  index=MultiIndex.from_tuples([(dt(2016, 1, 1), 1),
                                                (dt(2016, 1, 2), 1),
                                                (dt(2016, 1, 3), 1)],
                                               names=[&apos;date&apos;, &apos;id&apos;]))


&gt;&gt;&gt; lib.write(&apos;test&apos;, df, chunk_size=&apos;M&apos;)
&gt;&gt;&gt; lib.read(&apos;test&apos;)
               data
date       id
2016-01-01 1    100
2016-01-02 1    200
2016-01-03 1    300

&gt;&gt;&gt; lib.append(&apos;test&apos;, df)
&gt;&gt;&gt; lib.append(&apos;test&apos;, df)
&gt;&gt;&gt; lib.read(&apos;test&apos;)
               data
date       id
2016-01-01 1    100
           1    100
           1    100
2016-01-02 1    200
           1    200
           1    200
2016-01-03 1    300
           1    300
           1    300
</code></pre><p>删除</p>
<pre><code>delete(symbol, chunk_range=None)
    Delete all chunks for a symbol, or optionally, chunks within a range

    Parameters
    ----------
    symbol : str
        symbol name for the item
    chunk_range: range object
        a date range to delete
</code></pre><p>用法示例：</p>
<pre><code>&gt;&gt;&gt; lib.read(&apos;test&apos;)
               data
date       id
2016-01-01 1    100
2016-01-03 1    300

&gt;&gt;&gt; lib.delete(&apos;test&apos;, chunk_range=pd.date_range(&apos;2016-01-01&apos;, &apos;2016-01-01&apos;))
&gt;&gt;&gt; lib.read(&apos;test&apos;)
               data
date       id
2016-01-03 1    300
</code></pre><p>get_chunk_ranges</p>
<pre><code>get_chunk_ranges(symbol, chunk_range=None, reverse=False)
    Returns a generator of (Start, End) tuples for each chunk in the symbol

    Parameters
    ----------
    symbol: str
        the symbol for the given item in the DB
    chunk_range: None, or a range object
        allows you to subset the chunks by range
    reverse: boolean

    Returns
    -------
    generator
</code></pre><p>用法示例：</p>
<pre><code>&gt;&gt;&gt; list(lib.get_chunk_ranges(&apos;new_name&apos;))
[(&apos;2016-01-01&apos;, &apos;2016-01-01&apos;), (&apos;2016-01-03&apos;, &apos;2016-01-03&apos;)]
</code></pre><p>获取信息</p>
<pre><code>get_info(symbol)
    Returns information about the symbol, in a dictionary

    Parameters
    ----------
    symbol: str
        the symbol for the given item in the DB

    Returns
    -------
    dictionary
</code></pre><p>迭代器</p>
<pre><code>iterator(symbol, chunk_range=None):
    Returns a generator that accesses each chunk in ascending order

    Parameters
    ----------
    symbol: str
        the symbol for the given item in the DB
    chunk_range: None, or a range object
        allows you to subset the chunks by range

    Returns
    -------
    generator
</code></pre><p>list_symbols</p>
<pre><code>list_symbols()
    Returns all symbols in the library

    Returns
    -------
    list of str
</code></pre><p>读</p>
<pre><code>read(symbol, chunk_range=None, filter_data=True, **kwargs)
    Reads data for a given symbol from the database.

    Parameters
    ----------
    symbol: str
        the symbol to retrieve
    chunk_range: object
        corresponding range object for the specified chunker (for
        DateChunker it is a DateRange object or a DatetimeIndex,
        as returned by pandas.date_range
    filter_data: boolean
        perform chunk level filtering on the data (see filter in _chunker)
        only applicable when chunk_range is specified
    kwargs: ?
        values passed to the serializer. Varies by serializer

    Returns
    -------
    DataFrame or Series
</code></pre><p>用法示例：</p>
<pre><code>&gt;&gt;&gt; dr = pd.date_range(start=&apos;2010-01-01&apos;, periods=1000, freq=&apos;D&apos;)
&gt;&gt;&gt; df = DataFrame(data={&apos;data&apos;: np.random.randint(0, 100, size=1000),
                         &apos;date&apos;: dr
                        })

&gt;&gt;&gt; lib.write(&apos;symbol_name&apos;, df, chunk_size=&apos;M&apos;)
&gt;&gt;&gt; lib.read(&apos;symbol_name&apos;, chunk_range=pd.date_range(&apos;2012-09-01&apos;, &apos;2016-01-01&apos;))
    data       date
0     61 2012-09-01
1     69 2012-09-02
2     96 2012-09-03
3     23 2012-09-04
4     66 2012-09-05
5     54 2012-09-06
6     21 2012-09-07
7     92 2012-09-08
8     95 2012-09-09
9     24 2012-09-10
10    87 2012-09-11
11    33 2012-09-12
12    59 2012-09-13
13    54 2012-09-14
14    48 2012-09-15
15    67 2012-09-16
16    73 2012-09-17
17    72 2012-09-18
18     6 2012-09-19
19    24 2012-09-20
20     8 2012-09-21
21    50 2012-09-22
22    40 2012-09-23
23    45 2012-09-24
24     8 2012-09-25
25    73 2012-09-26
</code></pre><p>改名</p>
<pre><code>rename(from_symbol, to_symbol)
    Rename a symbol

    Parameters
    ----------
    from_symbol: str
        the existing symbol that will be renamed
    to_symbol: str
        the new symbol name
</code></pre><p>reverse_iterator</p>
<pre><code>reverse_iterator(symbol, chunk_range=None):
    Returns a generator that accesses each chunk in descending order

    Parameters
    ----------
    symbol: str
        the symbol for the given item in the DB
    chunk_range: None, or a range object
        allows you to subset the chunks by range

    Returns
    -------
    generator
</code></pre><p>更新</p>
<pre><code>update(symbol, item, chunk_range=None, upsert=False, **kwargs)
    Overwrites data in DB with data in item for the given symbol.

    Is idempotent

    Parameters
    ----------
    symbol: str
        the symbol for the given item in the DB
    item: DataFrame or Series
        the data to update
    chunk_range: None, or a range object
        If a range is specified, it will clear/delete the data within the
        range and overwrite it with the data in item. This allows the user
        to update with data that might only be a subset of the
        original data.
    upsert: bool
        if True, will write the data even if the symbol does not exist.
    kwargs:
        optional keyword args passed to write during an upsert. Includes:
        chunk_size
        chunker
</code></pre><p>写</p>
<pre><code>write(symbol, item, chunker=DateChunker(), **kwargs)
    Writes data from item to symbol in the database

    Parameters
    ----------
    symbol: str
        the symbol that will be used to reference the written data
    item: Dataframe or Series
        the data to write the database
    chunker: Object of type Chunker
        A chunker that chunks the data in item
    kwargs:
        optional keyword args that are passed to the chunker. Includes:
        chunk_size:
            used by chunker to break data into discrete chunks.
            see specific chunkers for more information about this param.
</code></pre><p>用法示例：</p>
<pre><code>&gt;&gt;&gt; dr = pd.date_range(start=&apos;2010-01-01&apos;, periods=1000, freq=&apos;D&apos;)
&gt;&gt;&gt; df = DataFrame(data={&apos;data&apos;: np.random.randint(0, 100, size=1000),
                         &apos;date&apos;: dr
                        })

&gt;&gt;&gt; lib.write(&apos;symbol_name&apos;, df, chunk_size=&apos;M&apos;)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/30/量化投资/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/30/量化投资/" itemprop="url">量化投资</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-30T07:53:05+08:00">
                2020-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/投资/" itemprop="url" rel="index">
                    <span itemprop="name">投资</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于量化投资的学习和思考</p>
<h1 id="数学角度看量化"><a href="#数学角度看量化" class="headerlink" title="数学角度看量化"></a>数学角度看量化</h1><p>在量化投资单纯从数学角度看，一个交易系统/交易模型仅仅是一个从行情序列到资金曲线的映射。</p>
<p>f(ts,para) = E</p>
<p>其中f是一个交易系统，ts是某一个投资标的（股票、期货、期权、外汇等）的行情时间序列para是交易系统的参数组，E是资金曲线。</p>
<p>任何一个模型都会有参数，有参数就会碰到参数寻优，过拟合等问题。</p>
<p>参数优化是基于历史数据进行的策略优化。而历史并不能完全重演。历史中表现优秀的参数，在交易中未必会表现很好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/29/PRINCIPLES/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/29/PRINCIPLES/" itemprop="url">PRINCIPLES</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-29T07:49:48+08:00">
                2020-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/财务/" itemprop="url" rel="index">
                    <span itemprop="name">财务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>《原则》全书一共分为三个部分 ： 第一部分是个人经历的介绍；第二部分是生活原则的描述；第三部分是工作原则的描述。</p>
<h2 id="生活原则"><a href="#生活原则" class="headerlink" title="生活原则"></a>生活原则</h2><h3 id="拥抱现实；应对现实"><a href="#拥抱现实；应对现实" class="headerlink" title="拥抱现实；应对现实"></a>拥抱现实；应对现实</h3><ul>
<li>不要混淆愿望与现实</li>
<li>不要担心自己形象；而关心能不能实现你的目标</li>
<li>要重视后续的结果以及后续的后续</li>
<li>不要让痛苦妨碍自己的进步</li>
<li>不要把不好归咎与任何人；从自己身上找原因</li>
</ul>
<h4 id="做一个超级现实的人"><a href="#做一个超级现实的人" class="headerlink" title="做一个超级现实的人"></a>做一个超级现实的人</h4><p>在乎梦想；但是扎根于现实</p>
<p>梦想 + 现实 + 决心 = 成功的生活</p>
<h4 id="理解现实；是任何良好结果的根本依据"><a href="#理解现实；是任何良好结果的根本依据" class="headerlink" title="理解现实；是任何良好结果的根本依据"></a>理解现实；是任何良好结果的根本依据</h4><p>因为当真相与愿望不符的时候；大部分人抗拒真相。 这种认知偏差；有很多心理学现象与之相关；如房间里的大象等。在《需求》 和 《思考快与慢中》都有过相关的论述。说到底；就是要扎根现实。理解现实，然后，改变自己；改变现实</p>
<h4 id="头脑需要极度开放"><a href="#头脑需要极度开放" class="headerlink" title="头脑需要极度开放"></a>头脑需要极度开放</h4><p>头脑极度开放；极度透明有利于快速学习与改进<br>这几乎是整个生活原则中最重要的一条原则了<br>你头脑越是开放，越是不会自欺欺人。其他人给你的反馈就会更加诚实（“你如果是喜欢听与自己意见一样的话；就会得到的反馈就越是虚假”）</p>
<p>如果这些人是可信的人 ；你将会收获很多。</p>
<p>不要担心其他人的看法；那会成为你的障碍<br>你必须以你认为最好的独特的方式行事；这样做一定会收到反馈；我们必须以开放的头脑思考这些反馈。</p>
<p>尽管你的极度透明会让你感觉到不舒服；但是这样对你是最好的。</p>
<p>极度求真，极度透明会带来更加有意义的工作和更好的人际关系</p>
<h4 id="观察自然；学习现实规律"><a href="#观察自然；学习现实规律" class="headerlink" title="观察自然；学习现实规律"></a>观察自然；学习现实规律</h4><p>两种视角：</p>
<p>自上而下 找事务背后规律： 理解市场；供求关系；宏观大势</p>
<p>自下而上去验证具体情况 ： 验证具体情况是否相符合</p>
<p>不要固守你认为事物 “应该” 是什么样子<br>保持客观： 不要让偏见使我们无法认识客观情况。</p>
<p>当看到一个认为自然是错误的想法的时候，先假设自己是错的，然后想办法弄明白为什么自然如此是合理的。<br>一个例子： 大草原上鬣狗吃了小幼马，我们会心生同情。但是事实上这是自然法则，自然会走向整体最优，而不是个体最优化。</p>
<p>人也是一样。人们会把对自己或者自己相关的人不利的事情叫做坏事，而忽略更大的好。 群体中也有这种倾向，如宗教歧视。</p>
<p>只根据事务对个人的影响就判断绝对的好与坏是不合理的。（这点很难做到）</p>
<p>一个东西要好，必须符合现实规律，并促进整体的进化。这会带来更大的好。</p>
<p>进化是宇宙中最强大的力量</p>
<p>这里推荐一本书：《基因之河》；</p>
<p>关于进化：还有一本书，《自私的基因》， 也非常开脑洞。</p>
<h4 id="进化是生命最大的成就和回报"><a href="#进化是生命最大的成就和回报" class="headerlink" title="进化是生命最大的成就和回报"></a>进化是生命最大的成就和回报</h4><p>个人激励机制必须符合群体目标。<br>比如自然给了性行为个体巨大的快乐激励，来达到群体的不断进化迭代。</p>
<p>现实为了趋向整体最大化，而不是个体。<br>为了整体做贡献，你就有可能收到回报。自然选择让更好产品得以保留，结果是整体的最优化。</p>
<p>通过快速试错以适应现实是无价的。<br>实验和适应能带来更快的进步。</p>
<p>要意识到你即是一切，又什么都不是，并决定你想成为什么样子。<br>“个人即是一切，又什么都不是，这是一个巨大的悖论。”</p>
<p>你的未来取决于你的视角。<br>你的未来取决于你的如何看待事物，关心什么事物。<br>必须决定你多大程度将别人的利益放在你的自己利益之上。<br>拥抱现实，从自然的角度俯视自身很美妙。</p>
<h4 id="理解自然提供的现实教训"><a href="#理解自然提供的现实教训" class="headerlink" title="理解自然提供的现实教训"></a>理解自然提供的现实教训</h4><p>收益递减规律。</p>
<p>任何东西在从太少变太多的过程中，边际收益都会递减。</p>
<p>没有痛苦就没有收获。</p>
<p>“人需要困难，这对健康来说是必须的。”</p>
<h4 id="痛苦-反思-进步"><a href="#痛苦-反思-进步" class="headerlink" title="痛苦 + 反思 = 进步"></a>痛苦 + 反思 = 进步</h4><p>如果以正确的态度面对痛苦，感到痛苦就是你的幸运！！即使反思痛苦。</p>
<p>最好的就是在痛苦的当时就进行反思。</p>
<h4 id="考虑后续与再后续的结果"><a href="#考虑后续与再后续的结果" class="headerlink" title="考虑后续与再后续的结果"></a>考虑后续与再后续的结果</h4><p>直接结果很可能是诱惑或者痛苦。</p>
<p>如果因为直接结果的痛苦而不去做，就很难获得大的成功。</p>
<p>如果因为直接结果的诱惑而去做了，就会遭遇更大的失败。</p>
<h4 id="接受结果：内控点"><a href="#接受结果：内控点" class="headerlink" title="接受结果：内控点"></a>接受结果：内控点</h4><p>在生活中不论遇到什么情况，如果你能够负起责任，进行良好的决策，而不是抱怨你无法控制的事情，你将更加容易知找到幸福。</p>
<p>不要为喜不喜欢自己的处境担忧，你必须根据自己的愿望找到实现愿望的途径。然后，鼓起勇气坚持下去。</p>
<p>后面的五步流程会给到你一定帮助。</p>
<h4 id="从更高的层次腐蚀机器"><a href="#从更高的层次腐蚀机器" class="headerlink" title="从更高的层次腐蚀机器"></a>从更高的层次腐蚀机器</h4><p>想象自己是一个大机器里的一个小机器，拥有改变自己而变得更好的能力。</p>
<p>通过比较你实现的结果和你的目标，你就能确定如何改进你的机器。</p>
<p>却别作为机器设计者的你和作为机器中工作者的你。</p>
<p>最难的事情是在自身所处的环境中，客观的看待我们自己，不高看自己，不承担不应该承担的任务。</p>
<p>擅于请教领域达人，因为你很难客观看待自己，所以你需要依赖他人的意见以及证据。</p>
<p>如果你头脑开放，足够有决心，你几乎可以实现任何愿望。</p>
<h3 id="五部流程，实现你的人生愿望"><a href="#五部流程，实现你的人生愿望" class="headerlink" title="五部流程，实现你的人生愿望"></a>五部流程，实现你的人生愿望</h3><ol>
<li>明确目标</li>
<li>找到阻碍目标的问题，并且不容忍问题</li>
<li>准确诊断问题，找到问题根源</li>
<li>规划可以解决问题的方案</li>
<li>做一切必要的事儿来践行这些方案，实现成果</li>
</ol>
<p>这五个步骤形成一个循环。</p>
<p>需要注意的点是：</p>
<p>专注每个点。设定目标的时候就设定目标，不要想实现和出错（延迟批判）。</p>
<p>当你诊断问题的时候，就不要想如何解决问题，混淆这两个问题会导致你无法发现真正的问题。</p>
<p>坚持这些规则。挫折，会让你难受，不完美永远存在。好消息是你可以从错误中吸收学习和成长。</p>
<p>坚持下去你就会有收获。</p>
<h4 id="有明确的目标"><a href="#有明确的目标" class="headerlink" title="有明确的目标"></a>有明确的目标</h4><p>排列目标优先级。你几乎可以得到你想要的任何东西，但你无法得到所有东西。</p>
<p>分清目标和欲望</p>
<p>目标是你真正需要的东西</p>
<p>欲望是你想要但会阻碍你实现目标的东西（比如偷懒）</p>
<p>不要因为某个目标无法实现就否定它</p>
<p>伟大的期望创造伟大的能力</p>
<p>拥有灵活性和自我归咎，那没什么能阻止你</p>
<p>知道如何应对挫折很重要</p>
<p>逆境中，重要的是守住优势，减少损失</p>
<p>你的任务永远是做出尽可能少的选择</p>
<p>成功不难，关键在于少犯错误</p>
<h4 id="找出问题但是不容忍"><a href="#找出问题但是不容忍" class="headerlink" title="找出问题但是不容忍"></a>找出问题但是不容忍</h4><p>令人痛苦的问题当做考验你潜在进步的机会</p>
<p>当你遇到一个问题，那就是一个机会。 大多数人不喜欢这么做</p>
<p>不要逃避问题，承认问题是改变的第一步</p>
<p>忍痛前行，痛苦会给你汇报</p>
<p>不要把某个原因当做问题本身</p>
<p>我无法得到很好的睡眠是一个原因，我工作效率低是一个问题，前者可能是后者的原因。</p>
<p>重点解决大问题</p>
<h4 id="找到问题根源"><a href="#找到问题根源" class="headerlink" title="找到问题根源"></a>找到问题根源</h4><p>弄清楚问题，这需要时间去诊断，一次良好的诊断一般需要15-60分钟。</p>
<p>区分直接与根本原因</p>
<h4 id="规划方案"><a href="#规划方案" class="headerlink" title="规划方案"></a>规划方案</h4><p>前进之前先回顾</p>
<p>设置方案，写下来所有人都能看到，严格执行</p>
<p>规划先于行动，好规划不一定要很多时间</p>
<h4 id="坚定的从头到尾执行方案"><a href="#坚定的从头到尾执行方案" class="headerlink" title="坚定的从头到尾执行方案"></a>坚定的从头到尾执行方案</h4><h4 id="保持谦逊"><a href="#保持谦逊" class="headerlink" title="保持谦逊"></a>保持谦逊</h4><p>与其他人高质量交流</p>
<p>保持谦逊，你可以从别人那里得到你需要的东西</p>
<p>找到你最大的弱点，并处理掉</p>
<h4 id="理解自己的认知，理解他人与你不同"><a href="#理解自己的认知，理解他人与你不同" class="headerlink" title="理解自己的认知，理解他人与你不同"></a>理解自己的认知，理解他人与你不同</h4><p>提升认知能力，保持头脑开放，从他人那里获得帮助，你可以实现很多事情</p>
<h3 id="做到头脑极度开放"><a href="#做到头脑极度开放" class="headerlink" title="做到头脑极度开放"></a>做到头脑极度开放</h3><p>这一章几乎是生活原则中最重要的一章。(雷达里奥说；这也是全书最重要的一章)<br>主要重点有两个： 一个是为什么要保持头脑开放；一个是什么情况下你是头脑封闭的。<br>认识到第二点其实很重要，这会帮助你的日常反思。</p>
<p>认识到自己的障碍和不足；</p>
<p>寻求可信度高的人的意见，设身处地思考和理解，对比自己的，最终做出更好的决策。</p>
<h4 id="认识你的两大障碍"><a href="#认识你的两大障碍" class="headerlink" title="认识你的两大障碍"></a>认识你的两大障碍</h4><p>障碍一：意识障碍；理解你的自我意识障碍</p>
<p>主要是你潜意识里的防备机制； 使你难以接受你的错误和缺点。</p>
<p>我们有一些根植于内心的需求：</p>
<ul>
<li>被爱</li>
<li>被需要</li>
<li>害怕死亡</li>
<li>害怕失去</li>
<li>害怕自己无意义</li>
</ul>
<p>不能让“想要自己正确的需求 ” 压倒 “找出真相” 的需求</p>
<p>当有人和你意见不一样；并且要求你解释的时候；你的大脑会把这样的东西当做 攻击；你会变得愤怒。</p>
<p>如果你想要成功；你需要克制这一点。 这样的人你也可以观察一下；身边到处都是。你也可以反思一下；你自己是不是这样的人。（怎么判断自己有这种倾向在后面会说到）</p>
<p>障碍二；思维障碍；理解你的思维盲点障碍</p>
<p>人很难理解自己看不到的东西；《需求》 这本书里也有说到 塞缪尔思反射 。</p>
<p>如果你一心只想告诉对方自己的认为正确的想法；你就是 一个头脑封闭的人</p>
<p>这样的话；当其他人给你展示各种可能性威胁和批评的时候；你可能会看不见。也无法领会。</p>
<h4 id="奉行头脑极度开放；不仅仅是“承认自己可能错了”"><a href="#奉行头脑极度开放；不仅仅是“承认自己可能错了”" class="headerlink" title="奉行头脑极度开放；不仅仅是“承认自己可能错了”"></a>奉行头脑极度开放；不仅仅是“承认自己可能错了”</h4><p>如果你知道自己有盲点；你就能找到一种解决办法。</p>
<p>头脑开放不仅仅是“承认自己可能错了”，但是依旧坚持自己的观点。这样作用不大。</p>
<p>a. 诚恳的想想自己也许并不知道最好的解决办法是什么。能不能妥善处理“不知道”很重要<br>很多糟糕的决定是因为他们相信自己是对的。而头脑极度开放的人知道。找到问题的答案很重要。</p>
<p>b. 决策有两个步骤： 1 分析所有相关信息；2 决策<br>听听其他人的观点并加以思考，不会削弱你独立思考，自主决策的自由。只会帮你拥有更广的角度</p>
<p>c. 不要担心你的形象，只担心如何实现目标<br>做出优秀决策的人，很少坚信自己已经掌握了最好的答案，承认自己有缺点 和 盲点 ，并试图了解更多，克服缺陷和盲点。</p>
<p>d 不吸收，产出也不大好。</p>
<p>e 从他人的角度，设身处地，才能评估另一种观点的价值<br>高度接受自己错了的可能性，鼓励别人告诉自己错在哪里</p>
<p>f 记住：你是在寻找最好的答案，不是自己能得出最好的答案<br>知道自己不知道，无比重要。 自问一下，我是不是只是从自己的角度看问题</p>
<p>g 搞清楚你是在争论还是在试图理解一个问题，根据可信度，想想哪种更加合理</p>
<p>可信度 有两个特征：</p>
<p>反复的在相关领域成功找到答案（至少三次，拥有硬履历）</p>
<p>再被责问的情况下能对自己的观点做出很好的解释</p>
<h4 id="领会并感激：深思熟虑的意见分歧"><a href="#领会并感激：深思熟虑的意见分歧" class="headerlink" title="领会并感激：深思熟虑的意见分歧"></a>领会并感激：深思熟虑的意见分歧</h4><p>沟通方式要让对方觉得，你是试图在理解</p>
<p>你需要提问，而不是做出陈述，心平气和的进行讨论，并鼓励对方也这么做。</p>
<p>（某些时候）人们在产生分歧时变得愤怒是毫无意义的</p>
<p>当讨论陷入僵局，最没效果的就是，你试图在脑子中将所有的事情都弄得清楚。</p>
<h4 id="和可信的，愿意表达分歧的人一起审视你的观点"><a href="#和可信的，愿意表达分歧的人一起审视你的观点" class="headerlink" title="和可信的，愿意表达分歧的人一起审视你的观点"></a>和可信的，愿意表达分歧的人一起审视你的观点</h4><p>既单独询问专家，也鼓励专家在我面前展现意见分歧。</p>
<p>为最坏的做准备。使其看起来不那么糟糕。</p>
<h4 id="（重要）识别你头脑封闭的迹象"><a href="#（重要）识别你头脑封闭的迹象" class="headerlink" title="（重要）识别你头脑封闭的迹象"></a>（重要）识别你头脑封闭的迹象</h4><p>a 封闭的人：不喜欢看到自己的观点被挑战</p>
<p>不开放：会因为无法说服他人而沮丧，而不是好奇对方为何看法不同。</p>
<p>开放： 更想了解为什么会有分歧，明白自己可能是错的</p>
<p>b 封闭的人：喜欢做陈述而不是提问</p>
<p>开放的人，可信度很高的人，经常会提出很多问题。并真诚的相信自己可能是错的</p>
<p>c 封闭的人: 更关心自己是否被理解，而不是理解他人</p>
<p>封闭的人： 通常担心自己没有被理解</p>
<p>开放的人：觉得有必要从他人的视角看问题。</p>
<p>d 封闭的人：“我可能错了。。。但这是我的观点”</p>
<p>这是一个敷衍的回答，人们借此来固守自己的观点</p>
<p>最好提出一个问题，而不是做出一个断言</p>
<p>e 封闭的人 ： 封闭的人，阻挠别人的发言</p>
<p>开放的人更喜欢倾听发言，鼓励表达</p>
<p>f 封闭的人 : 很难同时拥有两种想法</p>
<p>同时持有两种想法，并且能保持独立思考。</p>
<p>g 封闭的人 ： 缺乏谦逊</p>
<p>开放的人： 时刻担忧自己可能是错误的。</p>
<h4 id="如何做到头脑开放？"><a href="#如何做到头脑开放？" class="headerlink" title="如何做到头脑开放？"></a>如何做到头脑开放？</h4><ul>
<li>利用自己的痛苦进行高质量的思考</li>
<li>一旦觉得愤怒，冷静下来，以深思熟虑的方式看待眼前问题</li>
<li>一定要客观，愿意倾听</li>
<li>重视证据</li>
<li>冥想</li>
</ul>
<h3 id="理解人与人大大不相同"><a href="#理解人与人大大不相同" class="headerlink" title="理解人与人大大不相同"></a>理解人与人大大不相同</h3><p>要理解：左脑思考偏逻辑，右脑思考偏情感。</p>
<p>要理解：最长发生的斗争就是意识与潜意识，情绪和思考的斗争。</p>
<p>如果你意识不到你的潜意识的存在，你的行为就会像西奥迪尼在《影响力》中做的那个比喻一样：是一个带着按钮的录音机；一按就播放。</p>
<p>比如：听到别人反对时候的被侵犯感。</p>
<p>要知道：我们可以改变，通过习惯。</p>
<h3 id="如何做出正确的决策"><a href="#如何做出正确的决策" class="headerlink" title="如何做出正确的决策"></a>如何做出正确的决策</h3><p>好决策最大的敌人是坏情绪</p>
<p>如果你被情绪绑架，你将不可能作出好的决策。作出决策时候必须用逻辑，理性，事实。</p>
<p>正如荣格所说：“如果你不知道潜意识的存在，否则潜意识就会主导你的人生，而你称之为命运”</p>
<p>先了解，后决策</p>
<ol>
<li>是什么 ：先了解决策的基础知识，既包括“是什么”，也包括宏观的因果关系</li>
</ol>
<p>“习惯性的问自己，我在了解相关情况吗？我已经掌握了决策的所有知识了么？”</p>
<p>为了了解：</p>
<p>要知道应该问什么人</p>
<p>不要高估自己的可信度</p>
<p>不要不区分别人的可信度（在相同领域有过3次以上成功经验的硬简历）</p>
<p>区分事实和观点，不要听到什么信什么，别人说的和做的很可能不一样。</p>
<p>80/20原则：你从20%的信息获得80%的价值，明白关键性的20%是什么</p>
<p>不要完美主义，完美主义的边际效用是 递减的</p>
<ol start="2">
<li>怎么做 ：权衡结果，考虑结果，后续的结果，后续的后续的结果</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/backtrader/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/05/backtrader/" itemprop="url">backtrader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T20:31:54+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/投资/" itemprop="url" rel="index">
                    <span itemprop="name">投资</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Backtrader"><a href="#Backtrader" class="headerlink" title="Backtrader"></a>Backtrader</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前基于Python的量化回测框架有很多，开源框架有zipline、vnpy、pyalgotrader和backtrader等，而量化平台有Quantopian（国外）、聚宽、万矿、优矿、米筐、掘金等，这些量化框架或平台各有优劣。就个人而言，比较偏好用backtrader，因为它功能十分完善，有完整的使用文档，安装相对简单（直接pip安装即可）。优点是运行速度快，支持pandas的矢量运算；支持参数自动寻优运算，内置了talib股票分析技术指标库；支持多品种、多策略、多周期的回测和交易；支持pyflio、empyrica分析模块库、alphalens多因子分析模块库等；扩展灵活，可以集成TensorFlow、PyTorch和Keras等机器学习、神经网络分析模块。而不足之处在于，backtrader学习起来相对复杂，编程过程中使用了大量的元编程（类class），如果Python编程基础不扎实（尤其是类的操作），学起来会感到吃力。本文作为backtrader的入门系列之一，对其运行框架进行简要介绍，并以实际案例展示量化回测的过程。</p>
<h2 id="Backtrader介绍"><a href="#Backtrader介绍" class="headerlink" title="Backtrader介绍"></a>Backtrader介绍</h2><p>如果将backtrader包分解为核心组件，主要包括以下组成部分：</p>
<ol>
<li>数据加载（Data Feed）：将交易策略的数据加载到回测框架中。</li>
<li>交易策略（Strategy）：该模块是编程过程中最复杂的部分，需要设计交易决策，得出买入/卖出信号。</li>
<li>回测框架设置（ Cerebro）：需要设置（i）初始资金（ii）佣金（iii）数据馈送（iv）交易策略交易头寸大小。</li>
<li>运行回测：运行Cerebro回测并打印出所有已执行的交易。</li>
<li>评估性能（Analyzers）:以图形和风险收益等指标对交易策略的回测结果进行评价。</li>
</ol>
<p>“Lines”是backtrader回测的数据，由一系列的点组成，通常包括以下类别的数据：Open（开盘价）, High（最高价）, Low（最低价）, Close（收盘价）, Volume（成交量）, OpenInterest（无的话设置为0）。Data Feeds（数据加载）、Indicators（技术指标）和Strategies（策略）都会生成 Lines。价格数据中的所有”Open” (开盘价)按时间组成一条 Line。所以，一组含有以上6个类别的价格数据，共有6条 Lines。如果算上“DateTime”（时间，可以看作是一组数据的主键），一共有7条 Lines。当访问一条 Line 的数据时，会默认指向下标为 0 的数据。最后一个数据通过下标 -1 来访问，在-1之后是索引0，用于访问当前时刻。因此，在回测过程中，无需知道已经处理了多少条/分钟/天/月，”0”一直指向当前值，下标 -1 来访问最后一个值。</p>
<p><img src="/2020/09/05/backtrader/批注 2020-09-06 181654.png" alt=""></p>
<h2 id="Backtrader环境搭建"><a href="#Backtrader环境搭建" class="headerlink" title="Backtrader环境搭建"></a>Backtrader环境搭建</h2><ul>
<li>安装python环境 (anaconda)</li>
<li>pip install backtrader[plotting]</li>
<li>新建jupyterProject文件夹，在其路径栏输入 jupyter lab,按enter键,等待启用jupyter</li>
</ul>
<h2 id="回测应用实例"><a href="#回测应用实例" class="headerlink" title="回测应用实例"></a>回测应用实例</h2><p>量化回测说白了是使用历史数据去验证交易策略的性能，因此回测的第一步是搭建交易策略，这也是backtrader要设置的最重要和复杂的部分，策略设定好后，其余部分的代码编写是手到擒来。</p>
<h3 id="构建策略（Strategy）"><a href="#构建策略（Strategy）" class="headerlink" title="构建策略（Strategy）"></a>构建策略（Strategy）</h3><p>交易策略类代码包含重要的参数和用于执行策略的功能，要定义的参数或函数名如下：</p>
<p>（1）params-全局参数，可选：更改交易策略中变量/参数的值，可用于参数调优。</p>
<p>（2）log：日志，可选：记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。</p>
<p>（3） <strong>init</strong>：用于初始化交易策略的类实例的代码。</p>
<p>（4）notify_order，可选：跟踪交易指令（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。</p>
<p>（5）notify_trade，可选：跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。</p>
<p>（6）next，必选：制定交易策略的函数，策略模块最核心的部分。</p>
<p>下面以一个简单的单均线策略为例，展示backtrader的使用过程，即当收盘价上涨突破20日均线买入（做多），当收盘价下跌跌穿20日均线卖出（做空）。为简单起见，不报告交易回测的日志，因此log、notify_order和notify_trade函数省略不写。</p>
<pre><code>class my_strategy1(bt.Strategy):
    #全局设定交易策略的参数
    params=(
        (&apos;maperiod&apos;,20),
           )

    def __init__(self):
        #指定价格序列
        self.dataclose=self.datas[0].close
        # 初始化交易指令、买卖价格和手续费
        self.order = None
        self.buyprice = None
        self.buycomm = None

        #添加移动均线指标，内置了talib模块
        self.sma = bt.indicators.SimpleMovingAverage(
                      self.datas[0], period=self.params.maperiod)
    def next(self):
        if self.order: # 检查是否有指令等待执行, 
            return
        # 检查是否持仓   
        if not self.position: # 没有持仓
            #执行买入条件判断：收盘价格上涨突破20日均线
            if self.dataclose[0] &gt; self.sma[0]:
                #执行买入
                self.order = self.buy(size=500)         
        else:
            #执行卖出条件判断：收盘价格跌破20日均线
            if self.dataclose[0] &lt; self.sma[0]:
                #执行卖出
                self.order = self.sell(size=500)
</code></pre><h3 id="数据加载（Data-Feeds）"><a href="#数据加载（Data-Feeds）" class="headerlink" title="数据加载（Data Feeds）"></a>数据加载（Data Feeds）</h3><p>策略设计好后，第二步是数据加载，backtrader提供了很多数据接口，包括quandl（美股）、yahoo、pandas格式数据等，我们主要分析A股数据。</p>
<pre><code>#先引入后面可能用到的包（package）
import pandas as pd  
from datetime import datetime
import backtrader as bt
import matplotlib.pyplot as plt
%matplotlib inline   

#正常显示画图时出现的中文和负号
from pylab import mpl
mpl.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;]使用tushare获取浦发银行（代码：600000）数据。
#使用tushare旧版接口获取数据
import tushare as ts 
def get_data(code,start=&apos;2010-01-01&apos;,end=&apos;2020-03-31&apos;):
    df=ts.get_k_data(code,autype=&apos;qfq&apos;,start=start,end=end)
    df.index=pd.to_datetime(df.date)
    df[&apos;openinterest&apos;]=0
    df=df[[&apos;open&apos;,&apos;high&apos;,&apos;low&apos;,&apos;close&apos;,&apos;volume&apos;,&apos;openinterest&apos;]]
    return df
dataframe=get_data(&apos;600000&apos;)

#回测期间
start=datetime(2010, 3, 31)
end=datetime(2020, 3, 31)
# 加载数据
data = bt.feeds.PandasData(dataname=dataframe,fromdate=start,todate=end)
</code></pre><h3 id="回测设置（Cerebro）"><a href="#回测设置（Cerebro）" class="headerlink" title="回测设置（Cerebro）"></a>回测设置（Cerebro）</h3><p>回测设置主要包括几项：回测系统初始化，数据加载到回测系统，添加交易策略， broker设置（如交易资金和交易佣金），头寸规模设置作为策略一部分的交易规模等，最后显示执行交易策略时积累的总资金和净收益。</p>
<h1 id="初始化cerebro回测系统设置"><a href="#初始化cerebro回测系统设置" class="headerlink" title="初始化cerebro回测系统设置"></a>初始化cerebro回测系统设置</h1><p>cerebro = bt.Cerebro()  </p>
<p>#将数据传入回测系统<br>cerebro.adddata(data) </p>
<h1 id="将交易策略加载到回测系统中"><a href="#将交易策略加载到回测系统中" class="headerlink" title="将交易策略加载到回测系统中"></a>将交易策略加载到回测系统中</h1><p>cerebro.addstrategy(my_strategy1) </p>
<h1 id="设置初始资本为10-000"><a href="#设置初始资本为10-000" class="headerlink" title="设置初始资本为10,000"></a>设置初始资本为10,000</h1><p>startcash = 10000<br>cerebro.broker.setcash(startcash) </p>
<h1 id="设置交易手续费为-0-2"><a href="#设置交易手续费为-0-2" class="headerlink" title="设置交易手续费为 0.2%"></a>设置交易手续费为 0.2%</h1><p>cerebro.broker.setcommission(commission=0.002) </p>
<h3 id="执行回测"><a href="#执行回测" class="headerlink" title="执行回测"></a>执行回测</h3><p>输出回测结果。</p>
<pre><code>print(f&apos;净收益: {round(pnl,2)}&apos;)

d1=start.strftime(&apos;%Y%m%d&apos;)
d2=end.strftime(&apos;%Y%m%d&apos;)
print(f&apos;初始资金: {startcash}\n回测期间：{d1}:{d2}&apos;)
#运行回测系统
cerebro.run()
#获取回测结束后的总资金
portvalue = cerebro.broker.getvalue()
pnl = portvalue - startcash
#打印结果
print(f&apos;总资金: {round(portvalue,2)}&apos;)结果如下：
初始资金: 10000
回测期间：20100331:20200331
总资金: 12065.36
净收益: 2065.36
</code></pre><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>对上述结果进行可视化，使用内置的matplotlib画图。至此，简单的单均线回测就完成了。下面图形展示了浦发银行在回测期间的价格走势、买卖点和交易总资金的变化等。</p>
<pre><code># 画图
cerebro.plot()
</code></pre><h2 id="回测实例"><a href="#回测实例" class="headerlink" title="回测实例"></a>回测实例</h2><pre><code>from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey

class TestStrategy(bt.Strategy):

    params = (
        (&apos;exitbars&apos;, 5),
        (&apos;maperiod&apos;, 24),
        (&apos;printlog&apos;, False),
    )

    def log(self, txt, dt=None, doprint=False):
        &apos;&apos;&apos; Logging function for this strategy&apos;&apos;&apos;
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print(&apos;[%s] %s&apos; % (dt.isoformat(), txt))

    def __init__(self):
       # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close
        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None
        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)

        # Indicators for the plotting show
        bt.indicators.ExponentialMovingAverage(self.datas[0], period=25)
        bt.indicators.WeightedMovingAverage(
            self.datas[0], period=25).subplot = True
        bt.indicators.StochasticSlow(self.datas[0])
        bt.indicators.MACDHisto(self.datas[0])
        rsi = bt.indicators.RSI(self.datas[0])
        bt.indicators.SmoothedMovingAverage(rsi, period=10)
        bt.indicators.ATR(self.datas[0]).plot = False

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &apos;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log(&apos;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&apos;Order Canceled/Margin/Rejected&apos;)

        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log(&apos;OPERATION PROFIT： GROSS %.2f, NET %.2f&apos; %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log(&apos;Close: %.2f&apos; % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

       # Check if we are in the market
        if not self.position:
            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] &gt; self.sma[0]:
                # current close less than previous close
                if self.dataclose[-1] &lt; self.dataclose[-2]:
                    # previous close less than the previous close

                    # BUY, BUY, BUY!!! (with default parameters)
                    self.log(&apos;BUY CREATE: %.2f&apos; % self.dataclose[0])

                    # Keep track of the created order to avoid a 2nd order
                    self.order = self.buy()
        else:
            # Already in the market ... we might sell
            if self.dataclose[0] &lt; self.sma[0]:
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log(&apos;SELL CREATE: %.2f&apos; % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

    def stop(self):
        self.log(&apos;(MA Period %2d) Ending Value %.2f&apos; %
                 (self.params.maperiod, self.broker.getvalue()), doprint=True)


if __name__ == &apos;__main__&apos;:
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)
    # cerebro.optstrategy(TestStrategy, maperiod=range(10, 31))

    # 初始化数据的路径
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, &apos;.\\/datas\\/orcl-1995-2014.txt&apos;)
    # Create a Data Feed,reverse 代表是否反转数据
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values after this date
        todate=datetime.datetime(2000, 12, 31),
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)
    # 改变账户初始金额
    cerebro.broker.set_cash(100000.0)

    # Set the commission - 0.1% ... divide by 100 to remove the % 交易佣金设置
    cerebro.broker.setcommission(commission=0.001)
    # 设置每笔交易交易的股票数量
    cerebro.addsizer(bt.sizers.FixedSize, stake=10)

    print(&apos;Starting Portfolio Value: %.2f&apos; % cerebro.broker.getvalue())

    cerebro.run()

    print(&apos;Final Portfolio Value: %.2f&apos; % cerebro.broker.getvalue())
    # 画图
    cerebro.plot()
</code></pre><p>先来回顾一下交易策略模块（Strategy）的构成。交易策略类代码包含参数或函数名如下：</p>
<p>（1）params-全局参数，可选：更改交易策略中变量/参数的值，可用于参数调优。</p>
<p>（2）log：日志，可选：记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。</p>
<p>（3） init：用于初始化交易策略的类实例的代码。</p>
<p>（4）notify_order，可选：跟踪交易指令（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。</p>
<p>（5）notify_trade，可选：跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。</p>
<p>（6）next，必选：制定交易策略的函数，策略模块最核心的部分。</p>
<p>下面仍然以简单均线策略为例，重点介绍参数寻优和交易日志报告。</p>
<p>实现代码如下：</p>
<pre><code>#先引入后面可能用到的包（package）
import pandas as pd  
import numpy as np
import tushare as ts 
import matplotlib.pyplot as plt
%matplotlib inline   
#正常显示画图时出现的中文和负号
from pylab import mpl
mpl.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;]
mpl.rcParams[&apos;axes.unicode_minus&apos;]=False
</code></pre><p>params是全局参数，maperiod是MA均值的长度，默认15天，printlog为打印交易日志，默认不输出结果，策略模块的核心在next（）函数。</p>
<pre><code>from datetime import datetime
import backtrader as bt
class MyStrategy(bt.Strategy):
    params=((&apos;maperiod&apos;,15),
            (&apos;printlog&apos;,False),)
    def __init__(self):
        #指定价格序列
        self.dataclose=self.datas[0].close
        # 初始化交易指令、买卖价格和手续费
        self.order = None
        self.buyprice = None
        self.buycomm = None
        #添加移动均线指标
        self.sma = bt.indicators.SimpleMovingAverage(
                      self.datas[0], period=self.params.maperiod)
    #策略核心，根据条件执行买卖交易指令（必选）
    def next(self):
        # 记录收盘价
        #self.log(f&apos;收盘价, {dataclose[0]}&apos;)
        if self.order: # 检查是否有指令等待执行, 
            return
        # 检查是否持仓   
        if not self.position: # 没有持仓
            #执行买入条件判断：收盘价格上涨突破15日均线
            if self.dataclose[0] &gt; self.sma[0]:
                self.log(&apos;BUY CREATE, %.2f&apos; % self.dataclose[0])
                #执行买入
                self.order = self.buy()         
        else:
            #执行卖出条件判断：收盘价格跌破15日均线
            if self.dataclose[0] &lt; self.sma[0]:
                self.log(&apos;SELL CREATE, %.2f&apos; % self.dataclose[0])
                #执行卖出
                self.order = self.sell()
    #交易记录日志（可省略，默认不输出结果）
    def log(self, txt, dt=None,doprint=False):
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print(f&apos;{dt.isoformat()},{txt}&apos;)
    #记录交易执行情况（可省略，默认不输出结果）
    def notify_order(self, order):
        # 如果order为submitted/accepted,返回空
        if order.status in [order.Submitted, order.Accepted]:
            return
        # 如果order为buy/sell executed,报告价格结果
        if order.status in [order.Completed]: 
            if order.isbuy():
                self.log(f&apos;买入:\n价格:{order.executed.price},\
                成本:{order.executed.value},\
                手续费:{order.executed.comm}&apos;)
                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:
                self.log(f&apos;卖出:\n价格：{order.executed.price},\
                成本: {order.executed.value},\
                手续费{order.executed.comm}&apos;)
            self.bar_executed = len(self) 
        # 如果指令取消/交易失败, 报告结果
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&apos;交易失败&apos;)
        self.order = None
    #记录交易收益情况（可省略，默认不输出结果）
    def notify_trade(self,trade):
        if not trade.isclosed:
            return
        self.log(f&apos;策略收益：\n毛收益 {trade.pnl:.2f}, 净收益 {trade.pnlcomm:.2f}&apos;)
    #回测结束后输出结果（可省略，默认输出结果）
    def stop(self):
        self.log(&apos;(MA均线： %2d日) 期末总资金 %.2f&apos; %
                 (self.params.maperiod, self.broker.getvalue()), doprint=True)
</code></pre><p>下面定义一个主函数，用于对某股票指数（个股）在指定期间进行回测，使用tushare的旧接口获取数据，包含开盘价、最高价、最低价、收盘价和成交量。这里主要以3到30日均线为例进行参数寻优，考察以多少日均线与价格的交叉作为买卖信号能获得最大的收益。</p>
<pre><code>def main(code,start,end=&apos;&apos;,startcash=10000,qts=500,com=0.001):
    #创建主控制器
    cerebro = bt.Cerebro()      
    #导入策略参数寻优
    cerebro.optstrategy(MyStrategy,maperiod=range(3, 31))    
    #获取数据
    df=ts.get_k_data(code,autype=&apos;qfq&apos;,start=start,end=end)
    df.index=pd.to_datetime(df.date)
    df=df[[&apos;open&apos;,&apos;high&apos;,&apos;low&apos;,&apos;close&apos;,&apos;volume&apos;]]
    #将数据加载至回测系统
    data = bt.feeds.PandasData(dataname=df)    
    cerebro.adddata(data)
    #broker设置资金、手续费
    cerebro.broker.setcash(startcash)           
    cerebro.broker.setcommission(commission=com)    
    #设置买入设置，策略，数量
    cerebro.addsizer(bt.sizers.FixedSize, stake=qts)   
    print(&apos;期初总资金: %.2f&apos; %                    
    cerebro.broker.getvalue())    
    cerebro.run(maxcpus=1)    
    print(&apos;期末总资金: %.2f&apos; % cerebro.broker.getvalue())
</code></pre><p>再定义一个画图函数，对相应股票（指数）在某期间的价格走势和累计收益进行可视化。</p>
<pre><code>def plot_stock(code,title,start,end):
    dd=ts.get_k_data(code,autype=&apos;qfq&apos;,start=start,end=end)
    dd.index=pd.to_datetime(dd.date)
    dd.close.plot(figsize=(14,6),color=&apos;r&apos;)
    plt.title(title+&apos;价格走势\n&apos;+start+&apos;:&apos;+end,size=15)
    plt.annotate(f&apos;期间累计涨幅:{(dd.close[-1]/dd.close[0]-1)*100:.2f}%&apos;, xy=(dd.index[-150],dd.close.mean()), 
             xytext=(dd.index[-500],dd.close.min()), bbox = dict(boxstyle = &apos;round,pad=0.5&apos;,
            fc = &apos;yellow&apos;, alpha = 0.5),
             arrowprops=dict(facecolor=&apos;green&apos;, shrink=0.05),fontsize=12)
    plt.show()
</code></pre><p>以上证综指为例，回测期间为2010-01-01至2020-03-30，期间累计收益率为-15.31%，惨不忍睹。</p>
<pre><code>面分别对3-30日均线进行回测，这里假设指数可以交易，初始资金为100万元，每次交易100股，注意如果指数收盘价乘以100超过可用资金，会出现交易失败的情况，换句话说在整个交易过程中，是交易固定数量的标的，因此仓位的大小跟股价有直接关系。

main(&apos;sh&apos;,&apos;2010-01-01&apos;,&apos;&apos;,1000000,100)
</code></pre><p><img src="/2020/09/05/backtrader/批注 2020-09-06 183530.png" alt=""></p>
<pre><code>plot_stock(&apos;sh&apos;,&apos;上证综指&apos;,&apos;2010-01-01&apos;,&apos;2020-03-30&apos;)
</code></pre><p><img src="/2020/09/05/backtrader/批注 2020-09-06 183419.png" alt=""></p>
<h2 id="Analyzers模块"><a href="#Analyzers模块" class="headerlink" title="Analyzers模块"></a>Analyzers模块</h2><p>Analyzers模块涵盖了评价一个量化策略的完整指标，如常见的夏普比率、年化收益率、最大回撤、Calmar比率等等。Analyzers模块原生代码能获取的评价指标如下图所示，其中TradeAnalyzer和PeriodStats又包含了不少指标。由于采用元编程，Analyzers的扩展性较强，可以根据需要添加自己的分析指标，如获取回测期间每一时刻对应的总资金。</p>
<p><img src="/2020/09/05/backtrader/批注 2020-09-06 183823.png" alt=""></p>
<h3 id="策略模块编写"><a href="#策略模块编写" class="headerlink" title="策略模块编写"></a>策略模块编写</h3><p>（1）params-全局参数，可选：更改交易策略中变量/参数的值，可用于参数调优。</p>
<p>（2）log：日志，可选：记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。</p>
<p>（3） init：用于初始化交易策略的类实例的代码。</p>
<p>（4）notify_order，可选：跟踪交易指令（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。</p>
<p>（5）notify_trade，可选：跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。</p>
<p>（6）next，必选：制定交易策略的函数，策略模块最核心的部分。</p>
<p>（7）其他，包括start()、nextsstart()、stop()、prenext()、notify_fund()、notify_store()和notify_cashvalue。</p>
<p>面以技术分析指标RSI（不了解的请自行百度）的择时策略为例，当RSI&lt;30时买入，RSI&gt;70时卖出。为了简便起见，策略模块中只包含最核心的交易信号。</p>
<pre><code>import pandas as pd
import backtrader as bt
from datetime import datetime
class MyStrategy(bt.Strategy):
    params=((&apos;short&apos;,30),
            (&apos;long&apos;,70),)
    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(
                   self.data.close, period=21)
    def next(self):
        if not self.position:
            if self.rsi &lt; self.params.short:
                self.buy()
        else:
            if self.rsi &gt; self.params.long:
                self.sell()
</code></pre><h3 id="回测设置"><a href="#回测设置" class="headerlink" title="回测设置"></a>回测设置</h3><p>回测系统设置与之前一样，主要是数据加载、交易本金、手续费、交易数量的设置，此处以tushare的旧接口获取股票002537的交易数据进行量化回测。</p>
<pre><code>from __future__ import (absolute_import, division, print_function,  
                        unicode_literals) 
import tushare as ts
#以股票002537为例
df=ts.get_k_data(&apos;002537&apos;,start=&apos;2010-01-01&apos;)
df.index=pd.to_datetime(df.date)
#df[&apos;openinterest&apos;] = 0
df=df[[&apos;open&apos;,&apos;high&apos;,&apos;low&apos;,&apos;close&apos;,&apos;volume&apos;]]
data = bt.feeds.PandasData(dataname=df,                               
                            fromdate=datetime(2013, 1, 1),                               
                            todate=datetime(2020, 4, 17) )
# 初始化cerebro回测系统设置                           
cerebro = bt.Cerebro()  
# 加载数据
cerebro.adddata(data) 
# 将交易策略加载到回测系统中
cerebro.addstrategy(MyStrategy) 
# 设置初始资本为100,000
cerebro.broker.setcash(100000.0) 
#每次固定交易数量
cerebro.addsizer(bt.sizers.FixedSize, stake=1000) 
#手续费
cerebro.broker.setcommission(commission=0.001) 
</code></pre><h3 id="运行回测"><a href="#运行回测" class="headerlink" title="运行回测"></a>运行回测</h3><p>这里重点是Analyzers模块的调用与结果输出，调用模块是cerebro.addanalyzer()，再从模块中获取分析指标，如夏普比率是bt.analyzers.SharpeRatio，然后是给该指标重命名方便之后调用，即 _name=’SharpeRatio’。要获取分析指标，需要先执行回测系统，cerebro.run()，并将回测结果赋值给变量results，分析指标存储在results[0]里 (strat变量代替)，通过strat.analyzers.SharpeRatio.get_analysis()即可获取相应数据，其他指标操作方法类似。</p>
<pre><code>print(&apos;初始资金: %.2f&apos; % cerebro.broker.getvalue())
cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name = &apos;SharpeRatio&apos;)
cerebro.addanalyzer(bt.analyzers.DrawDown, _name=&apos;DW&apos;)
results = cerebro.run()
strat = results[0]
print(&apos;最终资金: %.2f&apos; % cerebro.broker.getvalue())
print(&apos;夏普比率:&apos;, strat.analyzers.SharpeRatio.get_analysis())
print(&apos;回撤指标:&apos;, strat.analyzers.DW.get_analysis())

输出结果：
初始资金: 100000.00
最终资金: 110215.33
夏普比率: OrderedDict([(&apos;sharperatio&apos;, 0.094)])
回撤指标: AutoOrderedDict([(&apos;len&apos;, 280), (&apos;drawdown&apos;, 1.01), (&apos;moneydown&apos;, 1126.60), (&apos;max&apos;, AutoOrderedDict([(&apos;len&apos;, 280), (&apos;drawdown&apos;, 3.61), (&apos;moneydown&apos;, 4016.60)]))])
</code></pre><h3 id="回测结果可视化"><a href="#回测结果可视化" class="headerlink" title="回测结果可视化"></a>回测结果可视化</h3><p>下面输出回测图表，一张大图上包含了三张图：</p>
<p>（1）资金变动图：可以看到在实施交易策略的数据期内，资金的盈利/损失。</p>
<p>（2）交易收益/亏损。蓝色（红色）点表示获利（亏损）交易以及获利（亏损）多少。</p>
<p>（3）价格图表。绿色和红色箭头分别表示交易策略的进入点和退出点。黑线是交易标的随时间变化的价格， 条形图表示每个条形图期间资金的交易量。</p>
<p><img src="/2020/09/05/backtrader/批注 2020-09-06 184322.png" alt=""></p>
<h3 id="Analyzers模块指标可视化"><a href="#Analyzers模块指标可视化" class="headerlink" title="Analyzers模块指标可视化"></a>Analyzers模块指标可视化</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>init</strong></p>
<p>任何类在生成的时候都是先调用这一初始化构造函数。也就是说，在实例生成的时候，这个函数将被调用。</p>
<ol>
<li><p>Birth: start</p>
<p> start方法在cerebro告诉strategy，是时候开始行动了，也就是说，通知策略激活的时候被调用。</p>
</li>
<li><p>Childhood: prenext</p>
<p> 有些技术指标，比如我们提到的MA，存在一个窗口，也就是说，需要n天的数据才能产生指标，那么在没有产生之前呢？这个prenext方法就会被自动调用。</p>
</li>
<li><p>Adulthood: next<br>这个方法是最核心的，就是每次移动到下一的时间点，策略将会调用这个方法，所以，策略的核心往往都是写在这个方法里的。</p>
</li>
<li><p>Death: stop</p>
<p> 策略的生命周期结束，cerebro把这一策略退出。</p>
</li>
</ol>
<h2 id="策略当中的回调函数"><a href="#策略当中的回调函数" class="headerlink" title="策略当中的回调函数"></a>策略当中的回调函数</h2><p>Strategy 类就像真实世界的交易员一样，当交易执行的时候，他会得到一些消息，譬如order是否执行，一笔trader赚了多少钱，等等。这些消息都将在Strategy类中通过回调函数被得以知晓。这些回调函数如下：</p>
<p>notify_order(order)：下的单子，order的任何状态变化都将引起这一方法的调用</p>
<p>notify_trade(trade)：任何一笔交易头寸的改变都将调用这一方法</p>
<p>notify_cashvalue(cash, value)：任何现金和资产组合的变化都将调用这一方法<br>notify_store(msg, *args, **kwargs)：可以结合cerebro类进行自定义方法的调用</p>
<p>那么问题接踵而至，这里我们只关注前2种方法中监测对象的可变化方式。</p>
<p>trade指的是一笔头寸，trade是open的状态指当前时刻，这一标的的头寸从0变到某一非零值。trade是closed则刚好相反。</p>
<pre><code>trade大概有如下常用属性
ref: 唯一id
size (int): trade的当前头寸
price (float): trade资产的当前价格
value (float): trade的当前价值
commission (float): trade的累计手续费
pnl (float): trade的当前pnl
pnlcomm (float): trade的当前pnl减去手续费
isclosed (bool): 当前时刻trade头寸是否归零
isopen (bool): 新的交易更新了trade
justopened (bool): 新开头寸
dtopen (float): trade open的datetime
dtclose (float): trade close的datetime

Orders

order是strategy发出的指令，让cerebro去执行。
strategy自身有buy, sell and close方法来生成order，cancel方法来取消一笔order。下单的方式有很多，后续会介绍，这里主要讲回调函数中，咱们可以获得哪些信息。
order.status可以返回order的当前状态

order.isbuy可以获得这笔order是否是buy

order.executed.price
order.executed.value
order.executed.comm
</code></pre><p>分别可以获得执行order的价格，总价，和手续费</p>
<pre><code>class TestStrategy(bt.Strategy):
    params = (
        (&apos;maperiod&apos;, 15),
    )

    def log(self, txt, dt=None):
        &apos;&apos;&apos; Logging function fot this strategy&apos;&apos;&apos;
        dt = dt or self.datas[0].datetime.date(0)
        print(&apos;%s, %s&apos; % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)
    def start(self):
        print(&quot;the world call me!&quot;)

    def prenext(self):
        print(&quot;not mature&quot;)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enougth cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    &apos;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log(&apos;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f&apos; %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log(&apos;Order Canceled/Margin/Rejected&apos;)

        self.order = None
</code></pre><p>可以看到打印出来的结果中，有start和prenext，最后当然也有death</p>
<h2 id="Backtrader的indicator"><a href="#Backtrader的indicator" class="headerlink" title="Backtrader的indicator"></a>Backtrader的indicator</h2><pre><code>def __init__(self):
    # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
    self.dataclose = self.datas[0].close

    # To keep track of pending orders and buy price/commission
    self.order = None
    self.buyprice = None
    self.buycomm = None

    # Add a MovingAverageSimple indicator
    self.sma = bt.indicators.SimpleMovingAverage(
        self.datas[0], period=self.params.maperiod)
</code></pre><p> 这里的最后，我们使用了一个backtrader内置的indicator，后续我们将尝试自己编写一个indicator。</p>
<h2 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h2><p>datafeed，也就是cerebro的本源，数据</p>
<pre><code>dataframe = pd.read_csv(&apos;dfqc.csv&apos;, index_col=0, parse_dates=True)
dataframe[&apos;openinterest&apos;] = 0
data = bt.feeds.PandasData(dataname=dataframe,
                        fromdate = datetime.datetime(2015, 1, 1),
                        todate = datetime.datetime(2016, 12, 31)
                        )
# Add the Data Feed to Cerebro
cerebro.adddata(data)

2014-03-13 00:00:00.005,1.425,1.434,1.449,1.418,457767208.0
2014-03-14 00:00:00.005,1.429,1.422,1.436,1.416,196209439.0
2014-03-17 00:00:00.005,1.433,1.434,1.437,1.422,250946201.0
2014-03-18 00:00:00.005,1.434,1.425,1.437,1.424,245516577.0
2014-03-19 00:00:00.005,1.423,1.419,1.423,1.406,331866195.0
2014-03-20 00:00:00.005,1.412,1.408,1.434,1.407,379443759.0
2014-03-21 00:00:00.005,1.406,1.463,1.468,1.403,825467935.0

dataframe = pd.read_csv(&apos;dfqc.csv&apos;, index_col=0, parse_dates=True)
</code></pre><p>把csv读入pandas的参数，index_col=0表示第一列时间数据是作为pandas 的index的，parse_dates=Ture是自动把数据中的符合日期的格式变成datetime类型。为什么要这样呢？其实读入后的pandas长怎么样都是由backtrader规定的</p>
<p>pandas的要求的结构，我们就知道，不仅仅有self.datas[0].close,还会有self.datas[0].open。也确实如此。只是我们通常拿close作为一个价格基准</p>
<pre><code>self.datas[0].close
</code></pre><p>返回的是一个lines。lines是backtrader一个很重要的概念，可以理解为时间序列流，这类数据，后面可以跟index，也就是说，可以有</p>
<pre><code>self.datas[0].close[0]
self.datas[0].close[-1]
</code></pre><p>这里的index是有意义的，0代表当前时刻，-1代表前一时刻，1代表后一时刻，以此类推</p>
<p>所以在next中使用self.dataclose[0],self.dataclose[-1]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/qa函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/29/qa函数/" itemprop="url">qa函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-29T11:08:26+08:00">
                2020-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/投资/" itemprop="url" rel="index">
                    <span itemprop="name">投资</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h2 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h2><h3 id="QA-Account"><a href="#QA-Account" class="headerlink" title="QA_Account()"></a>QA_Account()</h3><p>QA_Account() 是quantaxis的核心类, 其作用是一个可以使用规则兼容各种市场的账户类<br>1.3.0以后, QA_Account需要由组合来进行创建(推荐)</p>
<pre><code>调用方式
import QUANTAXIS as QA
user = QA.QA_User(username =&apos;quantaxis&apos;, password = &apos;quantaxis&apos;)
portfolio=user.new_portfolio(&apos;x1&apos;)
account = *portfolio.new_account*(account_cookie=&apos;test&apos;)

QA_AccountPRO?
Init signature:
QA_AccountPRO(
    user_cookie:str,
    portfolio_cookie:str,
    account_cookie=None,
    strategy_name=None,
    market_type=&apos;stock_cn&apos;,
    frequence=&apos;day&apos;,
    broker=&apos;backtest&apos;,
    init_hold={},
    init_cash=1000000,
    commission_coeff=0.00025,
    tax_coeff=0.001,
    margin_level={},
    allow_t0=False,
    allow_sellopen=False,
    allow_margin=False,
    running_environment=&apos;backtest&apos;,
    auto_reload=False,
    generated=&apos;direct&apos;,
    start=None,
    end=None,
)
Docstring:     
JOB是worker 需要接受QA_EVENT 需要完善RUN方法
👻QA_Broker 继承这个类
👻QA_Account 继承这个类
👻QA_OrderHandler 继承这个类
这些类都要实现run方法，在其它线程🌀中允许自己的业务代码
File:           /usr/local/lib/python3.6/site-packages/QUANTAXIS/QAARP/QAAccountPro.py
Type:           type
Subclasses:     
accpro = *portfolio.new_accountpro*(&apos;pro2&apos;,market_type=QA.MARKET_TYPE.STOCK_CN)
accpro.positions
{}
*accpro.receive_deal*?
Signature:
accpro.receive_deal(
    code,
    trade_id:str,
    order_id:str,
    realorder_id:str,
    trade_price,
    trade_amount,
    trade_towards,
    trade_time,
    message=None,
)
Docstring: &lt;no docstring&gt;
File:      /usr/local/lib/python3.6/site-packages/QUANTAXIS/QAARP/QAAccountPro.py
Type:      method
`accpro.receive_deal`(&apos;000001&apos;,&apos;001&apos;,&apos;001&apos;,&apos;0001&apos;,trade_price=12,trade_amount=10000,trade_towards=QA.ORDER_DIRECTION.BUY,trade_time=&apos;2020-08-18&apos;)
*accpro.positions*
{&apos;000001&apos;: &lt; QAPOSITION 000001 amount 10000/0 &gt;}
*accpro.history_table*


*accpro.send_order?*
Signature:
accpro.send_order(
    code=None,
    amount=None,
    time=None,
    towards=None,
    price=None,
    money=None,
    order_model=&apos;LIMIT&apos;,
    amount_model=&apos;by_amount&apos;,
    order_id=None,
    position_id=None,
    *args,
    **kwargs,
)
Docstring: &lt;no docstring&gt;
File:      /usr/local/lib/python3.6/site-packages/QUANTAXIS/QAARP/QAAccountPro.py
Type:      method

基于期货市场的账户初始化
future_account = portfolio.new_account(account_cookie =&apos;future&apos;,allow_t0=True,allow_margin=True,allow_sellopen=True, running_environment=QA.MARKET_TYPE.FUTURE_CN)

account的其他属性可以.出来，可以自己试着看
*accpro.cash*
[1000000, 879970.0, 779945.0]
*accpro.cash_available*
779945.0
*accpro.get_history*
*accpro.get_position*(&apos;000001&apos;)

pos2 = accpro.get_position(&apos;000002&apos;)

*pos2.message*
{&apos;code&apos;: &apos;000002&apos;,
 &apos;instrument_id&apos;: &apos;000002&apos;,
 &apos;user_id&apos;: &apos;pro2&apos;,
 &apos;portfolio_cookie&apos;: &apos;x1&apos;,
 &apos;username&apos;: &apos;quantaxis&apos;,
 &apos;position_id&apos;: &apos;3e2cd89e-7143-4e0e-b344-40571e84eda5&apos;,
 &apos;account_cookie&apos;: &apos;pro2&apos;,
 &apos;frozen&apos;: {},
 &apos;name&apos;: None,
 &apos;spms_id&apos;: None,
 &apos;oms_id&apos;: None,
 &apos;market_type&apos;: &apos;stock_cn&apos;,
 &apos;exchange_id&apos;: None,
 &apos;moneypreset&apos;: 100000,
 &apos;moneypresetLeft&apos;: 0.0,
 &apos;lastupdatetime&apos;: &apos;&apos;,
 &apos;volume_long_today&apos;: 5000,
 &apos;volume_long_his&apos;: 0,
 &apos;volume_long&apos;: 5000,
 &apos;volume_short_today&apos;: 0,
 &apos;volume_short_his&apos;: 0,
 &apos;volume_short&apos;: 0,
 &apos;volume_long_frozen_today&apos;: 0,
 &apos;volume_long_frozen_his&apos;: 0,
 &apos;volume_long_frozen&apos;: 0,
 &apos;volume_short_frozen_today&apos;: 0,
 &apos;volume_short_frozen_his&apos;: 0,
 &apos;volume_short_frozen&apos;: 0,
 &apos;margin_long&apos;: 100000.0,
 &apos;margin_short&apos;: 0,
 &apos;margin&apos;: 100000.0,
 &apos;position_price_long&apos;: 20.0,
 &apos;position_cost_long&apos;: 100000.0,
 &apos;position_price_short&apos;: 0,
 &apos;position_cost_short&apos;: 0.0,
 &apos;open_price_long&apos;: 20.0,
 &apos;open_cost_long&apos;: 100000.0,
 &apos;open_price_short&apos;: 0,
 &apos;open_cost_short&apos;: 0.0,
 &apos;trades&apos;: [],
 &apos;orders&apos;: {},
 &apos;last_price&apos;: 20,
 &apos;float_profit_long&apos;: 0.0,
 &apos;float_profit_short&apos;: 0.0,
 &apos;float_profit&apos;: 0.0,
 &apos;position_profit_long&apos;: 0.0,
 &apos;position_profit_short&apos;: 0.0,
 &apos;position_profit&apos;: 0.0}

*pos2.volume_long*
5000
*pos2.volume_long_today*
5000
*pos2.volume_long_his*
0
*pos2.last_price*
20
*pos2.on_price_change*(21)
if pos2.float_profit_long &gt; 2000:
    print(&apos;sell&apos;)
sell
</code></pre><h3 id="QIFIAccount"><a href="#QIFIAccount" class="headerlink" title="QIFIAccount"></a>QIFIAccount</h3><pre><code>from QIFIAccount import QIFI_Account
aifiacc = QIFI_Account(username=&apos;x2&apos;,password=&apos;x2&apos;,)
aifiacc.initial()
Create new Account
aifiacc?
Type:           QIFI_Account
String form:    &lt;QIFIAccount.QAQIFIAccount.QIFI_Account object at 0x7f6e3b2dfc18&gt;
File:           /usr/local/lib/python3.6/site-packages/QIFIAccount/QAQIFIAccount.py
Docstring:      &lt;no docstring&gt;
Init docstring:
Initial
QIFI Account是一个基于 DIFF/ QIFI/ QAAccount后的一个实盘适用的Account基类


1. 兼容多持仓组合
2. 动态计算权益

使用 model = SIM/ REAL来切换


sr = aifiacc.send_order(&apos;003&apos;,10,12,ORDER_DIRECTION.BUY)
aifiacc.send_order?
Signature:
aifiacc.send_order(
    code:str,
    amount:float,
    price:float,
    towards:int,
    order_id:str=&apos;&apos;,
)
Docstring: &lt;no docstring&gt;
File:      /usr/local/lib/python3.6/site-packages/QIFIAccount/QAQIFIAccount.py
Type:      method
sr = aifiacc.send_order(&apos;004&apos;,10.0,12.0,QA.ORDER_DIRECTION.BUY)
{&apos;volume_long&apos;: 0, &apos;volume_short&apos;: 0, &apos;volume_long_frozen&apos;: 0, &apos;volume_short_frozen&apos;: 0}
{&apos;volume_long&apos;: 0, &apos;volume_short&apos;: 0}
order check success
下单成功 b3f155c7-ab2b-4ac1-94b7-08b6af152738
td = aifiacc.make_deal(sr)
全部成交 b3f155c7-ab2b-4ac1-94b7-08b6af152738
update trade
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/20/QUANTAXIS/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/20/QUANTAXIS/" itemprop="url">QUANTAXIS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-20T21:47:00+08:00">
                2020-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/投资/" itemprop="url" rel="index">
                    <span itemprop="name">投资</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="安装cmder"><a href="#安装cmder" class="headerlink" title="安装cmder"></a>安装cmder</h2><ol>
<li><p>官网下载地址</p>
<p> <code>http://cmder.net/</code></p>
<p> 下载好解压包可直接使用</p>
</li>
<li><p>环境变量配置</p>
<p> 在系统属性里面配置环境变量，将Cmder.exe所在文件路径添加至path里</p>
</li>
</ol>
<p><img src="/2020/08/20/QUANTAXIS/1.webp" alt=""></p>
<p>win+R,输入cmder,确定，即可运行cmder</p>
<ol start="3">
<li><p>配置右键快捷启动</p>
<pre><code>// 设置任意地方鼠标右键启动Cmder
Cmder.exe /REGISTER ALL
</code></pre></li>
</ol>
<p><img src="/2020/08/20/QUANTAXIS/2.webp" alt=""></p>
<ol start="4">
<li><p>快捷键</p>
<p> Tab       自动路径补全<br> Ctrl+T    建立新页签<br> Ctrl+W    关闭页签<br> Ctrl+Tab  切换页签<br> Alt+F4    关闭所有页签<br> Alt+Shift+1 开启cmd.exe<br> Alt+Shift+2 开启powershell.exe<br> Alt+Shift+3 开启powershell.exe (系统管理员权限)<br> Ctrl+1      快速切换到第1个页签<br> Ctrl+n      快速切换到第n个页签( n值无上限)<br> Alt + enter 切换到全屏状态<br> Ctr+r       历史命令搜索<br> Tab         自动路径补全<br> Ctrl+T      建立新页签<br> Ctrl+W      关闭页签<br> Ctrl+Tab    切换页签<br> Alt+F4      关闭所有页签<br> Alt+Shift+1 开启cmd.exe<br> Alt+Shift+2 开启powershell.exe<br> Alt+Shift+3 开启powershell.exe (系统管理员权限)<br> Ctrl+1      快速切换到第1个页签<br> Ctrl+n      快速切换到第n个页签( n值无上限)<br> Alt + enter 切换到全屏状态<br> Ctr+r       历史命令搜索<br> Win+Alt+P   开启工具选项视窗</p>
</li>
<li><p>中文乱码问题</p>
</li>
</ol>
<p>将下面的4行命令添加到cmder/config/aliases文件末尾。</p>
<pre><code>l=ls --show-control-chars 
la=ls -aF --show-control-chars 
ll=ls -alF --show-control-chars 
ls=ls --show-control-chars -F
</code></pre><h2 id="安装docker桌面版"><a href="#安装docker桌面版" class="headerlink" title="安装docker桌面版"></a>安装docker桌面版</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><pre><code>https://www.docker.com/
</code></pre><p>下载Docker Desktop</p>
<h3 id="安装可能遇到的问题"><a href="#安装可能遇到的问题" class="headerlink" title="安装可能遇到的问题"></a>安装可能遇到的问题</h3><pre><code>Installation failed:one pre-requisite is not fullfilled
</code></pre><p>提示我们系统版本低，解决办法，伪装成专业版系统。用管理员权限开启运行[cmd]命令开启命令行，输入如下指令</p>
<pre><code>REG ADD &quot;HKEY_LOCAL_MACHINE\software\Microsoft\Windows NT\CurrentVersion&quot; /v EditionId /T REG_EXPAND_SZ /d Professional /F
</code></pre><p>再次安装docker可以成功</p>
<h2 id="下载QUANTAXIS的docker-compose-yaml文件"><a href="#下载QUANTAXIS的docker-compose-yaml文件" class="headerlink" title="下载QUANTAXIS的docker-compose.yaml文件"></a>下载QUANTAXIS的docker-compose.yaml文件</h2><pre><code>`https://github.com/QUANTAXIS/QUANTAXIS`
</code></pre><p>如果你是股票方向的 ==&gt;  选择 qa-service 下的docker-compose.yaml</p>
<p>如果你是期货方向的 ==&gt; 选择 qa-service-future 下的docker-compose.yaml</p>
<p>你可以理解 docker的构成类似搭积木的模式,  你需要这个功能的积木, 就选择他放在你的docker-compose.yaml里面</p>
<p>期货方向的yaml 比股票多一个  QACTPBEE的docker-container  [这是用于分发期货的tick行情所需的 股票则无需此积木]</p>
<p>可通过git拉取全部代码到本地，从本地拷贝出需要的dockerfile文件</p>
<h2 id="docker部署quantaxis"><a href="#docker部署quantaxis" class="headerlink" title="docker部署quantaxis"></a>docker部署quantaxis</h2><ol>
<li>选取一个空间较大的盘，最好不放c盘，新建quantaxis文件夹，将docker-compose.yaml拷贝到quantaxis文件夹</li>
<li><p>cd到quantaxis文件夹，运行如下命令</p>
<pre><code>docker volume create --name=qamg
docker volume create --name=qacode
docker-compose up -d
</code></pre></li>
</ol>
<p>意思在后台启动这个docker环境，如果需要控制台打印输出，则把-d去掉</p>
<ol start="3">
<li>在无报错的情况下，打开浏览器输入localhost:81即可看到</li>
</ol>
<p><img src="/2020/08/20/QUANTAXIS/3.jpg" alt=""></p>
<p>在上方随意点击栏目，都可进入登陆界面，默认密码是quantaxis</p>
<ol start="4">
<li>docker做了什么</li>
</ol>
<p>帮你直接开启你需要的服务</p>
<ul>
<li>27017 mongodb</li>
<li>8888 jupyter   （密码）quantaxis</li>
<li>8010 quantaxis_webserver</li>
<li>81 quantaxis_community 社区版界面</li>
<li>61208 系统监控</li>
<li>15672 qa-eventmq （密码）admin admin</li>
</ul>
<ol start="5">
<li><p>日志查看</p>
<pre><code>docker logs cron容器名
</code></pre></li>
<li><p>其他命令</p>
<pre><code>docker ps

docker stats

docker-compose top （必须到dockerfile文件夹目录下）

docker-compose ps （必须到dockerfile文件夹目录下）

docker stop $(docker ps -a -q)停止容器

docker rm $(docker ps -a -q)删除容器

docker-compose pull 更新（必须到dockerfile文件夹目录下）
docker-compose up -d 重启服务（必须到dockerfile文件夹目录下）
docker-compose stop 停止服务（必须到dockerfile文件夹目录下）

docker run  --rm -v qamg:/data/db \ -v $(pwd):/backup alpine \tar zcvf /backup/dbbackup.tar /data/db  备份数据库到当前目录下
docker run  --rm -v qamg:/data/db \
-v $(pwd):/backup alpine \
sh -c &quot;cd /data/db \
&amp;&amp; rm -rf diagnostic.data \
&amp;&amp; rm -rf journal \
&amp;&amp; rm -rf configdb \
&amp;&amp; cd / \
&amp;&amp; tar xvf /backup/dbbackup.tar&quot; 还原当前目录下的dbbackup.tar到mongod数据库

当更新了dockerfile后重启服务，之前保存的数据不会被清除
</code></pre></li>
</ol>
<h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><ol>
<li>先进入到jupyter的登陆页登陆，找到terminal</li>
</ol>
<p><img src="/2020/08/20/QUANTAXIS/4.jpg" alt=""></p>
<ol start="2">
<li>在点开的terminal界面中，输入quantaxis 回车, 进入quantaxis cli的命令行界面</li>
</ol>
<p><img src="/2020/08/20/QUANTAXIS/5.jpg" alt=""></p>
<ol start="3">
<li>在命令行界面 输入 save  按回车, 你可以看到许多命令行选项</li>
</ol>
<p><img src="/2020/08/20/QUANTAXIS/6.jpg" alt=""></p>
<ol start="4">
<li><p>参考</p>
<pre><code>save all  (股票/指数 的日线数据 | 权息数据 | 板块数据)  
save x   (股票/指数的 日线/分钟线数据  | 权息数据| 板块数据)

save future_min_all  (期货的全部合约的分钟线数据)
save future_min  (q期货主连的分钟线数据)

save future_day_all (期货全部合约的日线数据)
save future_day (期货主连的日线数据)

save index_day    (指数数据  此处也要存, 因为在做回测的时候, 需要沪深300作为标的对照物)
</code></pre></li>
<li><p>存完数据后可以打开notebook,做一个回测</p>
<pre><code>import QUANTAXIS as QA
import numpy as np
import pandas as pd
import datetime
st1=datetime.datetime.now()
# define the MACD strategy
def MACD_JCSC(dataframe, SHORT=12, LONG=26, M=9):
    &quot;&quot;&quot;
    1.DIF向上突破DEA，买入信号参考。
    2.DIF向下跌破DEA，卖出信号参考。
    &quot;&quot;&quot;
    CLOSE = dataframe.close
    DIFF = QA.EMA(CLOSE, SHORT) - QA.EMA(CLOSE, LONG)
    DEA = QA.EMA(DIFF, M)
    MACD = 2*(DIFF-DEA)

    CROSS_JC = QA.CROSS(DIFF, DEA)
    CROSS_SC = QA.CROSS(DEA, DIFF)
    ZERO = 0
    return pd.DataFrame({&apos;DIFF&apos;: DIFF, &apos;DEA&apos;: DEA, &apos;MACD&apos;: MACD, &apos;CROSS_JC&apos;: CROSS_JC, &apos;CROSS_SC&apos;: CROSS_SC, &apos;ZERO&apos;: ZERO})
</code></pre></li>
</ol>
<pre><code># create account
user = QA.QA_User(username=&apos;quantaxis&apos;, password=&apos;quantaxis&apos;)
portfolio = user.new_portfolio(&apos;qatestportfolio&apos;)


Account = portfolio.new_account(account_cookie=&apos;macd_stock&apos;, init_cash=1000000)
Broker = QA.QA_BacktestBroker()

QA.QA_SU_save_strategy(&apos;MACD_JCSC&apos;,&apos;Indicator&apos;,Account.account_cookie)
# get data from mongodb
QA.QA_SU_save_strategy(&apos;MACD_JCSC&apos;, &apos;Indicator&apos;,
                       Account.account_cookie, if_save=True)
data = QA.QA_fetch_stock_day_adv(
    [&apos;000001&apos;, &apos;000002&apos;, &apos;000004&apos;, &apos;600000&apos;], &apos;2017-09-01&apos;, &apos;2018-05-20&apos;)
data = data.to_qfq()

# add indicator
ind = data.add_func(MACD_JCSC)
# ind.xs(&apos;000001&apos;,level=1)[&apos;2018-01&apos;].plot()

data_forbacktest=data.select_time(&apos;2018-01-01&apos;,&apos;2018-05-01&apos;)


for items in data_forbacktest.panel_gen:
    for item in items.security_gen:
        ###################
        daily_ind=ind.loc[item.index]

        if daily_ind.CROSS_JC.iloc[0]&gt;0:
            order=Account.send_order(
                code=item.code[0], 
                time=item.date[0], 
                amount=1000, 
                towards=QA.ORDER_DIRECTION.BUY, 
                price=0, 
                order_model=QA.ORDER_MODEL.CLOSE, 
                amount_model=QA.AMOUNT_MODEL.BY_AMOUNT
                )
            #print(item.to_json()[0])
            Broker.receive_order(QA.QA_Event(order=order,market_data=item))
            trade_mes=Broker.query_orders(Account.account_cookie,&apos;filled&apos;)
            res=trade_mes.loc[order.account_cookie,order.realorder_id]
            order.trade(res.trade_id,res.trade_price,res.trade_amount,res.trade_time)
        elif daily_ind.CROSS_SC.iloc[0]&gt;0:
            #print(item.code)
            if Account.sell_available.get(item.code[0], 0)&gt;0:
                order=Account.send_order(
                    code=item.code[0], 
                    time=item.date[0], 
                    amount=Account.sell_available.get(item.code[0], 0), 
                    towards=QA.ORDER_DIRECTION.SELL, 
                    price=0, 
                    order_model=QA.ORDER_MODEL.MARKET, 
                    amount_model=QA.AMOUNT_MODEL.BY_AMOUNT
                    )
                #print
                Broker.receive_order(QA.QA_Event(order=order,market_data=item))
                trade_mes=Broker.query_orders(Account.account_cookie,&apos;filled&apos;)
                res=trade_mes.loc[order.account_cookie,order.realorder_id]
                order.trade(res.trade_id,res.trade_price,res.trade_amount,res.trade_time)
    Account.settle()

print(&apos;TIME -- {}&apos;.format(datetime.datetime.now()-st1))
print(Account.history)
print(Account.history_table)
print(Account.daily_hold)

# create Risk analysis
Risk = QA.QA_Risk(Account)

Account.save()
Risk.save()
</code></pre><ol start="6">
<li>推荐的做法</li>
</ol>
<p>使用最新的QAStrategy来做回测/模拟</p>
<p>首先 打开terminal (上面有讲), 输入</p>
<pre><code>pip install qastrategy
</code></pre><p>然后 新建一个notebook, 输入</p>
<pre><code>from QAStrategy import QAStrategyCTABase
import QUANTAXIS as QA
import pprint


class CCI(QAStrategyCTABase):

    def on_bar(self, bar):

        res = self.cci()

        print(res.iloc[-1])

        if res.CCI[-1] &lt; -100:

            print(&apos;LONG&apos;)

            if self.positions.volume_long == 0:
                self.send_order(&apos;BUY&apos;, &apos;OPEN&apos;, price=bar[&apos;close&apos;], volume=1)

            if self.positions.volume_short &gt; 0:
                self.send_order(&apos;SELL&apos;, &apos;CLOSE&apos;, price=bar[&apos;close&apos;], volume=1)

        elif res.CCI[-1] &gt; 100:
            print(&apos;SHORT&apos;)
            if self.positions.volume_short == 0:
                self.send_order(&apos;SELL&apos;, &apos;OPEN&apos;, price=bar[&apos;close&apos;], volume=1)
            if self.positions.volume_long &gt; 0:
                self.send_order(&apos;BUY&apos;, &apos;CLOSE&apos;, price=bar[&apos;close&apos;], volume=1)

    def cci(self,):
        return QA.QA_indicator_CCI(self.market_data, 61)

    def risk_check(self):
        pass
        # pprint.pprint(self.qifiacc.message)
</code></pre><p>然后 你可以自由指定回测/模拟</p>
<p>首先实例化这个类</p>
<pre><code>strategy =CCI(code=&apos;RB2005&apos;, frequence=&apos;1min&apos;,strategy_id=&apos;a3916de0-bd28-4b9c-bea1-94d91f1744ac&apos;, start=‘2020-01-01‘, end=‘2020-02-07’)
</code></pre><p>如果你需要测试这个策略</p>
<pre><code>strategy.debug()
</code></pre><p>如果你需要做回测</p>
<pre><code>strategy.run_backtest()
</code></pre><p>如果你需要让他直接挂模拟</p>
<p>在挂模拟的时候, 你需要注意一些东西</p>
<p>挂模拟的标的需要和真实标的一致<br>挂模拟的时候, 你的行情必须是有推送的, 并且申请了你所需要的的分钟线级别的数据</p>
<p>(如何申请行情数据? 你可以看这里 )<br><a href="https://github.com/yutiansut/QUANTAXIS_RealtimeCollector" target="_blank" rel="noopener">https://github.com/yutiansut/QUANTAXIS_RealtimeCollector</a></p>
<pre><code># 期货订阅请求
  curl -X POST &quot;http://127.0.0.1:8011?action=new_handler&amp;market_type=future_cn&amp;code=au1911&quot;
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 股票订阅请求</span></span><br><span class="line">curl -X POST <span class="string">"http://127.0.0.1:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001"</span></span><br><span class="line"><span class="comment"># 二次采样请求</span></span><br><span class="line">curl -X POST <span class="string">"http://127.0.0.1:8011?action=new_resampler&amp;market_type=future_cn&amp;code=au1911&amp;frequence=2min"</span></span><br><span class="line"></span><br><span class="line">对于小白可能难以理解curl是个啥, 此处给出一个简单易懂的代码</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">requests.post(<span class="string">"http://127.0.0.1:8011?action=new_handler&amp;market_type=future_cn&amp;code=&#123;&#125;"</span>.format(<span class="string">"rb2001"</span>)</span><br><span class="line">以此类推其他的请求都可以这么做</span><br></pre></td></tr></table></figure>

像 螺纹2001 合约, 你需要改成 rb2001  注意此处是小写

strategy =CCI(code=&apos;rb2001&apos;, frequence=&apos;1min&apos;,strategy_id=&apos;a3916de0-bd28-4b9c-bea1-94d91f1744ac&apos;)
strategy.debug_sim()
</code></pre><p>做完了这些操作以后, 你可以点击 回测 你就可以看到类似这样的结果</p>
<p><img src="/2020/08/20/QUANTAXIS/7.jpg" alt=""></p>
<ol start="7">
<li><p>更多参考</p>
<p> <a href="http://www.yutiansut.com:3000/topic/5dc5da7dc466af76e9e3bc5d" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5dc5da7dc466af76e9e3bc5d</a></p>
<p> 如何修改期货的实盘行情地址   <a href="http://www.yutiansut.com:3000/topic/5dfade9efe01257b44740e70" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5dfade9efe01257b44740e70</a></p>
<p> 实时如何申请行情  <a href="http://www.yutiansut.com:3000/topic/5dd1be9b0c8e672840f3fea7" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5dd1be9b0c8e672840f3fea7</a></p>
<p> 如何接入你的实盘期货账户  <a href="http://www.yutiansut.com:3000/topic/5dc865e8c466af76e9e3bdd1" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5dc865e8c466af76e9e3bdd1</a></p>
<p> 如何实现模拟盘/实盘的跟单  <a href="http://www.yutiansut.com:3000/topic/5ddb5ba8fe01257b4474080a" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5ddb5ba8fe01257b4474080a</a></p>
<p> docker 如何访问外部数据库  <a href="https://github.com/QUANTAXIS/QUANTAXIS/issues/1346" target="_blank" rel="noopener">https://github.com/QUANTAXIS/QUANTAXIS/issues/1346</a>   <a href="http://www.yutiansut.com:3000/topic/5e4531c96d3b182e88b4ebb4" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5e4531c96d3b182e88b4ebb4</a></p>
<p> docker小白用户的推荐 <a href="http://www.yutiansut.com:3000/topic/5e4cb13f6d3b182e88b4ef64" target="_blank" rel="noopener">http://www.yutiansut.com:3000/topic/5e4cb13f6d3b182e88b4ef64</a></p>
</li>
</ol>
<h2 id="整个环境一览"><a href="#整个环境一览" class="headerlink" title="整个环境一览"></a>整个环境一览</h2><p><img src="/2020/08/20/QUANTAXIS/8.jpg" alt=""></p>
<p>配置的一些备忘</p>
<p><img src="/2020/08/20/QUANTAXIS/9.jpg" alt=""></p>
<p><img src="/2020/08/20/QUANTAXIS/10.jpg" alt=""></p>
<p><img src="/2020/08/20/QUANTAXIS/11.jpg" alt=""></p>
<ol start="8">
<li>安装vscode可以调试docker</li>
</ol>
<h2 id="修改定时保存数据的时间"><a href="#修改定时保存数据的时间" class="headerlink" title="修改定时保存数据的时间"></a>修改定时保存数据的时间</h2><p>使用vscode进入qa-cron的容器中，进入目录 /etc/cron.d 修改daily_update里的时间即可，如果只需要保存期货数据，要改掉脚本里的  update_future.py</p>
<pre><code>部署
crontab daily_update
crontab -l
检查
/etc/init.d/cron start
/etc/init.d/cron status

解决在执行时提示 cron: can’t lock /var/run/crond.pid, otherpid may be 2699: Resource temporarily unavailable

解决方案： 

    rm -rf /var/run/crond.pid

    /etc/init.d/cron reload

    sudo /usr/sbin/service cron restart

如果定时不启用，可以在本地save保存数据，save不会覆盖之前已经下载好的数据
</code></pre><h2 id="在界面安装包"><a href="#在界面安装包" class="headerlink" title="在界面安装包"></a>在界面安装包</h2><pre><code>!ls
!pip -v
!pip install
!pip install qastrategy -U
在terminal界面也可以安装

from QUANTAXIS.QAARP.QAAccountPro import QA_AccountPRO
QA_AccountPRO?
</code></pre><h2 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h2><pre><code>docker-compose up -d nginx                     构建建启动nignx容器

docker-compose exec nginx bash            登录到nginx容器中

docker-compose down                              删除所有nginx容器,镜像

docker-compose ps                                   显示所有容器

docker-compose restart nginx                   重新启动nginx容器

docker-compose run --no-deps --rm php-fpm php -v  在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器

docker-compose build nginx                     构建镜像 。        

docker-compose build --no-cache nginx   不带缓存的构建。

docker-compose logs  nginx                     查看nginx的日志 

docker-compose logs -f nginx                   查看nginx的实时日志



docker-compose config  -q                        验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。 

docker-compose events --json nginx       以json的形式输出nginx的docker日志

docker-compose pause nginx                 暂停nignx容器

docker-compose unpause nginx             恢复ningx容器

docker-compose rm nginx                       删除容器（删除前必须关闭容器）

docker-compose stop nginx                    停止nignx容器

docker-compose start nginx                    启动nignx容器
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/GIT使用详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Airthink">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Airthink">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/GIT使用详解/" itemprop="url">Git使用详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T17:23:22+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git的安装和使用"><a href="#Git的安装和使用" class="headerlink" title="Git的安装和使用"></a>Git的安装和使用</h1><h2 id="下载安装Git"><a href="#下载安装Git" class="headerlink" title="下载安装Git"></a>下载安装Git</h2><pre><code>[https://git-scm.com/download/win](https://git-scm.com/download/win &quot;下载Git&quot;)
</code></pre><p><img src="/2020/06/17/GIT使用详解/1.png" alt=""></p>
<h2 id="下载完成后双击安装"><a href="#下载完成后双击安装" class="headerlink" title="下载完成后双击安装"></a>下载完成后双击安装</h2><h2 id="检验是否安装完成"><a href="#检验是否安装完成" class="headerlink" title="检验是否安装完成"></a>检验是否安装完成</h2><p>鼠标右击如果看到有两个git单词则安装成功</p>
<p><img src="/2020/06/17/GIT使用详解/2.png" alt=""></p>
<h1 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h1><h2 id="Git的工作区域"><a href="#Git的工作区域" class="headerlink" title="Git的工作区域"></a>Git的工作区域</h2><p><img src="/2020/06/17/GIT使用详解/3.png" alt=""></p>
<h2 id="向仓库中添加文件流程"><a href="#向仓库中添加文件流程" class="headerlink" title="向仓库中添加文件流程"></a>向仓库中添加文件流程</h2><p><img src="/2020/06/17/GIT使用详解/4.png" alt=""></p>
<h1 id="Git初始化及仓库创建和操作"><a href="#Git初始化及仓库创建和操作" class="headerlink" title="Git初始化及仓库创建和操作"></a>Git初始化及仓库创建和操作</h1><h2 id="Git安装之后需要进行一些基本信息设置"><a href="#Git安装之后需要进行一些基本信息设置" class="headerlink" title="Git安装之后需要进行一些基本信息设置"></a>Git安装之后需要进行一些基本信息设置</h2><ol>
<li>设置用户名：git  config – global  user.name  ‘你再github上注册的用户名’;</li>
<li>设置用户邮箱：git  config – global  user.email  ‘注册时候的邮箱’;</li>
</ol>
<p>注意：该配置会在github主页上显示谁提交了该文件</p>
<ol start="3">
<li>配置ok之后，我们用如下命令来看看是否配置成功</li>
</ol>
<p>　　git config –list</p>
<p>注意：git  config –global 参数，有了这个参数表示你这台机器上所有的git仓库都会使用这个配置，当然你也可以对某个仓库指定不同的用户名和邮箱</p>
<h2 id="初始化一个新的git仓库"><a href="#初始化一个新的git仓库" class="headerlink" title="初始化一个新的git仓库"></a>初始化一个新的git仓库</h2><ol>
<li>创建文件夹</li>
</ol>
<p>　　　　方法一：可以鼠标右击-》点击新建文件夹test1</p>
<p>　　　　方法二：使用git新建：$  mkdir test1</p>
<p><img src="/2020/06/17/GIT使用详解/5.png" alt=""></p>
<ol start="2">
<li>在文件内初始化git（创建git仓库）</li>
</ol>
<p>　　　　方法一：直接输入 $ cd test1</p>
<p>　　　　方法一：点击test1文件下进去之后-》鼠标右击选择Git Bash Here-&gt;输入$ git int</p>
<p><img src="/2020/06/17/GIT使用详解/6.png" alt=""></p>
<ol start="3">
<li>向仓库中添加文件　　</li>
</ol>
<p>　　方法一：用打开编辑器新建index.html文件</p>
<p>　　方法二：使用git命令。$  touch ‘文件名’，然后把文件通过$ git add ‘文件名’添加到暂存区，最后提交操作</p>
<p><img src="/2020/06/17/GIT使用详解/7.png" alt=""></p>
<ol start="4">
<li>修改仓库文件</li>
</ol>
<p>　　方法一：用编辑器打开index.html进行修改</p>
<p>　　方法二：使用git命令。$  vi  ‘文件名’，然后在中间写内容，最后提交操作</p>
<p><img src="/2020/06/17/GIT使用详解/8.png" alt=""></p>
<p><img src="/2020/06/17/GIT使用详解/9.png" alt=""></p>
<ol start="5">
<li>删除仓库文件</li>
</ol>
<p>　　方法一：在编辑器中直接把要删除的文件删除掉</p>
<p>　　方法二：使用git删除：$ git rm ‘文件名’，然后提交操作</p>
<p><img src="/2020/06/17/GIT使用详解/10.png" alt=""></p>
<h1 id="Git管理远程仓库"><a href="#Git管理远程仓库" class="headerlink" title="Git管理远程仓库"></a>Git管理远程仓库</h1><p><img src="/2020/06/17/GIT使用详解/11.png" alt=""></p>
<h1 id="Git克隆操作"><a href="#Git克隆操作" class="headerlink" title="Git克隆操作"></a>Git克隆操作</h1><p>目的：将远程仓库（github上对应的项目）复制到本地</p>
<p><img src="/2020/06/17/GIT使用详解/12.png" alt=""></p>
<h2 id="代码：git-clone-仓库地址"><a href="#代码：git-clone-仓库地址" class="headerlink" title="代码：git clone 仓库地址"></a>代码：git clone 仓库地址</h2><p>仓库地址由来如下：</p>
<h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p><img src="/2020/06/17/GIT使用详解/13.png" alt=""></p>
<h2 id="将本地仓库同步到git远程仓库中：git-push"><a href="#将本地仓库同步到git远程仓库中：git-push" class="headerlink" title="将本地仓库同步到git远程仓库中：git push"></a>将本地仓库同步到git远程仓库中：git push</h2><p><img src="/2020/06/17/GIT使用详解/14.png" alt=""></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><img src="/2020/06/17/GIT使用详解/15.png" alt=""></p>
<p>解决：这是通过Git GUI进行提交时发生的错误，由 .git 文件夹中的文件被设为“只读”所致，将 .git 文件夹下的所有文件、文件夹及其子文件的只读属性去掉即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Airthink">
          <p class="site-author-name" itemprop="name">Airthink</p>
           
              <p class="site-description motion-element" itemprop="description">The Pursuit of Happyness</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ikangbow" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Airthink</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
